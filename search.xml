<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue的基础用法]]></title>
    <url>%2F2018%2F08%2F30%2Fvue%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Vue是一套构建用户界面的渐进式框架。文档：https://cn.vuejs.org/v2/guide所有api：https://cn.vuejs.org/v2/api/ 模板语法声明时渲染Vue.js 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统。 文本插值 12345HTML&lt;div id="app"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; v-text：更新元素的 textContent其实，双花括号就是v-text的语法糖 123&lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;等同于&lt;p v-text="msg"&gt;&lt;/p&gt; 12345678JSvar app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125;&#125;) 此时，#app里的内容会变成Hello Vue 响应式修改：1app.message = '我被修改了' ps：除了数据属性，Vue 实例还提供了一些有用的实例属性与方法，它们都有前缀 $，以便与用户定义的属性区分开来1234567app.$el === document.getElementById('app') //&lt;div id="app"&gt;Hello Vue!&lt;/div&gt;app.$data // &#123;message:'Hello Vue!'&#125;app.$data.message // hello Vue!等同于app.message // Hello Vue v-html：更新元素的 innerHTML 123&lt;div id="app"&gt; &lt;div v-html="message"&gt;&lt;/div&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#app', data: &#123; message: '&lt;h1&gt;菜鸟教程&lt;/h1&gt;' &#125;&#125;) 参考文档：https://cn.vuejs.org/v2/guide/菜鸟教程：vue模板语法 补充知识 el:挂载点，不能是body data：数据对象，推荐在实例创建之前就预设好所有的数据 双花括号其实是v-text的语法糖 响应式系统123456789101112131415var data = &#123; a: 1 &#125;var app = new Vue(&#123; data: data //此时，vue的data与原始数据指向同一个地址&#125;)app.a == data.a // =&gt; true// 修改app.a会影响到原始数据app.a = 2data.a // =&gt; 2// ……反之亦然data.a = 3app.a // =&gt; 3 计算属性computed双括号里面一般用作声明，所以不推荐里面进行太过复杂的运算，在模板中放入太多的逻辑会让模板过重且难以维护123&lt;div id="app"&gt; &#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/div&gt; 推荐改成计算属性123&lt;div id="app"&gt; &#123;&#123; reversedMessage &#125;&#125;&lt;/div&gt; 1234567891011var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello' &#125;, computed: &#123;// 计算属性的 getter reversedMessage: function () &#123; return this.message.split('').reverse().join('') &#125; &#125;&#125;) 通过修改app.message可以得到不同的结果 除了计算属性，还能通过methods渲染12345HTML&lt;div id="app"&gt; &lt;p&gt;颠倒字符串: "&#123;&#123; x() &#125;&#125;"&lt;/p&gt;&lt;/div&gt; 12345678910111213JSnew Vue(&#123; el: "#app", data: &#123; msg:'12345' &#125;, methods: &#123; x: function()&#123; return this.msg.split('').reverse().join('') &#125; &#125;&#125;) p标签内最终呈现颠倒字符串:54321 计算属性的get和set计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter：查看在线例子通过计算属性的setter，我们可以间接修改它所依赖的属性 12345678910111213141516171819&lt;p&gt;&#123;&#123; fullName &#125;&#125;&lt;/p&gt;computed: &#123; //写成对象的格式 fullName: &#123; // getter get() &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set(newValue) &#123; const names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;当响应式修改vm.fullName = 'John Doe' 时，set 会被自动调用，然后通过get将fullName这个属性渲染到页面上 【计算属性是通过别的属性计算而来的，所以，直接修改this.fullName的值是没有用的；可以通过计算属性的setter，将它依赖的属性先修改了，从而改变计算属性】 计算属性的get和set实现全选返现功能12345678910computed:&#123; isAll:&#123; get()&#123; return this.todos.filter(todo =&gt; todo.done).length === this.todos.length &#125;, set(newVal)&#123; this.todos.forEach(todo =&gt; todo.done=newVal) &#125; &#125;&#125; v-model绑定了isAll,当勾选了这个框，就会调用set 【点击查看例子】 计算属性computed与方法methods的区别计算属性有缓存：https://cn.vuejs.org/v2/guide/computed.html 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。而使用 methods ，每当触发重新渲染时，函数总会重新调用执行。 来看个具体的例子123456789101112&lt;div id="app"&gt; &lt;span&gt; &#123;&#123;computedMessage&#125;&#125; &#123;&#123;computedMessage&#125;&#125; &#123;&#123;computedMessage&#125;&#125; &lt;/span&gt; &lt;span&gt; &#123;&#123;calcMessage()&#125;&#125; &#123;&#123;calcMessage()&#125;&#125; &#123;&#123;calcMessage()&#125;&#125; &lt;/span&gt; &lt;/div&gt; 123456789101112131415161718var app = new Vue(&#123; el: '#app', data: &#123; message: 'hi' &#125;, computed:&#123; computedMessage()&#123; console.log('computed') return 'computed ' + this.message &#125;, &#125;, methods:&#123; calcMessage()&#123; console.log('methods') return 'calc ' + this.message &#125; &#125;&#125;) 【点击查看例子】打开控制台，可以看到computed打印了1次，而methods打印了3次。 另外，从命名上可以看出，计算属性是一个属性，因此一般用于return一个具体的值，且在双括号中当做属性使用12&lt;!-- 计算属性 --&gt;&#123;&#123; sum &#125;&#125; 而methods一般用于执行方法，当它有return时才与计算属性类似，在双括号中必须执行这个方法12&lt;!-- 方法 --&gt;&#123;&#123; sum() &#125;&#125; 计算属性的应用场景如果是简单的处理，且最后将处理结果return出去作为属性值，推荐使用计算属性如果data里的属性是需要依靠其他属性计算得出，就将这个属性移到计算属性里(比如sum需要用到data里的其他属性计算后得出，那么就将这个sum属性移到计算属性里) 求总分 求平均分 处理简单字符串 vue的计算属性，通过调用缓存的sum求出average，提高了性能1234567&lt;div id="app"&gt; 数学&lt;input type="text" v-model.number="math"&gt; 英语&lt;input type="text" v-model.number="english"&gt; 语文&lt;input type="text" v-model.number="chinese"&gt; &lt;br&gt;总分:&#123;&#123;sum&#125;&#125; &lt;br&gt; 平均分:&#123;&#123;average&#125;&#125;&lt;/div&gt; 1234567891011121314151617var app = new Vue(&#123; el:'#app', data:&#123; math:90, english:85, chinese:87 &#125;, computed:&#123; sum()&#123; return this.math+this.english+this.chinese; &#125;, average()&#123; //直接把缓存的sum拿过来除以3 return this.sum/3; &#125;, &#125;&#125;) 如果用methods，那么每次都会重新调用sum 侦听属性watchhttps://cn.vuejs.org/v2/api/#watch 侦听属性watch，当侦听到data里数据的变化时，执行方法12345678910111213141516171819202122watch:&#123;//侦听maskSeen的值，如果发生改变就执行函数 maskSeen(newVal,oldVal)&#123; console.log(newVal); &#125;,//侦听currentUser.id的变化，当发生改变时，执行函数 'currentUser.id' : function (newVal,oldVal) &#123; console.log(newVal); console.log(oldVal); &#125;,//侦听路由的变化//下面这种写法是错的，不能使用箭头函数，因为箭头函数没有this！！！！！ '$route.query.page':(newVal,oldVal)=&gt;&#123; console.log(this); &#125; &#125;,//深度侦听【此时就不写成函数，而是写成对象的形式】lists: &#123; handler(newVal, oldVal) &#123; /* ... */ &#125;, deep: true //当lists变化，或者lists里面的某个值变化时，执行handler里的方法&#125;, 指令v- v-text：更新元素的 textContent v-html：更新元素的 innerHTML v-bind：动态地绑定一个或多个属性，或一个组件 prop 到表达式。 v-on：绑定事件监听器。 v-once：进入页面时 只渲染一次 之后即使数据变更也不再进行渲染 模板语法-指令：https://cn.vuejs.org/v2/guide/syntax.html 指令中，等号后面的冒号可以省略1234567&lt;p v-bind:id="songId"&gt;...&lt;/p&gt;&lt;p v-bind:id=songId&gt;...&lt;/p&gt; &lt;p :id=songId&gt;...&lt;/p&gt;&lt;p v-on:click="test"&gt;...&lt;/p&gt;&lt;p v-on:click=test&gt;...&lt;/p&gt;&lt;p @click=test&gt;...&lt;/p&gt; v-bind:xxx=&quot;yyy&quot;表示：将这个元素的xxx属性和 Vue 实例data中的yyy保持一致【用于绑定class、id、等各种属性，支持js语法】 v-on：绑定用户事件函数 v-model：在表单控件上双向绑定数据 v-html:双大括号里的内容默认以text的显示呈现，想要转换成html标签想要用v-html指令 v-bind用于绑定属性动态地绑定一个或多个特性，或一个组件 prop 到表达式。模板语法-特性：https://cn.vuejs.org/v2/guide/syntax.html 绑定data里的imgSrc123HTML&lt;img v-bind:src="imgSrc"&gt; 内联字符串拼接1&lt;img :src="'/path/to/images/' + fileName"&gt; 绑定data里的songUrl123HTML&lt;a v-bind:href="songUrl"&gt;...&lt;/a&gt; 绑定多个属性api:v-bind1&lt;div v-bind="&#123; id: someProp, 'other-attr': otherProp &#125;"&gt;&lt;/div&gt; 12//ES6中的省略写法&lt;div v-bind="&#123;loginpartSeen, login, signup, isLogin&#125;"&gt;&lt;/div&gt; &lt;span v-bind:title=&quot;message&quot;&gt;将这个元素的 title 属性和data中的message保持一致1234567HTML&lt;div id="app-2"&gt; &lt;span v-bind:title="message"&gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &lt;/span&gt;&lt;/div&gt; 12345678JSvar app2 = new Vue(&#123; el: '#app-2', data: &#123; message: '页面加载于 ' + new Date().toLocaleString() &#125;&#125;) 响应式修改：1app2.message = '新消息' //修改message的值 ps：1234567app2.$el app2.$dataapp2.$data.message等同于app2.message 使用 JavaScript 表达式双大括号里的内容可以看成是一个JS表达式只能包含单个表达式，判断语句请改成三元表达式12345678910111213HTML&#123;&#123; 1 + 1 &#125;&#125; // 2&#123;&#123; typeof 'hello' &#125;&#125; //string&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;div v-bind:id="'list-' + songId"&gt;&lt;/div&gt;&lt;div v-bind:id="`list-$&#123;songId&#125;`"&gt;&lt;/div&gt; 此外，支持window自身的全局变量，如 Math 和 Date v-bind绑定样式class与style绑定：https://cn.vuejs.org/v2/guide/class-and-style.html菜鸟教程：样式绑定 v-bind:class绑定class 基础用法1&lt;div :class="&#123;active:clickIndex === index&#125;"&gt;&lt;/div&gt; 我们可以使用三元表达式来切换样式12345&lt;!-- 行间样式 --&gt;&lt;div :style="mode===`edit`? '' : `width:260px;` "&gt;&lt;/div&gt; //注意字符串要用反点号&lt;!-- 切换clss --&gt;&lt;div :class=" isActive ? activeClass : '' "&gt;&lt;/div&gt; 固定绑定class1&lt;div :class="btnClass"&gt;&lt;/div&gt; 123data:&#123; btnClass:'btn active'&#125; 最终结果：&lt;div class=&quot;btn active&quot;&gt;&lt;/div&gt; 除了固定绑定class，我们还可以通过设置true/false来动态切换class 对象语法绑定class我们可以传给 v-bind:class 一个对象，以动态地切换 class，key为className，value为布尔值：123&lt;div :class="&#123; active: isActive &#125;"&gt;&lt;/div&gt;只有当data里的isActive为true时才添加.active 123data:&#123; isActive:true,&#125; 最终渲染成&lt;div class=&quot;active&quot;&gt;&lt;/div&gt; 通过app.isActive = false可以动态切换 ！注意当中有横杠的class名要加单引号123&lt;div class="static" //可以与普通类名共存 :class="&#123; active: isActive, 'text-danger': hasError &#125;"&gt; //text-danger要加单引号&lt;/div&gt; 1234data: &#123; isActive: true, hasError: false&#125; 最终渲染为1&lt;div class="static active"&gt;&lt;/div&gt; 上面的写法过于臃肿，如果有多个class名，可以写到同一个对象中，这样就不需要一个个单独写class名了，直接写这个对象名就行了123&lt;div class="static" //可以与普通类名共存 :class="classObject"&gt;&lt;/div&gt; 123456data: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125; 单独添加一个class名123&lt;div id="app"&gt; &lt;p :class="active"&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345678910111213141516new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue.js!', active:&#123;active:true&#125; // 对象语法一般用于多个class名，单个class名推荐用下面的方法 &#125;&#125;)等同于new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue.js!', active:'active', //单个class名推荐用这种方法 &#125;&#125;) 数组语法绑定class1&lt;div :class="[activeClass, errorClass]"&gt;&lt;/div&gt; 1234data: &#123; activeClass: 'active', errorClass: 'text-danger'&#125; 最终渲染为&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt; 三目运算1&lt;div :class="[a ? b : c ,xxx]"&gt;&lt;/div&gt; 123data:&#123; xxx:'d'&#125; 当data中的a为真值时，渲染为&lt;div class=&quot;b d&quot;&gt;&lt;/div&gt; 数组和对象语法混用绑定class1&lt;div :class="[&#123; active: isActive &#125;, errorClass]"&gt;&lt;/div&gt; 1234data:&#123; isActive:true, errorClass:'abc'&#125; 最终渲染为&lt;div class=&quot;active abc&quot;&gt;&lt;/div&gt; v-bind绑定内联样式style 对象语法绑定style 1&lt;div :style="&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;&lt;/div&gt; 1234data: &#123; activeColor: 'red', fontSize: 30&#125; 如果有多个样式，直接绑定到一个对象通常更好，这会让模板更清晰：123456data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' //驼峰式fontSize或者单引号'font-size' &#125;&#125; 1&lt;div :style="styleObject"&gt;&lt;/div&gt; 各种写法1234567A. &lt;p v-bind:class="className + '-container'"&gt; √B. &lt;p v-bind:class=className + '-container'&gt; × 【当中不能有空格】B2. &lt;p v-bind:class=className+'-container'&gt; √C. &lt;p v-bind:class="className + 'container'"&gt; ×D. &lt;p v-bind:class="$&#123;className&#125;-container"&gt; ×E. &lt;p v-bind:class="`$&#123;className&#125;-container`"&gt; √F. &lt;p v-bind:class=`$&#123;className&#125;-container`&gt; √ 作业：v-bind的作用，并分别写出v-bind的变量语法，数组语法，对象语法? v-bind通常用来绑定属性的，格式是v-bind：属性名 = “值”，简写:属性名 = “值”变量语法：v-bind：class = “变量”，变量形式 ,这里的变量的值，通常是在css定义好的类名数组语法：v-bind：class= “[变量1，变量2]” ，数组形式，其实跟上面差不多，只不过可以同时绑定多个class名对象语法：v-bind:class = {classname1：boolean，classname2：boolean}，对象形式，这里的classname1（2）其实就是样式表中的类名，这里的boolean通常是一个变量，也可以是常量、计算属性等，这种方法也是绑定class最常用的方式。 v-on事件处理绑定事件监听器12&lt;button v-on:click="counter += 1"&gt;增加 1&lt;/button&gt;&lt;p&gt;这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。&lt;/p&gt; 查看在线例子 绑定用户事件函数click时执行doSomething123HTML&lt;a v-on:click="doSomething"&gt;...&lt;/a&gt; &lt;button v-on:click=&quot;reverseMessage&quot;&gt;逆转消息&lt;/button&gt; ：click时执行reverseMessage函数123456HTML&lt;div id="app-5"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button v-on:click="reverseMessage"&gt;逆转消息&lt;/button&gt;&lt;/div&gt; 1234567891011var app5 = new Vue(&#123; el: '#app-5', data: &#123; message: 'Hello Vue.js!' &#125;, methods: &#123; reverseMessage: function () &#123; this.message = this.message.split('').reverse().join('') &#125; &#125;&#125;) PS:123app5.message //获取message的值app5.reverseMessage(); //执行reverseMessage Vue的data里的内容和methods里的内容都会挂载到实例对象之下,所以可以直接this.message和this.reverseMessage() 绑定多个方法12//ES6中的省略写法&lt;div v-on="&#123;clickSaveBtn, print, clickLogout&#125;"&gt;&lt;/div&gt; 除了绑定事件，还能绑定属性值123456HTML&lt;div id="app"&gt; &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt; &lt;button v-on:click="foo = 'baz'"&gt;Change it&lt;/button&gt;&lt;/div&gt; 12345678910JSvar obj = &#123; foo: 'bar'&#125;new Vue(&#123; el: '#app', data: obj&#125;) v-on绑定属性值1&lt;p @click="show=!show"&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; 修饰符模板语法-指令-修饰符：https://cn.vuejs.org/v2/guide/syntax.html 修饰符 (Modifiers) 是以.指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。 .prevent 修饰符用于阻止浏览器默认行为event.preventDefault() .stop修饰符用于阻止冒泡 .enter表示敲的是Enter键 事件修饰符1234567891011121314151617181920212223&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a @click.stop="doThis"&gt;&lt;/a&gt;&lt;!-- 提交表单时阻止刷新页面 --&gt;&lt;!-- 注意！！！submit事件要加在form表单身上，而不是按钮上 --&gt;&lt;form @submit.prevent="onSubmit"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a @click.stop.prevent="doThat"&gt;&lt;/a&gt;&lt;!-- 只有修饰符，没有事件 --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;&lt;!-- 使用捕获模式，而不是冒泡模式 --&gt;&lt;div @click.capture="doThis"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div @click.self="console.log('父')"&gt; &lt;div @click="console.log('子')"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- click 事件只触发一次 --&gt;&lt;a @click.once="doThis"&gt;&lt;/a&gt; 按键修饰符 enter tab delete (捕获 “删除” 和 “退格” 键) esc space up down left right ctrl alt shift meta（windows键，就是那个’田’字键） 12345678910&lt;!-- 只有在 keyCode 是 13 时调用方法 --&gt;&lt;input @keyup.13="submit"&gt;&lt;!-- Enter 时调用方法 --&gt;&lt;form @keyup.enter="onSubmit"&gt;...&lt;/form&gt;&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67="clear"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl="doSomething"&gt;Do something&lt;/div&gt; 你也可直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符：123&lt;input @keyup.page-down="onPageDown"&gt;PgDn按键的ev.key == PageDown，因此写成kebab-case形式 JS Bin【点击查看按键修饰符例子】 v-on多个事件123&lt;div id="app"&gt; &lt;div v-on="&#123;click:fnClick,mouseenter:fnEnter&#125;"&gt;Yo.&lt;/div&gt;&lt;/div&gt; 1234567891011var app = new Vue(&#123; el: '#app', methods: &#123; fnClick() &#123; console.log('clicked'); &#125;, fnEnter() &#123; console.log('entered'); &#125; &#125;&#125;) v-model表单控件双向绑定普通html用name=’xxx’来传递数据vue中用v-model替代name v-model实际上是个语法糖：123456 &lt;div id="app4"&gt; &#123;&#123;price&#125;&#125;&lt;br&gt; &lt;input v-model="price"&gt; &lt;!-- 等同于 --&gt; &lt;input :value="price" @input="price = $event.target.value"&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#app4', data: &#123; price: '20' &#125;&#125;); v-model可用于： input textarea select 普通input-text&lt;input v-model=&quot;message&quot;&gt; ：将输入框里的值与data里的message双向绑定123456HTML&lt;div id="app-6"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model="message"&gt;&lt;/div&gt; 123456var app6 = new Vue(&#123; el: '#app-6', data: &#123; message: 'Hello Vue!' &#125;&#125;) 单选⊙和多选框□菜鸟教程：单选修改颜色 一个简单的单选例子：123456&lt;div id="app"&gt; 香蕉&lt;input type="radio" v-model="fruit" value="香蕉"&gt;&lt;br&gt; 苹果&lt;input type="radio" v-model="fruit" value="苹果"&gt;&lt;br&gt; 桃子&lt;input type="radio" v-model="fruit" value="桃子"&gt;&lt;br&gt; 我最爱吃的水果：&#123;&#123;fruit&#125;&#125;&lt;/div&gt; 123456const app = new Vue(&#123; el:'#app', data:&#123; fruit:'' //单选用字符串,多选框用数组 &#125;&#125;) JS Bin【点击查看例子】 一个简单的多选框例子：12345678910111213&lt;div id="app"&gt; 男 &lt;input type="radio" v-model="gender" value="male"&gt; 女&lt;input type="radio" v-model="gender" value="female"&gt; &lt;br&gt;我的性别是：&#123;&#123;gender&#125;&#125; &lt;hr&gt; 西瓜&lt;input type="checkbox" v-model="fruits" value="melon"&gt; 苹果&lt;input type="checkbox" v-model="fruits" value="apple"&gt; 香蕉&lt;input type="checkbox" v-model="fruits" value="banana"&gt; 桃子&lt;input type="checkbox" v-model="fruits" value="peach"&gt; 我爱吃：&#123;&#123;fruits&#125;&#125;&lt;/div&gt; 12345678var app = new Vue(&#123; el: '#app', data: &#123; gender: 'male', //默认值,单选用字符串 fruits: ['melon', 'peach'] //默认值,多选用数组 &#125;&#125;) checkbox在checkbox中,v-model双向绑定多选框的勾选状态1&lt;input type="checkbox" v-model=todo.done&gt; 【点击查看例子】 全选与取消全选:https://c.runoob.com/codedemo/3870 select1234567891011&lt;div id="app"&gt; &lt;select v-model="city"&gt; &lt;!-- 推荐像下面这样提供一个value为空的禁用选项。 --&gt; &lt;option disabled value=""&gt;请选择&lt;/option&gt; &lt;option value="sh"&gt;上海&lt;/option&gt; &lt;option value="bj"&gt;北京&lt;/option&gt; &lt;option value="gz"&gt;广州&lt;/option&gt; &lt;option value="sz"&gt;深圳&lt;/option&gt; &lt;/select&gt; app.city=&#123;&#123;city&#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el:'#app', data:&#123; city:'bj',//默认值 &#125;,&#125;) v-model的修饰符 v-model.lazy :v-model默认实时监听数据的变化，添加lazy修饰符后，只有当blur或者按下Enter时才变更数据 v-model.trim v-model.number v-model.lazy1&lt;input type="text" v-model.lazy="userName"&gt; v-model，当在输入框输入内容时，实时动态更新数据添加修饰符.lazy之后，只有当blur或按下Enter键时才更新数据应用场景：表单验证时，用户一个字一个字输入时，我们不需要实时验证，等到用户把内容输入完后再验证用户信息JS Bin【点击查看例子】 v-model.trim去除前后空格1&lt;input type="text" v-model.trim="userName"&gt; v-model.number转成数字1&lt;input type="text" v-model.number="price"&gt; 输入框里的内容是字符串形式，如果后期需要对输入框里的值进行加减乘除运算，需要parseInt通过v-model.number可以简化上述操作，直接将字符串数字转成数字类型 v-htmlv-html：更新元素的innerHTML模板语法-原始HTML：https://cn.vuejs.org/v2/guide/syntax.html &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;：将data里的rawHtml以html标签的形式呈现1234HTML&lt;p&gt;以text形式呈现: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;转换成html标签: &lt;span v-html="rawHtml"&gt;&lt;/span&gt;&lt;/p&gt; ！！你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户在input中输入的内容使用v-html。 v-text：更新元素的 textContent其实，双花括号就是v-text的语法糖123&lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;等同于&lt;p v-text="msg"&gt;&lt;/p&gt; 条件渲染与循环渲染 v-if:true时插入DOM，false时从DOM中删除【对比v-show，true时显示，false时隐藏】 v-for：绑定数组里的数据来渲染一个项目列表 v-if条件渲染用于动态在DOM内添加或删除DOM元素注意，v-if会复用已有元素，如果不想复用，需要添加唯一的key&lt;p v-if=&quot;true&quot;&gt;我被插入到DOM中&lt;/p&gt;1234567891011121314HTML&lt;div id="app-3"&gt;//根据seen的true或false来改变p的插入/移除 &lt;p v-if="seen"&gt;现在你看到我了&lt;/p&gt;&lt;!-- 渲染后template标签消失 --&gt; &lt;template v-if="seen"&gt; &lt;h1&gt;菜鸟教程&lt;/h1&gt; &lt;p&gt;学的不仅是技术，更是梦想！&lt;/p&gt; &lt;p&gt;哈哈哈，打字辛苦啊！！！&lt;/p&gt; &lt;/template&gt;&lt;/div&gt; 1234567891011JSvar app3 = new Vue(&#123; el: '#app-3', data: &#123; seen: true &#125;&#125;)输入 app3.seen = false可以看到p标签被移除了 菜鸟教程：v-if Vue 在插入/更新/移除元素时自动应用过渡效果 v-if搭配template标签使用12345678910&lt;div id="app"&gt; &lt;p v-if="Seen"&gt;你看得见我吗？&lt;/p&gt;&lt;/div&gt;等同于&lt;div id="app"&gt; &lt;template v-if="Seen"&gt; &lt;p&gt;你看得见我吗？&lt;/p&gt; &lt;/template&gt;&lt;/div&gt; 当Seen为true时，template包含的内容会被渲染出来(template标签本身不会渲染)template只能和v-if搭配，不能和v-show搭配！ v-if，v-if-else，v-elsehttps://cn.vuejs.org/v2/guide/conditional.html#v-else-if 为了防止复用原有元素，需要指定唯一的key12345&lt;div id="app"&gt; &lt;div v-if="people===`admin` || people===`super_admin`" key="admin"&gt;你好，管理员&lt;/div&gt; &lt;div v-else-if="people===`hr`" key="hr"&gt;你好，hr&lt;/div&gt; &lt;div v-else key="user"&gt;你好，用户&lt;/div&gt;&lt;/div&gt; 123456var app = new Vue(&#123; el:'#app', data:&#123; people:'admin', &#125;&#125;) 12345678&lt;div id="app"&gt; &lt;div v-if="Math.random() &gt; 0.5"&gt; Sorry &lt;/div&gt; &lt;div v-else&gt; Not sorry &lt;/div&gt;&lt;/div&gt; 123new Vue(&#123; el: '#app'&#125;) 菜鸟教程：v-else v-for列表渲染绑定数组里的数据来渲染一个项目列表&lt;li v-for=&quot;todo in todos&quot;&gt;123456789HTML&lt;div id="app-4"&gt; &lt;ol&gt; &lt;li v-for="todo in todos"&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 123456789101112JSvar app4 = new Vue(&#123; el: '#app-4', data: &#123; todos: [ &#123; text: '学习 JavaScript' &#125;, &#123; text: '学习 Vue' &#125;, &#123; text: '整个牛项目' &#125; ], &#125;&#125;) 数组的响应式变更数组的更改响应式修改：123456789101112131415//直接改变原始数组app4.todos.push( &#123; text: '新项目' &#125; );//数组最后添加一个新项目app4.todos.pop() //抛出去最后一项app4.todos.shift() //删除数组中的第一项app4.todos.unshift( &#123;text:'xxx'&#125; ) //在数组最前面添加一项万能的.splice(起点,个数,插入值)app4.todos.splice(2,1) //从第2项开始，删除1项app4.todos.splice(2,0,&#123; text:'xxx' &#125;) //从第2项开始，删除0项，在第2为前面插入&#123;text:'xxx'&#125;app4.todos.sort((a,b)=&gt;a-b)appe.todos.reverse()//不会直接改变原始数组,需要手动进行替换app4.todos = app4.todos.filter(?)app4.todos = app4.todos.concat(?)app4.todos = app4.todos.slice(?) 无法响应式修改：123456app4.todos[0] = 123; //视图没有重新渲染app4.todos.length = 1; //视图没有重新渲染//解决方法：数组用万能的spliceapp4.todos.splice(0,1,123) //将第0项删除后替换成123app4.todos.splice(1) //只保留第一项 或者用this.$set(this.arr, index, newValue)https://cn.vuejs.org/v2/guide/list.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B91234567891011new Vue(&#123; el:'#app', data:&#123; todos:[0,1,2,3,4] &#125;, methods:&#123; change()&#123; this.$set(this.todos,1,'改变了') &#125; &#125;&#125;) 【点击查看例子】 v-for配合函数运算123456&lt;div id="app"&gt; &lt;ul&gt; //此处配合三元运算 &lt;li v-for="food in foods"&gt;&#123;&#123;food.name&#125;&#125;: $&#123;&#123;food.discount?food.price * food.discount:food.price&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1234567891011121314151617181920var app = new Vue(&#123; el: '#app', data: &#123; foods: [&#123; name: '葱', price: 10, discount: 0.5 &#125;, &#123; name: '姜', price: 5, discount: 0.45 &#125;, &#123; name: '蒜', price: 8 &#125;, ] &#125;&#125;) 可以通过app.foods.push({name:&#39;辣椒&#39;,price:3,discount:.4})进行添加 v-for数组渲染与对象渲染12345//数组&lt;div v-for="(item, index) in items"&gt;&lt;/div&gt;//对象&lt;div v-for="(val, key, index) in object"&gt;&lt;/div&gt; v-for迭代对象菜鸟教程：v-for 1&lt;li v-for="value in obj"&gt; 12345678910new Vue(&#123; el: '#app', data: &#123; obj: &#123; name: '菜鸟教程', url: 'http://www.runoob.com', slogan: '学的不仅是技术，更是梦想！' &#125; &#125;&#125;) 最后会将obj里的所有value渲染出来：查看在线例子 v-for迭代整数123&lt;li v-for="n in 10"&gt; &#123;&#123; n &#125;&#125;&lt;/li&gt; 123new Vue(&#123; el: '#app'&#125;) 查看在线例子 v-cloak由于css先加载，vue后加载，所以双括号一开始会闪现；解决办法：添加v-cloak，然后设置css。当vue加载完成后，这个v-cloak就会自动删除 123&lt;div id="app" v-cloak&gt; &#123;&#123;大胡子&#125;&#125;&lt;/div&gt; 123[v-cloak]&#123; display: none !important;&#125; 这样一来，双括号就不会闪现了 结合v-if和loading动画v-cloak可以不显示双花括号，但是会留白，此时用v-if配合loading动画123456&lt;div id="app" v-cloak&gt;&lt;div v-if="msg"&gt; &#123;&#123; msg &#125;&#125;&lt;/div&gt;&lt;div v-else&gt;loading.......&lt;/div&gt;&lt;/div&gt; v-cloak起到不显示双花括号的功能，v-if在生命周期获得msg后才显示页面内容，负责显示loading 缩写(v-bind与v-on)1234567891011&lt;a v-bind:href="songUrl"&gt;...&lt;/a&gt;v-bind:缩写成冒号:&lt;a :href="songUrl"&gt;...&lt;/a&gt;------------------&lt;a v-on:click="doSomething"&gt;...&lt;/a&gt;v-on:xxx缩写成@xxx&lt;a @click="doSomething"&gt;...&lt;/a&gt; 组件component 组件系统是 Vue 的一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理。组件用于提高代码的复用性，便于开发和维护。组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。所有的 Vue 组件同时也都是 Vue 的实例，所以可接受相同的选项对象 (除了一些根级特有的选项) 并提供相同的生命周期钩子。 组件的注册(组件的作用域)全局组件 将组件的template写到html里，然后在组件里传选择器 局部组件 父子组件通信父组件将数据传给子组件的props子组件无法直接修改父组件的数据，必须通过$emit()托付父组件，让父组件帮忙修改父组件的数据 12&lt;hello :xxx="name" @myfn="name='hello world!' + $event"&gt;&lt;hello&gt;//点击后，name变成hello world 123456789101112131415var hello = &#123; props:['xxx'], template:`&lt;h1 @click="$emit('myfn',参数)"&gt;&#123;&#123;xxx&#125;&#125;&lt;/h1&gt;`,&#125;;var app = new Vue(&#123; el:'#app', components:&#123; hello, &#125;, data:&#123; name:'stage', &#125;,&#125;) 组件绑定原生事件在 Vue 2.0 中，为自定义组件绑定原生事件必须使用 .native 修饰符：1&lt;my-component @click.native="handleClick"&gt;Click Me&lt;/my-component&gt; .sync 修饰符在有些情况下，我们可能需要对一个 prop 进行“双向绑定”，使子组件的prop修改时，父组件的data也跟着改变。为了方便起见，我们为这种模式提供一个缩写，即 .sync 修饰符,其实它是v-on:update的语法糖1234Vue.component('child-say',&#123; props:['msg'], template:`&lt;button @click="$emit('update:msg','儿子的值')"&gt;儿子改变父亲的data&lt;/button&gt;`,&#125;); 1234&lt;text-document :msg="msg" v-on:update:msg="msg = $event"&gt;&lt;/text-document&gt; 上面的代码用.sync语法糖改写如下：1&lt;child-say :msg.sync="msg"&gt;&lt;/child-say&gt; 【点击查看例子】 动态组件https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6Vue内置了一个component标签，依:is=&quot;组件名&quot;的值，来决定哪个组件被渲染。1&lt;component :is="cpName"&gt;&lt;/component&gt; JS Bin【点击查看例子】 在动态组件上使用 keep-alivehttps://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%9C%A8%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-keep-alive1234&lt;!-- 失活的组件将会被缓存！--&gt;&lt;keep-alive&gt; &lt;component :is="cpName"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 异步组件(按需加载，懒加载)文档：异步组件 如果一开始打开页面加载所有的组件，加载起来比较耗时，我们可以把一些组件定义为异步组件，在需要使用的时候再加载。 优点： 按需加载，可以节省首次加载的时间，提高页面打开的速度 第一次按需加载完成之后，会被缓存下来，再次使用这个组件时就不会重复加载了 默认情况下，webpack会把所有组件打包在一个js文件里，导致js文件过大；异步组件可以打包成独立的js文件，并且只有在这个组件需要被渲染的时候(比如 v-if 触发渲染)才会触发1234567&lt;!-- 一开始seen为false，页面中没有渲染该组件点击后，页面渲染该组件，于是异步加载 --&gt;&lt;change-skin v-if="seen" @click="seen = !seen"&gt;&lt;/change-skin&gt; 1234567const ChangeSkin = () =&gt; import(/* webpackChunkName: "change_skin" */ './ChangeSkin.vue');new Vue(&#123; components: &#123; ChangeSkin, 'my-component': () =&gt; import('./my-component') &#125;&#125;) 解析 DOM 模板时的注意事项https://cn.vuejs.org/v2/guide/components.html#%E8%A7%A3%E6%9E%90-DOM-%E6%A8%A1%E6%9D%BF%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9 有些 HTML 元素，诸如 ul、ol、table 和 select，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 li、tr 和 option，只能出现在其它某些特定的元素内部。12345678&lt;ul&gt; &lt;blog-post-row&gt;&lt;/blog-post-row&gt;&lt;/ul&gt;这个自定义组件 &lt;blog-post-row&gt; 会被HTML视作无效的内容提升到外部，导致最终渲染结果出错，变成&lt;blog-post-row&gt;&lt;/blog-post-row&gt;&lt;ul&gt;&lt;/ul&gt; 如果想让这个组件插入ul的内部，就要使用is属性123&lt;ul&gt; &lt;li is="blog-post-row"&gt;&lt;/li&gt;&lt;/ul&gt; 过滤器12345&lt;!-- 在两个大括号中 --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- 在 v-bind 指令中 --&gt;&lt;div v-bind:id="rawId | formatId"&gt;&lt;/div&gt; 文档：【过滤器】语法:123&lt;div&gt;&#123;&#123; message | xxx('参数1', 参数2) &#125;&#125;&lt;/div&gt; 默认第一个参数value是管道符前面的值，剩下的参数是人为传入的其他参数1234filters: &#123; xxx(value,参数1,参数2) &#123; return value + 参数1 + 参数2;&#125;, 过滤器一般用于处理文本的格式化，比如将data里的name变成大写，将data里的长度变成米，将data里的价格后面添上“元”等。又比如，过滤出todoLists里的所有、已完成、未完成 过滤器不会修改data里的值，只用于将data里的值格式化后渲染出来。过滤器由“管道”符号|表示：12345678&lt;div id="app"&gt; &lt;input type="text" v-model.number="length"&gt;毫米 &lt;p&gt;&#123;&#123; length | meter &#125;&#125;&lt;/p&gt; &lt;hr&gt; &lt;p&gt;&#123;&#123; money | country('人民币') &#125;&#125;&lt;/p&gt;&lt;/div&gt; Vue.filter(‘过滤器名称’, (管道前面的值,自定义传的值)={});123456789101112131415//在new Vue之前，注册一个全局过滤器Vue.filter('meter', (value)=&gt; &#123;//第一个参数value就是meter的值 return value/1000 + '米';&#125;);Vue.filter('country', (value,xxx)=&gt; &#123;//第一个参数value就是country的值,第二个参数xxx是传入的参数'人民币' return value + xxx;&#125;);new Vue(&#123; el:'#app', data:&#123; length:0, money:10, &#125;,&#125;); 【点击查看例子】 除了全局过滤器，还可以用局部过滤器123456789101112//局部过滤器new Vue(&#123; el:'#app', filters: &#123; meter(value) &#123; return value/1000 + '米'; &#125;, country(value,xxx) &#123; return value + xxx; &#125; &#125;&#125;); 除了双括号里可以用过滤器外,v-bind也可以 1&lt;div :id="length | meter"&gt;&lt;div&gt; 简单的数据格式化可以用filter，如果是复杂的数据格式化推荐用计算属性，因为计算属性本身带有缓存。 自定义指令自定义指令用于对普通 DOM 元素的复杂操作进行封装(比如元素的拖拽)。文档：【自定义指令】 全局指令1234567891011121314151617181920212223242526Vue.directive('pin',(el,binding)=&gt;&#123; //console.dir(binding) let pinned = binding.value;//等号右边的值 let position = binding.modifiers;//修饰符,&#123;bottom:true,right:true&#125; let type = binding.arg;//传参，'error' if(pinned)&#123; el.style.position='fixed'; for(key in position)&#123; el.style[key]='20px'; &#125; if(type=='error')&#123; el.style.background='red'; &#125; &#125;else&#123; el.style.position='static'; el.style.background='#ccc'; &#125;&#125;);new Vue(&#123; el:'#app', data:&#123; pinned:false, &#125;,&#125;); 12345&lt;div id="app"&gt; &lt;div class="card" v-pin:error.bottom.right="pinned"&gt; &lt;button @click="pinned=!pinned"&gt;钉住/取消&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 【点击查看例子】 局部指令除了全局指令，我们也可以注册局部指令1234567new Vue(&#123; directives: &#123; pin(el,binding)&#123; //doSomething &#125; &#125;&#125;) 一个最简单的例子：12345678910new Vue(&#123; el:'#app', directives: &#123; focus:&#123; inserted(el)&#123; el.focus(); &#125; &#125; &#125;&#125;) 1&lt;input type="text" v-focus&gt; JS Bin【点击查看例子：自动获取焦点】 对象字面量如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。1&lt;div v-demo="&#123; color: 'white', text: 'hello!' &#125;"&gt;&lt;/div&gt; 1234Vue.directive('demo', (el, binding) =&gt; &#123; console.log(binding.value.color) // =&gt; "white" console.log(binding.value.text) // =&gt; "hello!"&#125;) 钩子函数钩子函数的用法 bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中） update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 钩子函数参数https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0 12&lt;div v-demo:foo.a.b="msg"&gt;&lt;/div&gt;&lt;!-- msg的值为'hello' --&gt; 123456el // &lt;div&gt;&lt;/div&gt; 指令绑定的DOM元素binding.name //demobinding.value //hellobinding.expression //msgbinding.arg //foo 传给指令的参数binding.modifiers //&#123;a:true, b:true&#125; 是否传入修饰符a,b 自定义指令实现拖拽关于用自定义指令在vue中实现元素拖动JS Bin【点击查看例子：v-drag拖拽】 mixins混入(复用)将new Vue({options})里的options提取出来，从而使相同option得到复用 混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。文档：【混入】 1234&lt;div id="app"&gt; &lt;button @click="yellow"&gt;&#123;&#123;msg&#125;&#125;&lt;/button&gt; &lt;vue-hello&gt;&lt;/vue-hello&gt;&lt;/div&gt; 12345678910111213141516171819202122232425//定义要复用的混入var mixin = &#123; data()&#123; return &#123; msg:'hello world!', &#125; &#125;, methods:&#123; yellow(ev)&#123; ev.target.style.background='yellow'; &#125;, &#125;,&#125;;Vue.component('vue-hello',&#123; mixins:[mixin], template:`&lt;p @click="yellow"&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;`,&#125;);new Vue(&#123; el:'#app', //以数组的形式传入混用 mixins: [mixin],&#125;) 【点击查看例子】 !注意：当混入的数据和组件原有的数据重名时，以组件数据优先。 组件插槽插槽用于内容的分发。 将 &lt;slot&gt; 元素作为承载分发内容的出口。文档：【插槽】 单个插槽一个最简单的例子：1234567Vue.component('alert-box', &#123; template: ` &lt;div&gt; &lt;slot&gt;如果没有内容，我将作为默认内容显示；如果有内容，我将被分发的内容直接替换&lt;/slot&gt; &lt;/div&gt; `&#125;) 123&lt;alert-box&gt; &lt;h3&gt;自定义内容&lt;/h3&gt;&lt;/alert-box&gt; 当组件渲染的时候，这个 slot 标签将会被替换为&lt;h3&gt;自定义内容&lt;/h3&gt;。 最终渲染成：123&lt;div&gt; &lt;h3&gt;自定义内容&lt;/h3&gt;&lt;/div&gt; 多个插槽，取个名字有些时候我们需要多个插槽，这时可以给这些slot取个名字12345678910&lt;div id="app"&gt; &lt;vue-card&gt; &lt;h2 slot="title"&gt;标题&lt;/h2&gt; &lt;template slot="content"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/template&gt; &lt;p slot="more"&gt;更多信息&lt;/p&gt; &lt;/vue-card&gt; &lt;!-- 如果不传内容，将会显示slot的默认值 --&gt; &lt;vue-card&gt;&lt;/vue-card&gt;&lt;/div&gt; 12345678910111213141516//组件Vue.component('vue-card',&#123; template:` &lt;div class="card"&gt; &lt;div&gt; &lt;slot name="title"&gt;显示默认标题&lt;/slot&gt; &lt;/div&gt; &lt;div&gt; &lt;slot name="content"&gt;显示默认内容&lt;/slot&gt; &lt;/div&gt; &lt;div&gt; &lt;slot name="more"&gt;显示默认更多&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; `&#125;) 【点击查看例子】 作用域插槽作用域插槽 用途：从子组件的slot中获取数据1234567891011Vue.component('cp',&#123; template:`&lt;div&gt; &lt;slot :msg="msg" :count="count"&gt;&lt;/slot&gt; &lt;/div&gt;`, data()&#123; return &#123; msg:'子组件的内容', count:10 &#125; &#125;&#125;); 通过slot-scope=&quot;slotProps&quot;获取子组件的数据1234567891011121314151617&lt;div id="app"&gt; &lt;cp&gt; &lt;h2 slot-scope="xxx"&gt; &#123;&#123;xxx.msg&#125;&#125; --- &#123;&#123;xxx.count&#125;&#125; &lt;/h2&gt; &lt;/cp&gt;&lt;/div&gt;&lt;!-- 利用ES6解构赋值精简 --&gt;&lt;div id="app"&gt; &lt;cp&gt; &lt;h2 slot-scope="&#123;msg,count&#125;"&gt; &#123;&#123;msg&#125;&#125; --- &#123;&#123;count&#125;&#125; &lt;/h2&gt; &lt;/cp&gt;&lt;/div&gt; JS Bin【点击查看例子】 访问插槽通过this.$slots.插槽名[0]来访问插槽123456789Vue.component('cp',&#123; template:`&lt;div&gt; &lt;slot name="a"&gt;&lt;/slot&gt; &lt;/div&gt;`, mounted()&#123; console.log(this.$slots.a[0]); console.log(this.$slots.a[0].elm.innerText) &#125;&#125;); JS Bin【点击查看例子】 ref注册引用api:refref被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，ref指向的就是 DOM 元素；如果用在子组件上，ref就指向组件实例：12&lt;!-- `vm.$refs.xx` 指向这个DOM节点 --&gt;&lt;p @click="yy" ref="xx"&gt;Hello World!&lt;/p&gt; 123456789new Vue(&#123; el:'#app', methods:&#123; yy()&#123; //this.$refs.xx this.$refs['xx'].style.color='red'; &#125; &#125;&#125;) 【点击查看例子】注册单个元素时，相当于querySelector() 在v-for中要有下标[0]，因为$refs是个数组1&lt;p v-for="(list,i) in lists" :ref="i"&gt;&lt;/p&gt; 1this.$refs['i'][0].style.color='red'; 注册多个元素时，相当于querySelectorAll() vue的响应式更改数组的更新https://cn.vuejs.org/v2/guide/list.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9 由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如：this.items[index] = newValue 当你修改数组的长度时，例如：this.items.length = newLength 1234567var vm = new Vue(&#123; data: &#123; items: ['a', 'b', 'c'] &#125;&#125;)vm.items[1] = 'x' // 不是响应性的vm.items.length = 2 // 不是响应性的 为了解决第一类问题，可以用以下两种方式，达到响应式更改1234567// Vue.setthis.$set(this.todos, index, newValue)或者// Array.prototype.splicethis.todos.splice(index, 1, newValue) 【点击查看例子】 为了解决第二类问题，你可以使用 splice：1this.todos.splice(newLength) 对象的更新https://cn.vuejs.org/v2/guide/list.html#%E5%AF%B9%E8%B1%A1%E6%9B%B4%E6%94%B9%E6%A3%80%E6%B5%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9 深入响应式原理 还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：123456789var vm = new Vue(&#123; data: &#123; user:&#123;name:'stage'&#125; &#125;&#125;)// `vm.user.name` 现在是响应式的vm.user.age = 22//设置新值// `vm.user.age` 不是响应式的 可以使用 Vue.set(object, key, value)来解决这个问题1this.$set(this.obj, 'age', 22) 【点击查看例子】 另外，你也可以使用Object.assign，但是要注意123456789101112//不要写成这样！！！Object.assign(vm.user, &#123; age: 22, favoriteColor: 'Vue Green'&#125;)//建议写成这样！！！！vm.user = Object.assign(&#123;&#125;, vm.user, &#123; age: 22, favoriteColor: 'Vue Green'&#125;) VUE的练习题12345&lt;div id="app"&gt; &lt;span ____填空______&gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &lt;/span&gt;&lt;/div&gt; 123456var app = new Vue(&#123; el: '#app', data: &#123; message: '提示信息' &#125;&#125;) 答案：1234567891011v-bind:title="message"v-bind:title='message'v-bind:title=message其中，message===this.messagev-bind:title="this.message"v-bind:title='this.message'v-bind:title=this.message//以下是错误的！！！！！！v-bind:title="&#123;&#123;message&#125;&#125;" //双引号中不能出现&#123;&#123;&#125;&#125;符号 补充 Vue的data里的内容和methods里的内容都会挂载到实例对象之下,所以可以直接this.message和this.reverseMessage() computed 对象内的方法如果在初始化时绑定到元素上的事件会先执行一次这个方法 ，而 methods 内的方法则不会； 123&lt;div id="app"&gt; &#123;&#123;x&#125;&#125;&lt;/div&gt; 12345678new Vue(&#123; el: '#app', computed:&#123; x()&#123; alert(1); &#125; &#125;,&#125;) 进入页面时会自动执行computed里的方法 设置图片的默认值通过表达式||，当imgUrl为假值时，显示默认图片1&lt;img :src="imgUrl || defaultImg"&gt; vue中引入图片在html中1&lt;img src="@/assets/imgs/xxx.png"&gt; 这种方式是按照正常HTML语法引用路径 在js中12345678import avatar from '@/assets/logo.png'//然后在data里定义data()&#123; return &#123; avatar &#125;&#125; 接着就可以在html里绑定 &lt;img :src=&quot;avatar&quot; /&gt; 通过require引入图片1avatar:require("@/assets/xxx.png") 通过require可以实现动态设置图片1user.set('avatar',require(`imgs/$&#123;Math.floor(Math.random()*14)&#125;.png`)); 踩坑methods的方法名不能叫do1&lt;button @click="do"&gt;点我&lt;/button&gt; 12345678new Vue(&#123; el:'#app', methods:&#123; do()&#123; console.log(1); &#125; &#125;,&#125;) 方法名叫do会报错 methods的方法名不能叫delete1&lt;button @click="delete"&gt;删除&lt;/button&gt; 方法名叫delete会报错 初始值为null时如果数据的初始值是null data:{ list:null } 那么在渲染list.xxx时会报错cannot find xxx of null 解决方法：给最外层加上&lt;div v-if=&quot;list != null&quot;&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零配置打包工具Parcel]]></title>
    <url>%2F2018%2F08%2F30%2Fparcel%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[Parcel是一款极速零配置Web应用打包工具，省去了webpack那样的繁琐配置。它利用多核处理提供了极快的速度，并且不需要任何配置。 安装首先通过 Yarn 或者 npm 安装 Parcel ： Yarn:12345yarn global add parcel-bundler# 或者npm install -g parcel-bundler 初始化package.json 文件12345yarn init -y# 或者npm init -y 配置package.json1234"script": &#123; "start": "parcel index.html --open", "build": "parcel build index.html --no-source-maps --public-url ./"&#125; vue的注意事项如果你是用parcel打包，那么在你项目的 package.json 中添加：1234567&#123; // ... "alias": &#123; "vue" : "./node_modules/vue/dist/vue.common.js", "@" : "./src" &#125;&#125; 配置转译器babel新建.babelrc,yarn add babel-preset-env123&#123; "presets": ["env"]&#125; postcss新建.postcssrc,yarn add postcss-modules autoprefixer12345678&#123; "modules": true, "plugins": &#123; "autoprefixer": &#123; "grid": true &#125; &#125;&#125; hello word在当前文件夹下，创建 index.html 和 main.js 文件 123456&lt;!-- index.html --&gt;&lt;html&gt;&lt;body&gt; &lt;script src="./main.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12//main.jsalert('hello world') 然后运行npm start 打包npm run build parcel会自动install依赖1import Vue from 'vue' 此时，parcel会自动帮你install，不需要手动安装vue]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>打包工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex使用教程]]></title>
    <url>%2F2018%2F08%2F30%2FVuex%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Vuex 就是前端为了方便数据的操作而建立的一个” 前端数据库“，用来管理所有组件的数据。state 就是数据库getter 用来 获取 数据mutation 用来定义一些方法对数据进行 修改/存储actions 呢。你想呀，后端从前端拿到了数据，总要做个异步处理吧，处理完了再存到数据库中(.then( () =&gt; {异步处理完成后执行}))。其实这就是action的过程。如果是个同步操作，那么可以直接丢到数据库，所以vuex也可以在action 中直接存，就是直接mutation。在我看来，Vuex 相当于某种意义上设置了读写权限的全局变量，将数据保存保存到该“全局变量”下，并通过一定的方法去读写数据。 为什么使用Vuex如图所示，顶层父组件App有一个数据a:123,组件A想要获取这个数据，必须通过props一层层向下传App -&gt; G -&gt; A,B组件也想获取数据a，必须通过props一层层向下传App -&gt; E -&gt; D -&gt;B 如果B组件有个按钮，点击后想要修改a的值，则必须通过自定义事件$emit()一层层向上通知父组件B -&gt; D -&gt; E -&gt; App 如图所示，用了Vuex后，相当于建立了一个前端数据库，所有的组件都可以直接获取到Vuex里的数据，并且可以直接修改数据 使用场景 当一个项目的组件的层级有好几层，而且有些组件需要获取同一个数据时（避免数据一层层向下传递） 当不同的组件，它们有个事件是需要更改同一个数据时（避免自定义事件一层层向上传） 全局共享的数据使用vuex，比如用户信息，因为用户的权限，头像，昵称等等常常会出现在各个不同的组件中，此外，不需要实时更新的数据，都需要保存起来，减少不必要的http请求 Vuex的数据变化过程前端通过 action 进行异步处理数据后通过context.commit传递给mutation，然后通过 mutation 把数据放入数据库（state）中，哪个组件要用就通过getter 从数据库（state）中取。 更改 Vuex 的 store 中的状态的唯一方法是提交(commit) mutation 同步逻辑可以直接写到 mutation 里面，通过 this.$store.commit(&#39;xxx&#39;)进行提交 异步逻辑都应该封装到 actions 里面，通过 this.$store.dispatch(&#39;xxx&#39;) 方法调用 导出与注入123456789101112131415//store.js//使用Vueximport Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);//实例化const store = new Vuex.Store(&#123; state: &#123;&#125;, getters: &#123;&#125;, mutations: &#123;&#125;, actions: &#123;&#125;&#125;)export default store; 将store.js导入到入口文件，挂载到Vue实例的配置项里12345678910//main.jsimport Vue from 'vue'import router from './router/index.js'import store from './vuex/index.js'new Vue(&#123; el:'#app', router, store,&#125;) state 数据1234state: &#123; lists: [], count:0&#125; 在组件中获取state1&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; 通过this.$store.state.xxx就可以获取state里的数据了123456789//组件computed: &#123; count()&#123; return this.$store.state.count; &#125;, firstName()&#123; return this.$store.state.firstName; &#125; &#125;, 利用辅助函数mapState获取数据语法：...mapState([&#39;数据名1&#39;,&#39;数据名2&#39;])123computed: &#123; ...mapState(['count','firstName','lastName']),&#125; 也可以直接在html中通过$store.state获取【不推荐这种写法】123&lt;div id="app"&gt; &#123;&#123; $store.state.count &#125;&#125;&lt;/div&gt; mutation 变更mutation对state里的数据进行 修改/保存mutation里的方法，第一个参数始终是state，后面可以传入额外的参数文档：mutations123456mutations: &#123; getLists(state,lists)&#123; //变更状态 state.lists = lists; &#125;,&#125; 在组件中提交mutation(变更)请求如果mutations里的方法是同步操作，那么组件可以直接提交commit请求1234567//store.jsmutations: &#123; increment(state,payload)&#123; state.count += payload.add; &#125;&#125; 1234567//组件中methods: &#123; btnClick()&#123; this.$store.commit('increment',&#123;add:10&#125;); &#125;&#125; 你也可以直接在html中通过$store.commit提交变更请求123&lt;div id="app"&gt; &lt;p @click="$store.commit('increment',&#123;add:10&#125;)"&gt; &#123;&#123;$store.state.count&#125;&#125;&lt;/p&gt;&lt;/div&gt; 如果mutations里的方法需要异步执行，怎么办(比如setTimeout，1秒之后才执行state.count++)？通过actions！ actions 调用文档：action在actions中，通过context.commit()来调用mutations里的方法123456789actions: &#123; getLists(context)&#123; axios.get('www.xxx.com').then((&#123;data&#125;)=&gt; &#123; /调用mutations里的init方法，并将data.lists作为参数传过去 context.commit('init',data.lists); &#125;) .catch(error =&gt; document.write(error)); &#125;,&#125; 实践中，我们会经常用到 ES2015 的 参数解构 来简化代码（特别是我们需要调用 commit 很多次的时候）：123456789actions: &#123; getLists(&#123;commit, state&#125;)&#123; //对象的解构赋值 axios.get('www.xxx.com').then((&#123;data&#125;)=&gt; &#123; commit('init',data.lists); &#125;) &#125;,&#125; 在组件中提交action(调用)请求在组件中,通过dispatch调用action,然后store.state.xxx获取数据文档：组件通过dispatch调用vuex里的actions组件通过this.$store.dispatch()调用store实例里面 actions里定义的方法，然后在计算属性computed里通过return this.$store.state获得state里的数据12345678910111213141516171819//组件Address.vue&lt;script&gt; export default &#123; //将getter到的数据放在计算属性里 computed: &#123; lists()&#123; return this.$store.state.lists; &#125; &#125;, created()&#123; if(!lists.length)&#123; //通过dispatch调用actions里的方法，返回想要的数据 this.$store.dispatch('getLists'); &#125; &#125; &#125;&lt;/script&gt; mapActionsmapActions 映射为 this.$store.dispatch123456789101112131415import &#123; mapActions &#125; from 'vuex'export default &#123; methods: &#123; ...mapActions([ 'addAddress', // 将 `this.addAddress()` 映射为 `this.$store.dispatch('addAddress')` // `mapActions` 也支持载荷： 'removeAddress' // 将 `this.removeAddress(xxx)` 映射为 `this.$store.dispatch('removeAddress', xxx)` ]), ...mapActions(&#123; yyy: 'getMyAddress' // 将 `this.yyy()` 映射为 `this.$store.dispatch('getMyAddress')` &#125;) &#125;&#125; mapStatemapState 映射为 this.$store.state.xxx当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。此时可以用使用 mapState 辅助函数，然后将数据放入组件的计算属性内12345678import &#123; mapState &#125; from 'vuex'export default &#123; computed: mapState(&#123; // 传字符串参数 'count' xxx: 'count', //此时，this.xxx = store.state.count &#125;)&#125; 如果映射的计算属性的名称与 state 里的名称相同时，我们也可以给 mapState 传一个字符串数组。1234computed: mapState([ // 映射 this.count 为 store.state.count 'count']) 如果该组件有自己的计算属性，怎么办？混入计算属性12345678computed: &#123; xxx() &#123; /* ... */ &#125;, // 使用对象展开运算符将store.state里的数据混入computed ...mapState(&#123; count: 'count', &#125;)&#125; 像上面这种key和value相同的情况，可以将对象写成数组的形式123computed: &#123; ...mapState(['count']),&#125; Gettergetter类似Vue中的计算属性 有时候我们需要从 store 中的 state 中派生出一些状态，例如需要将state中的firstName和lastName合并,这时需要定义一个计算属性fullName123456//main.jscomputed: &#123; fullName () &#123; return this.$store.state.firstName + this.$store.state.lastName; &#125;&#125; 如果有多个组件需要用到此属性，我们就得每次都手写一遍这个计算属性的代码，Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。12345678910111213141516//store.jsconst store = new Vuex.Store(&#123; state: &#123; firstName: 'Harry', lastName: 'Potter' &#125;, getters: &#123; fullName: state =&gt; &#123; return state.firstName + state.lastName; &#125;, //推荐写成下面这种写法 fullName(state)&#123; return state.firstName + state.lastName; &#125; &#125;,&#125;) 然后，所有的组件都可以通过this.$store.getters.fullName获取这个属性文档:Getter1234567//在子组件中computed: &#123; fullName()&#123; return this.$store.getters.fullName; &#125;&#125; 等同于12345//在子组件中computed:&#123; ...mapGetters(['fullName']);&#125; !注意，store.js自身无法获取getters里面的数据；在Vue中，可以直接获取计算属性，但是在Vuex中，无法获取getters里的数据12345678910111213141516//store.jsconst store = new Vuex.Store(&#123; state: &#123; a:1, &#125;, getters: &#123; aPlus: state =&gt; &#123; return state.a + 1; &#125; &#125;, mutations: &#123; xxx(state)&#123; this.aPlus + 1; //警告！这是错误的，因为store.js只能操作state里的数据,无法操作getters里的数据 &#125;, &#125;&#125;) 其实，从mutation的第一个参数可以看出，它是通过第一个参数 state 来间接修改state里的数据；而mutation内部并没有提供getters这个参数 mapGetters文档：mapGettersmapGetters 映射为 this.$store.getters.xxx123456789101112131415import &#123; mapGetters &#125; from 'vuex'export default &#123; computed: &#123; // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ 'a', 'others', // ... ]), ...mapGetters(&#123; b:'xxx', //如果key和value不同名，数组要改写成对象的形式 &#125;) &#125;&#125; 关于辅助函数12345678910111213141516import store form './store.js' //千万别忘了把store注入到Vue实例内！！！！import &#123; mapState, mapGetters, mapMutations, mapActions &#125; from 'vuex'new Vue(&#123; el: "#app", store, computed: &#123; //state和getters放在计算属性内 ...mapState(['lists']), ...mapGetters(['aPlus']), &#125;, methods: &#123; //mutations和actions放在methods内 ...mapMutations(['add','remove']),//同步操作，可以直接通过mutation修改state里的数据，不需要借助action的commit ...mapActions(['asyncFn']),//异步操作 &#125;&#125;) 辅助函数传递payload载荷要在html中传递过去，而不是在methods里！！！！1&lt;button @click="add(5)"&gt;+5&lt;/button&gt; 12345//组件中methods: &#123; ...mapMutations(["add"]) &#125; 12345//store.js mutations: &#123; add(state,n) &#123; state.count += n; &#125;, 参考地址：https://segmentfault.com/q/1010000011006052 另一种方式传递payload单独在methods里定义一个方法来调用123456methods:&#123; ...mapActions(['add']), handleClick()&#123; this.add(&#123;amount:100&#125;) &#125;&#125; 1&lt;button @click="handleClick"&gt;登录&lt;/button&gt; 参考地址：https://segmentfault.com/q/1010000009563211 module如果将所有页面的数据全部放在一个store里，会显得十分臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、getter、mutation、action12345678910111213141516171819// src/store/index.js//新建文件夹modules，用来放模块//使用Vueximport Vue from 'vue';import Vuex from 'vuex';import user from './modules/user.js';import blog from './modules/blog.js';Vue.use(Vuex);const store = new Vuex.Store(&#123; modules: &#123; user, blog &#125;&#125;);export default store; 123456789101112131415// user.js 和 blog.js的模板如下const state = &#123;&#125;;const getters = &#123;&#125;;const mutations = &#123;&#125;;const actions = &#123;&#125;;export default &#123; state, getters, mutations, actions&#125; 从而实现，每个模块单独维护各自的数据状态 模块的局部状态对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态state。1234567891011121314//模块user.js// 这里的 `state` 对象是模块的局部状态const getters = &#123; doubleCount (state) &#123; return state.count * 2； &#125;&#125;;const mutations = &#123; increment (state) &#123; state.count++; &#125;&#125;; 对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState：1234567actions: &#123; incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123; if ((state.count + rootState.count) % 2 === 1) &#123; commit('increment') &#125; &#125;&#125; 在组件中获取模块中的数据12345//组件中...mapState(&#123; isLogin:state =&gt; state.moduleA.isLogin, name:state =&gt; state.moduleB.name&#125;) 导入封装的$request123//在入口文件 store/index.jsimport request from '@/utils/request.js';Vuex.Store.prototype.$request = request; 然后就能在vuex中直接使用this.$request()了]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router使用教程]]></title>
    <url>%2F2018%2F08%2F30%2Fvue-router%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[vue-router的使用教程 路由路由就是，根据地址栏的路径，返回对应的页面 后端路由node.js写法123456789if(path === '/')&#123; 返回主页&#125;else if(path==='/page1')&#123; 返回page1&#125;else if(path==='/page2')&#123; 返回page2&#125;else &#123; 返回404&#125; 前端路由vue-router写法123456789101112131415161718192021222324const routes = [ &#123; path: '/page1', component: Page1 &#125;, &#123; path: '/page2', component: Page2 &#125;]``` # 基础使用```html&lt;script src="https://cdn.bootcss.com/vue/2.5.16/vue.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js"&gt;&lt;/script&gt;&lt;div id="app"&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to="/page1"&gt;Go to page1&lt;/router-link&gt; &lt;router-link to="/page2"&gt;Go to page2&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将塞到这里渲染出来 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; router-link默认渲染成带有正确链接的a标签，可以通过配置 tag 属性生成别的标签.。参考文档 1234567891011121314151617181920212223242526//使用vue-routerimport Vue from 'vue'import VueRouter from 'vue-router'Vue.use(VueRouter)//1. 定义组件const Page1 = &#123; template: '&lt;div&gt;这里是页面1&lt;/div&gt;' &#125;//也可以通过 import 导入进来import Page2 from './components/Page2.vue'// 2. 配置路由const routes = [ &#123; path: '/page1', component: Page1 &#125;, &#123; path: '/page2', component: Page2 &#125;]// 3. 创建 router 实例，然后将配置 `routes` 传入const router = new VueRouter(&#123; routes // （缩写）相当于 routes: routes&#125;)// 4. 将router传给appconst app = new Vue(&#123; router, el:'#app',&#125;); routes配置选项 例子2123456789&lt;div id="app"&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to="/"&gt;首页&lt;/router-link&gt; &lt;router-link to="/about"&gt;关于我们&lt;/router-link&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 12345678910111213141516171819202122//配置路由const routes = [&#123; path: '/', component: &#123; template: `&lt;div&gt;&lt;h1&gt;这里是首页&lt;/h1&gt;&lt;/div&gt;`, &#125;,&#125;, &#123; path: '/about', component: &#123; template: `&lt;div&gt;&lt;h1&gt;这里是关于我们&lt;/h1&gt;&lt;/div&gt;`, &#125;,&#125;, ];//将配置好的路由传给实例const router = new VueRouter(&#123; routes // (缩写) 相当于 routes: routes&#125;);const app = new Vue(&#123; el:'#app', router,&#125;); 【查看在线实例】 路由传递参数(动态路由匹配)文档：动态路由匹配 路径参数paramspath:&#39;/user/:username&#39;，则this.$route.params.username就是user/后面的值地址栏显示为：localhost:8080/#/user/王花花 直接传递参数1&lt;router-link to="/user/王花花"&gt;王花花&lt;/router-link&gt; 或者通过name和params传递路径参数1234&lt;router-link :to="&#123;name:'UserName', params:&#123;username:'王花花'&#125;&#125;"&gt;王花花&lt;/router-link&gt;&lt;!-- 不能用path，否则报错！！！！必须用 name --&gt;&lt;router-link :to="&#123;path:'/user', params:&#123;username:'王花花'&#125;&#125;"&gt;王花花&lt;/router-link&gt; “路径参数”使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。12345678910//配置路由const routes = [&#123; // 动态路径参数 以冒号开头 path: '/user/:username', name:'UserName', component: &#123; //通过$route.params.username获取路径参数 template: `&lt;div&gt;&lt;h1&gt;我叫 &#123;&#123;$route.params.username&#125;&#125;&lt;/h1&gt;&lt;/div&gt;`, &#125;,&#125;, ]; 查询参数query/xxx?a=1&amp;b=2，则this.$route.query就是问号后面的内容地址栏显示为：localhost:8080/#/user/王花花?age=20 直接传递参数1&lt;router-link to="/user/王花花?age=20"&gt;王花花&lt;/router-link&gt; 或者通过name / path 和 query传递参数1234&lt;router-link :to="&#123;name:'UserName',query:&#123;xxx:123&#125;&#125;"&gt;王花花&lt;/router-link&gt;&lt;!-- 等同于 --&gt;&lt;router-link :to="&#123;path:'/user/王花花',query:&#123;xxx:123&#125;&#125;"&gt;王花花&lt;/router-link&gt; 通过$route.query.xxx获取查询参数123456789//配置路由const routes = [&#123; // 动态路径参数 以冒号开头 path: '/user/:name', name:'UserName', component: &#123; template: `&lt;div&gt;&lt;h1&gt;我叫 &#123;&#123;$route.params.name&#125;&#125;&lt;/h1&gt;&lt;h2&gt;我今年&#123;&#123;$route.query.age&#125;&#125;岁了&lt;/div&gt;`, &#125;,&#125;, ]; 【查看在线实例】 嵌套路由(子路由)在配置routes时添加 children12&lt;router-link to="/user/王花花"&gt;王花花&lt;/router-link&gt;&lt;router-link to="/user/李栓蛋"&gt;李栓蛋&lt;/router-link&gt; !注意：children里path前不要加/可以使用append在路径后面追加more,但是append每次点击会重复追加123456789101112131415161718192021//配置路由const routes = [&#123; // 动态路径参数 以冒号开头 path: '/user/:name', component: &#123; template: `&lt;div&gt;&lt;h1&gt;我叫 &#123;&#123;$route.params.name&#125;&#125;&lt;/h1&gt; //↓由于是动态路径，所以这里是:to，不要漏了冒号&lt;router-link :to="'/user/'+$route.params.name+'/more'"&gt;更多信息&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt;`,//或者使用append,追加more这一页 &#125;,//子路由是个数组,如果有多个同级子路由,则写在一个数组里 children:[ &#123; path:'more',//这里不要写成'/more' component:&#123; template:`&lt;div&gt;&lt;h3&gt;用户&#123;&#123;$route.params.name&#125;&#125;的信息&lt;/h3&gt;loremloremloremlorem&lt;/div&gt;`, &#125;, &#125; ],&#125;, ]; 【查看在线实例】 !注意：记得给父路由里router-view，否则子路由没有出口展示 通过命名路由可以简化路径的写法原本的路径是/user/王花花1&lt;router-link to="/address/form"&gt;编辑地址&lt;/router-link&gt; 通过命名路由12345678910children: [&#123; path: 'choose', name:'choose', component: ChooseAddress, &#125;, &#123; path: 'form', name:'form', component: AddressForm, &#125;] 可以将router-link简写成1&lt;router-link :to="&#123; name: 'form'&#125;"&gt;User&lt;/router-link&gt; router-link相关api 编程式导航除了使用 &lt;router-link&gt; 创建 a 标签来定义导航链接，有时我们想点击一个按钮来切换页面，这时可以给按钮绑定@click=$router.push(&#39;/xxx&#39;)，借助 router 的实例方法，通过编写代码来实现。$router.push(location, onComplete?, onAbort?)注意：在 Vue 实例内部，你可以通过 $router 访问路由实例。因此你可以调用 this.$router.push。$router的相关方法：https://router.vuejs.org/zh/api/#router-aftereach 123&lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 可以使用$router.push(&#39;/index&#39;),如果有参数的话，可以使用 $router.push({name:&#39;index&#39;,params:{userId:12345}}) 或者$router.push(\/index/${userId}`)` 1234567891011121314151617181920212223242526272829303132//1. 定义组件const Login = &#123; template: ` &lt;div&gt;登录界面 &lt;button @click="$router.push('/')"&gt;返回&lt;/button&gt; &lt;/div&gt;` &#125;;const Index = &#123; template: '&lt;button @click="login"&gt;登录&lt;/button&gt;', methods:&#123; login()&#123; this.$router.push('/login'); &#125;, &#125;,&#125;;// 2. 定义路由const routes = [ &#123; path: '/', component: Index &#125;, &#123; path: '/login', component: Login &#125;, &#123; path: '*', component: NotFound &#125; //放到最后面];// 3. 创建 router 实例，然后传 `routes` 配置const router = new VueRouter(&#123; routes // （缩写）相当于 routes: routes&#125;);// 4. 将router传给appconst app = new Vue(&#123; router, el:'#app',&#125;); 【查看在线实例】 编程式导航 vs router-link1234&lt;router-link:to="&#123;name: 'form', query: &#123; type: 'add' &#125;&#125;"&gt;新增地址&lt;/router-link&gt; 等同于123addAddress()&#123; this.$router.push(&#123;name: 'form', query: &#123; type: 'add' &#125;&#125;)&#125; router-push 命名路由(给routes取名字name)有时候，通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称。12345//配置路由const routes = [ &#123; path: '/user', name:'user', component: User &#125;, &#123; path: '/login', name:'login', component: Login &#125;]; 要链接到一个命名路由，可以给 router-link 的 to 属性传一个对象：1&lt;router-link :to="&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"&gt;User&lt;/router-link&gt; 这跟代码调用 router.push() 是一回事：1$router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;) 这两种方式都会把路由导航到 /user/123 路径。 命名视图(多个出口取名字)文档：命名视图 有时候想在同一个页面上同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar (侧边栏) 和 content (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default所对应的组件。 123456789101112const router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; default: TopNav, a: Content, b: SideBar &#125; &#125; ]&#125;) 123&lt;router-view class="default" /&gt;&lt;router-view class="content" name="a" /&gt;&lt;router-view class="sidebar" name="b" /&gt; 重定向(跳转)文档：重定向 当访问 /a时， 重定向到 /b12345//配置路由const routes = [ &#123; path: '/a', redirect: '/b' &#125;, &#123; path: '*', redirect: '/'&#125; //当匹配不到路由时，重定向到首页] 重定向的目标也可以是一个命名的路由：123const routes = [ &#123; path: '*', redirect: &#123; name: 'index' &#125;&#125;] 路由按顺序从上到下，依次匹配。最后一个*能匹配全部,因此要放在最后面！！！ 响应路由参数的变化 当使用路由参数时，例如从 /user/王花花 导航到 /user/李栓蛋，由于路径都是/user/:username,因此页面不会更新数据。想对路由参数的变化作出响应的话，你可以在组件中通过 watch (监测变化) $route 对象 123456789//组件中export default &#123; watch: &#123; '$route'(to, from) &#123; //当$route发生变化时,获取最新的数据 this.getData(); &#125; &#125;&#125; 导航守卫/导航钩子(路由改变时进行验证)“导航”表示路由正在发生改变。 全局守卫文档：全局守卫12&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;router-link to="/admin"&gt;后台管理&lt;/router-link&gt; 12345678910111213141516const router = new VueRouter(&#123; ... &#125;)//全局守卫router.beforeEach((to, from, next) =&gt; &#123; //console.log(to); //console.log(from); let logined=false; //如果要前往admin页面，且处于未登录状态 if(to.path =='/admin' &amp;&amp; !logined)&#123; //则跳转到登录页 next('/login'); &#125;else&#123; next(); &#125;&#125;) router.beforeEach:当路由改变之前 to、from都是路由对象，相关api参考路由对象API next():正常导航 next(false):禁止导航 next(&#39;/xxx&#39;):中断当前导航，跳转到/xxx 【查看在线实例】 路由元信息及匹配导航守卫里，验证方式太过单一123456789if(to.path =='/admin' &amp;&amp; !logined)&#123; //则跳转到登录页 next('/login'); &#125;else&#123; next();&#125;在未登陆状态时，如果要前往/admin,则会跳转到/login页面！但是,如果要前往/admin/db，仍然可以前往，即使在未登录状态下 如何在未登录状态下,/admin及/admin下面的所有内容都无法访问？我们可以在定义路由的时候可以配置 meta 字段12345678910111213141516171819202122232425262728293031323334353637//配置路由const routes = [&#123; path: '/login', component: &#123; template: `&lt;h1&gt;请先登录&lt;/h1&gt;`, &#125;,&#125;,&#123; path: '/admin', meta:&#123; logined:false, &#125;, component: &#123; template: `&lt;div&gt;&lt;h1&gt;管理员页面&lt;/h1&gt;&lt;router-link to="/admin/db"&gt;数据库&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;`, &#125;, children:[ &#123; path:'db', component:&#123;template:`&lt;h2&gt;这里是数据库&lt;/h2&gt;`&#125;, &#125; ],&#125;,&#123; path: '/admin2', meta:&#123; logined:false, &#125;, component: &#123; template: `&lt;h1&gt;这里是另一个管理员页面&lt;/h1&gt;`, &#125;,&#125;]; 那么如何访问这个 meta 字段呢？通过路由对象(to、from都是路由对象)的matched属性，得到路由配置routes里的路由记录(是个数组);再通过.some()方法遍历这个数组下的meta字段1234567891011//全局守卫router.beforeEach((to, from, next) =&gt; &#123; console.log(to.matched); //遍历路由对象，检查里面的meta信息 //some() 方法用于检测数组中的元素是否满足指定条件，满足返回true，不满足返回false if(to.matched.some(item=&gt;item.meta.logined))&#123;//此处为判断item.meta.logined===true的简写形式 next(); &#125;else&#123; next('/login'); &#125;&#125;) 【查看在线实例】 meta的详细用法1234567891011121314151617181920212223242526272829import store from '@/store';//引入vuexconst router = new Router(&#123; routes: [ &#123; path: '/', name: 'index', component: () =&gt; import(/* webpackChunkName: "index" */ '@/pages/index/Index.vue'), meta: &#123; requireLogin:true //需要验证登录状态 &#125; &#125; ]&#125;)router.beforeEach((to,from,next) =&gt;&#123; if(to.matched.some(record =&gt; record.meta.requireLogin))&#123;//如果该路由需要验证登录状态 if(!store.state.auth.isLogin)&#123;//如果没有登录 next(&#123;//跳转到登录页 path:'/login', query: &#123; redirect: to.fullPath &#125;,//查询参数显示：从哪儿跳转而来，这样登录以后，可以从查询参数得到路径设置跳转回去 &#125;); &#125; else&#123;//如果已经登录 next(); &#125; &#125; else&#123;//如果不需要验证登录状态，则直接跳转 next(); &#125;&#125;) 如果是异步操作，可能还未获取到状态，就已经跳转了，因此异步验证异步状态需要改写成这样：12345678910111213141516router.beforeEach((to,from,next) =&gt;&#123; if(to.matched.some(record =&gt; record.meta.requireLogin))&#123;//如果该路由需要验证登录状态 store.dispatch('checkLogin').then(isLogin=&gt;&#123; //从vuex获取登录状态后，再跳转 if(!isLogin)&#123; next(&#123; path:'/login', query:&#123;redirect:to.fullPath&#125; &#125;); &#125; else&#123; next(); &#125; &#125;) &#125; else&#123; next(); &#125;&#125;) 然后在登录页设置一下，让它登录后跳转回原来的页面1234567clickLoginBtn()&#123; this.$request(.......) .then(()=&gt;&#123; this.$router.push(&#123;path: this.$route.query.redirect || '/'&#125;) //或者 this.$router.back(); &#125;)&#125; 懒加载路由懒加载默认情况下，会将所有路由下的组件都打包在一个js文件下,文件体积太大。懒加载的作用是，将每个路由对应的组件分开打包成独立的js文件，只有当你跳转到该路由时，才加载相应的组件。 1234567const Home = () =&gt; import('./Home.vue');const router = new VueRouter(&#123; routes: [ &#123; path: '/home', component: Home &#125; ]&#125;) 这样，Home组件会被打包成独立的js文件，只有跳转到/home时才加载 把组件按组分块123const Foo = () =&gt; import(/* webpackChunkName: "group-foo" */ './Foo.vue')const Bar = () =&gt; import(/* webpackChunkName: "group-foo" */ './Bar.vue')const Baz = () =&gt; import(/* webpackChunkName: "group-foo" */ './Baz.vue') 这3个组件会被打包到同一个js文件里,当跳转到相应路由时，这3个组件一起加载webpackChunkName用来指定生成的js文件的文件名，否则 `chunkFilename: “[name].[chunkhash:8].chunk.js” 中的 [name] 是一个自动分配的、可读性很差的id 最后，配置一下webpack，使其打包的js文件名不是随机乱码 $router vs $route$router用于设置路由【$router里面是方法】https://router.vuejs.org/zh/api/#router-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7 $router.push $router.replace $router.go $router.back $router.forward 路由对象$route,用于获取路由信息【$route里面是属性】https://router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1 $route.path $route.params $route.query $route.fullPath $route.name $route.meta]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS自定义属性（CSS变量）]]></title>
    <url>%2F2018%2F08%2F28%2Fcss%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[简单介绍css自定义属性的用法参考资料：https://www.w3cplus.com/css3/css-properties-in-depth.html currentColor最简单的一个css自定义属性:currentColor1234div&#123; color:red; border:1px solid currentColor;&#125; –variable-name: 值12345678:root&#123; --bg-color:red; --main-color:green;&#125;p&#123; background:var(--bg-color); color:var(--main-color);&#125; 【点击查看代码】 默认值如果没有指定--p-margin的值,则默认值为0 0 10px123p &#123; margin: var(--p-margin, 0 0 10px);&#125; 作用域将css自定义属性写在不同的作用域，使其只有在特定的容器内生效123456789101112131415:root &#123; --main-bg: black; --main-color: white;&#125;p &#123; background: var(--main-bg); color: var(--main-color); font-size: 20px; padding: 5px 10px; text-align: center;&#125;.dark &#123; --main-bg: aqua; --main-color: orange;&#125; 在class=&quot;dark&quot;这个作用域下，拿到的是.dark里的变量值，而不是:root下的值 【点击查看代码】 伪类作用域12345678910111213p &#123; --bg-color: red; --color: green; background: var(--bg-color); color: var(--color); transition: .6s; padding: 8px 0; text-align: center;&#125;p:hover &#123; --bg-color: aqua; --color: black;&#125; 【点击查看代码】 变量组合–variable-name: var(–another-variable-name);1234567:root&#123; --main-color:blue; --main-bg:var(--main-color);&#125;p&#123; background:var(--main-bg);&#125; 值的计算变量的值不能直接计算123456:root&#123; --main-size:18px;&#125;p&#123; font-size:var(--main-size)*2; 错误！！！不能直接计算&#125; 可以使用calc()实现值的计算123456:root &#123; --main-size: 18px;&#125;p &#123; font-size: calc( var(--main-size)*2 );&#125; 【点击查看代码】 用js操作自定义属性读/写自定义属性(getPropertyValue, setProperty) 123456789//获取const root = document.documentElement;const rootStyles = getComputedStyle(root);var mainBg = rootStyles.getPropertyValue('--main-bg').trim();console.log(mainBg)//赋值const root = document.documentElement;root.style.setProperty('--main-bg','orange'); 【点击查看代码】 换肤功能css自定义属性 配合 js，可以很方便地实现换肤功能，而不需要创建多个样式表1234567let root = document.documentElement;green.onclick = function() &#123; root.style.setProperty('--main-bg', 'green');&#125;blue.onclick = function() &#123; root.style.setProperty('--main-bg', 'blue');&#125; 【点击查看代码】]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 Express初体验]]></title>
    <url>%2F2018%2F08%2F27%2FExpress%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。使用 Express 可以快速地搭建一个完整功能的网站。菜鸟教程 前提Node.js 的 fs模块 用于读写文件，http模块 可以创建severexpress可以让http更好用 新建文件夹打开cmd，输入cd,然后将文件夹拖进cmd就会自动补全路径 安装Express npm init 生成package.json文件 npm i express 写代码部署到LeanCloud配置package.json123456789101112&#123; "name": "express-demo", "scripts": &#123; "start": "node server.js" &#125;, "dependencies": &#123; "express": "^4.16.3" &#125;, "engines": &#123; "node": "*" &#125;&#125; 将node设置为 * 表示总是使用最新版本的 Node.js。 部署 在云引擎 -&gt; 设置 -&gt; 源码部署中填入git仓库【注意是https格式】 点击Webhooks （用于自动部署） 设置Web 主机域名 在部署 -&gt; git源码部署 -&gt; 点击部署]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 实现一个MVVM框架(仿Vue.js)]]></title>
    <url>%2F2018%2F08%2F06%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAMVVM%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[通过手写一个MVVM框架，从而理解Vue.js的响应式原理涉及到的知识点包括：Object.defineProperty 实现数据拦截观察者模式 Object.defineProperty 实现数据拦截语法：Object.defineProperty(obj, key, descriptor) 基本用法12345var obj = &#123;a:1,b:2&#125;Object.defineProperty(obj, 'c', &#123; value : 3&#125;)console.log(obj) // &#123;a: 1, b: 2, c: 3&#125; configurable 可否删除1234567var obj = &#123;a:1&#125;Object.defineProperty(obj, 'b', &#123; configurable: false, value : 2&#125;)delete obj.b //无法删除 configurable 的值设置为 false 后(如果没设置，默认就是 false)，就无法删除该属性。 enumerable 可否遍历12345678var obj = &#123;a: 1&#125;;Object.defineProperty(obj, 'b', &#123; value: 2, enumerable: false&#125;);for(var key in obj)&#123; console.log(key) // 只输出 a， 不输出b&#125; 设置 enumerable 属性为 false 后，遍历对象的时候会忽略当前属性(如果未设置，默认就是 false不可遍历)。 writable 可否修改123456var obj = &#123;a:1,b:2&#125;Object.defineProperty(obj, 'c', &#123; value : 3, writable: false&#125;)obj.c = 111 //修改失败 get和set注意，get和value不能同时存在！12345678910111213var obj = &#123;&#125;;Object.defineProperty(obj, 'age', &#123; get()&#123; console.log('正在获取age...'); return age; &#125;, set(newVal)&#123; console.log('正在设置age...'); age = newVal; &#125;&#125;);obj.age = 100;console.log(obj.age); // 100 get：一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。 set：一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数newVal，并将该参数的新值分配给该属性。默认为 undefined。 数据劫持写一个数据劫持函数observe()，效果如下：123456789var data = &#123; a: 1, b: &#123;c:2&#125;&#125;;observe(data);console.log(data.b.c)data.b = [111,222,333]data.b 说干就干！1234567891011121314151617181920212223function observe(data)&#123; if(!data || typeof data !== 'object')&#123;//如果data不存在，或者它不是个对象 return; &#125; else&#123; for(let key in data)&#123; let val = data[key]; Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get()&#123; return val; &#125;, set(newVal)&#123; console.log(`$&#123;val&#125; =&gt; $&#123;newVal&#125;`); val = newVal; &#125; &#125;); if(typeof val === 'object')&#123;//如果value是个对象，则递归 observe(val); &#125; &#125; &#125;&#125; 以上，observe方法实现了数据的劫持 观察者模式(发布/订阅模式)一个典型的观察者模式应用场景是用户在一个网站订阅主题 多个用户(观察者，Observer)都可以订阅某个主题(Subject) 当主题内容更新时订阅该主题的用户都能收到通知 以下是代码实现 Subject是构造函数，new Subject() 创建一个主题对象，该对象内部维护订阅当前主题的观察者数组。主题对象上有一些方法，如添加观察者(addObserver)、删除观察者(removeObserver)、通知观察者更新(notify)。 当notify 时实际上调用全部观察者 observer 自身的 update 方法。 Observer 是构造函数，new Observer() 创建一个观察者对象，该对象有一个 update 方法。 12345678910111213141516171819202122232425262728293031323334353637class Subject &#123; constructor() &#123; this.observers = [] &#125;; addObserver(observer) &#123; this.observers.push(observer) &#125;; removeObserver(observer) &#123; let index = this.observers.indexOf(observer); if(index &gt; -1)&#123; this.observers.splice(index, 1); &#125; &#125;; notify() &#123; this.observers.forEach(observer=&gt; &#123; observer.update(); &#125;); &#125;;&#125;class Observer&#123; constructor(name) &#123; this.update = function() &#123; console.log(name + '更新...') &#125; &#125;&#125;;let observer1 = new Observer('observer1')let observer2 = new Observer('observer2')let subject = new Subject()subject.addObserver(observer1)subject.addObserver(observer2)subject.notify() 上面的代码中，主题被观察者订阅的写法是 subject.addObserver(observer)， 不是很直观，改写成 observer.subscribeTo(subject) 1234567891011121314151617class Observer&#123; constructor() &#123; this.update = function() &#123; console.log('更新...'); &#125; &#125;; subscribeTo(subject) &#123; subject.addObserver(this); &#125;&#125;;let subject = new Subject() //发布主题let observer = new Observer()observer.subscribeTo(subject) //观察者订阅主题subject.notify() //通知更新 MVVM单向绑定的实现MVVM (Model-View-ViewModel) 是一种用于把数据和视图层分离的设计模式。MVVM 中的 Model 表示应用程序使用的数据，比如一个用户账户信息(名字、头像、电子邮件等)。Model 保存信息，但通常不处理行为，不会对信息进行再次加工。数据的格式化是由View 处理的。行为一般认为是业务逻辑，封装再 ViewModel 中。View 是与用户进行交互的桥梁。ViewModel 充当数据转换器 将 Model 信息转换为 View 的信息 将命令从 View 传递到 Model。 假设有如下代码，data 里的name会和视图中的绑定，修改 data 里的值，会直接引起视图中对应数据的变化。 1&lt;div&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt; 12345new Vue(&#123; data:&#123; name:'xxx' &#125;&#125;) 实现一个Vue12345678class Vue()&#123; constructor(opts)&#123; this.init(opts); observer(this.$data); this.compile(); &#125;;&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 模板引擎的使用]]></title>
    <url>%2F2018%2F07%2F31%2F%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[模板引擎的使用 【点击查看代码】】]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MVC小例子]]></title>
    <url>%2F2018%2F07%2F21%2FMVC%E5%B0%8F%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[一个mvc的在线小实例 MVC1&lt;div id="app"&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041const view =&#123; el:'#app', template:'', render(lists)&#123; this.template += `&lt;ul&gt;`; $(lists).each((index,list) =&gt; &#123; this.template += `&lt;li style="border-bottom:1px solid red;&gt; &lt;div class=title&gt;$&#123;list.title&#125;&lt;/div&gt; &lt;div class=author&gt;作者:$&#123;list.author.loginname&#125;&lt;/div&gt; &lt;/li&gt;`; &#125;); this.template += `&lt;ul&gt;`; $(this.el).html(this.template); &#125;&#125;;const model = &#123; lists:[], getLists()&#123; return $.get('https://cnodejs.org/api/v1/topics',(&#123;data&#125;)=&gt;&#123;this.lists = data;&#125;); &#125;&#125;;const controller = &#123; init(view,model)&#123; this.view = view; this.model = model; this.model.getLists().then(()=&gt; this.view.render(this.model.lists)); this.bindEvents(); &#125;, bindEvents()&#123; this.handleClick(); &#125;, handleClick()&#123; $(this.view.el).on('click', '.title', ev =&gt; &#123; ev.target.style.color = 'red; &#125;); &#125;&#125;;controller.init(view,model); JS Bin【点击查看在线代码】 踩坑12&lt;div class=title&gt;$&#123;list.title&#125;&lt;/div&gt;&lt;div class=author&gt;作者:$&#123;list.author.loginname&#125;&lt;/div&gt; 在模板字符串中，写成双引号class=&quot;title&quot;会渲染成class=&quot; title&quot;,当中有个空格，不知什么原因(:з」∠)因此，建议写成没有引号class=title,或者单引号class=&#39;title&#39;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>MVC模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 js相关题目]]></title>
    <url>%2F2018%2F07%2F18%2Fjs%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[与javascript有关的面试题汇总 参考资料https://jirengu.github.io/javascript-tutorial/http://book.jirengu.com/fe/ 引用类型的问题1234567891011121314var obj = &#123; a:1, b:[1,2,3]&#125;var x = obj.a;var y = obj.b;x = 2;y.push(4);obj //&#123;a:1,b:[1,2,3,4]&#125;x //2y //[1,2,3,4] ！！画内存图即可解题。值得注意的是，数组是引用类型，所以y会修改obj里的b this的指向问题this只有在函数被执行时才能确认箭头函数中的this是在定义函数的时候就确定了，而不是在执行函数时确定 12345678910111213141516171819var s = &#123; s:'student', getS:function()&#123; console.log(this.s); &#125;&#125;;var t = &#123; s:'teacher'&#125;;var getS = s.getS;var getS1 = getS.bind(s);// 写出以下输出结果s.getS();s.getS.apply(t); getS();getS1.call(t); 12345678910111213141516window.number = 2;var obj = &#123; number:3, dbl:(function()&#123; this.number += 4 //这个this指向window，因为立即执行函数的this始终指向window return function()&#123; this.number += 7; //这个this，谁调用，this就指向谁 &#125; &#125;)()&#125;var dbl = obj.dbl;dbl(); //2+4+7=13,此时window.number == 13obj.dbl();//3+7=10,此时obj.number == 10console.log(window.number + obj.number) //23 1234567891011var name = 'hunger'var obj = &#123; name: 'valley', fn: function() &#123; function fn2() &#123; console.log(this.name) &#125; fn2() //等同于window.fn2() &#125;&#125;obj.fn() //执行fn2(),等同于window.fn2(),因此this指向window 1234567891011121314var a = 123;var obj = &#123; a:1, getA:function()&#123; var self = this; console.log(this.a); //1 console.log(self.a); //1 (function()&#123; console.log(this.a); //123 console.log(self.a); //1 &#125;)(); &#125;&#125;obj.getA(); 数组中的this12345678var arr = []for(var i=0; i&lt;3; i++)&#123; arr[i] = function()&#123; console.log(this) &#125;&#125;//数组相当于特殊的对象，此时arr = &#123;'0': function()&#123;&#125;, '1': function()&#123;&#125;, '2': function()&#123;&#125;, length:3&#125;arr[0]() // [ƒ, ƒ, ƒ],this指向这个arr arr0 等同于 arr.0() ,因此 this 指向arr 箭头函数中的this123456789101112131415var app = &#123; init() &#123; var menu = &#123; init: ()=&gt;&#123; console.log(this) //this -&gt; menu -&gt; app【箭头函数的this指向父级的】 &#125;, bind() &#123; console.log(this) //this -&gt; menu &#125; &#125; menu.init() menu.bind() &#125;&#125;app.init() 异步中的this1234567891011121314151617181920212223242526var app = &#123; fn1() &#123; setTimeout(function fn()&#123; console.log(this) &#125;, 10) &#125;, fn2() &#123; setTimeout(()=&gt;&#123; console.log(this) &#125;,20) &#125;, fn3() &#123; setTimeout((function()&#123; console.log(this) &#125;).bind(this), 30) &#125;, fn4: ()=&gt; &#123; setTimeout(()=&gt;&#123; console.log(this) &#125;,40) &#125;&#125;app.fn1() //先放入异步队列，过10s后执行window.fn(),所以this指向windowapp.fn2() //this指向appapp.fn3() //this指向appapp.fn4() //this -&gt; app -&gt; window js类型转换1234'10'+1 // 1011+'10' //110'10'-1 // 910-'1' //9 6 个falsy值0、NaN、’’、false、null、undefined 1234null == false // falseundefined == false //falsenull == undefined //truenull === undefined //false 正则表达式##号码段为131到139的11位手机号的验证1/^13[1-9][0-9]&#123;8&#125;$/ 匹配邮箱除了用正则，还可以用什么来匹配邮箱？前端做了表单验证后，后端还需要再验证一遍吗？ 把yyyy-mm-dd格式，替换成mm/dd/yyyy怎么做？正则表达式中，括号的用法12345678910var str = '今天是2017-06-12';var reg = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/; //!!!注意，千万不要全局匹配g//$0:2017-06-12//$1:2017//$2:06//$3:12var result = str.replace(reg, "$2/$3/$1");console.log(result); // "今天是06/12/2017" 变量提升在进入一个执行环境后，先把 var 和 function 声明的变量前置， 再去顺序执行代码123456789101112131415161718var a = 1; //变量声明function fn()&#123;&#125;; //函数声明var fn2 = function()&#123;&#125;; //函数表达式//函数声明会将整个函数提升//函数表达式只会将var fn2 = undefined 提升function fn()&#123; var a=1; //在函数中，用var声明的变量就是局部变量 b=2; //没有用var声明的变量就是全局变量&#125;//变量先提升，函数后提升，然后按照执行顺序，当变量与函数同名时，函数名覆盖变量名function fn()&#123;&#125;var fn;console.log( fn ) //函数 1234567891011console.log( fn )var fn = 1function fn()&#123;&#125;console.log( fn )/* 将变量和函数提升，然后再做赋值运算 */var fn;function fn()&#123;&#125;console.log( fn ) //函数fnfn = 1console.log( fn ) //1 123456console.log(i)for(var i=0; i&lt; 3; i++)&#123; console.log(i)&#125;//undefined//0,1,2 此处不是点击按钮，因此输出0,1,2;如果是点击按钮，那么输出3，因为点击事件是个异步事件 1234567891011121314151617var n = 3;function getN()&#123; return n;&#125;var getN2 = (function()&#123; n = 4; var n; n += 3; return getN; function getN()&#123; return n; &#125;&#125;)();getN() //3getN2() //7 123456if(!('a' in window))&#123; var a=1;&#125;console.log(a); //undefinedconsole.log('b' in window) //truevar b; 123456789var a = 1;var b = 1;function x()&#123; var a=b=2; //此处相当于var a=2;b=2;由于b没有var，因此b是全局的&#125;x();console.log(a,b);//1,2 123456(function()&#123; var a=b=1;&#125;)();console.log(typeof a); //undefined 【a在函数作用域内，因此全局的a is not defined；未定义和undefined的typeof都是undefined】console.log(typeof b); //number 【b=1，它是全局的】 setTimeout异步题1234567891011121314151617for(var i=0;i&lt;5;i++)&#123; let j = i; setTimeout(function()&#123; console.log(j); &#125;,j*1000);&#125;//结果，每隔1s输出0、1、2、3、4//分析//i是全局变量，j是块级变量，所以打印出0、1、2、3、4【如果是i，则每隔1s打印出5】//每隔1s是因为j*1000这个赋值是同步的，function里面的才是异步代码//i=0;setTimeout(fn,0s)//i=1;setTimeout(fn,1s)//i=2;setTimeout(fn,2s)//i=3;setTimeout(fn,3s)//i=4;setTimeout(fn,4s) 123456789for(var i=1;i&lt;=3;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,0)&#125;//4//4//4 数组apiforEach，map，filter，some，every slice和splice伪数组转数组1Array.prototype.slice.call(fakeArr) 对象apiObject.assign是干嘛的 ES6 用ES6解构的方式，将下面代码中的obj.name赋值给n，obj.age赋值给a 12345let obj = &#123;name:’韩梅梅’, age:’20’&#125;;let n, a;//答案：let &#123;name:n, age:a&#125; = obj; var,let,const var声明的变量，无块级作用域，且存在变量提升现象，可以重复声明； let声明的变量，有块级作用域，不存在变量提升，不能重复声明； const声明的是常量，如果是基本类型则不能修改，如果是引用类型可以修改。1234567//let不能重复声明let a=1;let a=2; //报错 'a' has already been declared//const声明的变量，基本类型的不能更改，引用类型的可以更改const obj=&#123;x:1&#125;obj.x=2; 算法题快速排序https://segmentfault.com/a/119000000942642112345678910111213141516171819202122232425262728function quickSort(arr) &#123; //如果数组&lt;=1,则直接返回,这句很重要！！！否则数组中只剩一个数的时候会无限递归！！ if (arr.length &lt;= 1) &#123; return arr; &#125; let baseIndex = Math.floor(arr.length / 2); //找基准，并把基准从原数组删除 let base = arr.splice(baseIndex, 1)[0]; //定义左右数组 let left = []; let right = []; //比基准小的放在left，比基准大的放在right arr.forEach(item=&gt;&#123; if(item&lt;=base)&#123; left.push(item); &#125; else&#123; right.push(item); &#125; &#125;) //递归 return [...quickSort(left),base, ...quickSort(right)];&#125;var arr = [55,21,86,32,16,96,4]var result = quickSort(arr)result //[4, 16, 21, 32, 55, 86, 96] 复杂度？？？？？？ 选择排序https://segmentfault.com/a/1190000009366805希尔排序https://segmentfault.com/a/1190000009461832冒泡排序 堆栈http://juejin.im/entry/58759e79128fe1006b48cdfd队列链表 递归https://segmentfault.com/a/1190000009857470 requestanimationframe的用法代码运行结果12345678910111213function switchCase(value)&#123; switch(value)&#123; case '0':console.log('0'); case '1':console.log('1');break; case undefined:console.log('undefined');break; default:console.log('default'); &#125;&#125; // 写出下列输出结果switchCase(0); // defaultswitchCase('0'); // 0 1 【执行完case 0之后，由于没有break，继续往下执行】switchCase(); // undefined 编码题 用js实现一个随机打乱数组顺序的函数 12345var arr = [4,1,7,3,10,7];arr.sort(function()&#123; return Math.random()&gt;0.5 ? 1 : -1; //用Math.random()函数生成0~1之间的随机数与0.5比较，返回-1或1&#125;) 千分位标注，使得1234567变成1,234,567 12var n = 1234567;n.toLocaleString() 手写发布订阅 123456789101112131415161718192021222324252627282930313233343536var events = &#123;&#125;;let pubsub = &#123; on(name,callback)&#123; let list = events[name] || (events[name] = []); list.push(callback); return this; //用于链式调用 &#125;, off(name)&#123; if(!name)&#123; events = &#123;&#125;;//全部清空 &#125;else&#123; delete events[name]; &#125; return this; &#125;, emit(name,data)&#123; let list = events[name]; if(list)&#123; for(let i=0;i&lt;list.length;i++)&#123; list[i](data); &#125; &#125; return this; &#125;&#125;;pubsub.on('a',data=&gt;&#123; console.log(data);&#125;).on('b',data=&gt;&#123; console.log(data)&#125;)pubsub.off('a');//pubsub.off();//不传事件名，则全部清除pubsub.emit('a','我是a').emit('b','我是b') 编写一个函数，获取最大值 12345function getMax()&#123; return Math.max.apply(null,arguments)&#125;getMax(38,28,48,10); //48 sort排序 123456789101112131415161718192021var students = ['小明','小红','小花']; var scores = &#123; 小明: 59, 小红: 99, 小花: 80 &#125;;students.sort(function(a,b) &#123; return scores[a]-scores[b]; //按照scores从小到大排序&#125;);//["小明", "小花", "小红"] ////////////////////////////[ &#123; name: "张三", age: 30 &#125;, &#123; name: "李四", age: 24 &#125;, &#123; name: "王五", age: 28 &#125;].sort(function (o1, o2) &#123; return o1.age - o2.age;&#125;)// [// &#123; name: "李四", age: 24 &#125;,// &#123; name: "王五", age: 28 &#125;,// &#123; name: "张三", age: 30 &#125;// ] 节流，始终以均匀的流速出结果疯狂点击，始终以每2s的速度打印出1 123456789101112131415function throttle(fn,wait)&#123; var timer; return function()&#123; if(!timer)&#123; timer = setTimeout(function()&#123; fn(); timer = null; &#125;,wait); &#125; &#125;&#125;btn.onclick=throttle(function()&#123; console.log(1);&#125;,2000) 防抖，当有下一个事件时，前一个事件取消疯狂点击，不打印出结果；不点击时才打印出结果 12345678910111213function debounce(fn,wait)&#123; var timer; return function()&#123; timer &amp;&amp; clearTimeout(timer); timer = setTimeout(function()&#123; fn(); &#125;,wait); &#125;&#125;btn.onclick=debounce(function()&#123; console.log(1);&#125;,2000) 递归实现杨辉三角假设输入3，输出[[1],[1,1],[1,2,1]] 用js实现一个比较APP版本号的大小的函数，版本号各市由数字和.组成。例如：1.1.0、1.10、1.2.3等。 代码运行结果变量提升，函数作用域123456789var x = 3;function func(randomize) &#123; if (randomize) &#123; var x = Math.random(); //if里声明的x提到外面，初始值为undefined return x; &#125; return x;&#125;func(false); // undefined 12345678910111213141516function C1(name)&#123; if(name) this.name = name&#125;function C2(name)&#123; this.name = name&#125;function C3(name)&#123; this.name = name || 'John'&#125;C1.prototype.name = 'Tom'C2.prototype.name = 'Tom'C3.prototype.name = 'Tom'console.log(new C1().name + new C2().name + new C3().name)//Tom undefined John 12345678//请定义这样一个函数function repeat (func, times, wait) &#123;&#125;//这个函数能返回一个新函数，比如这样用var repeatedFun = repeat(alert, 10, 5000)//调用这个 repeatedFun ("hellworld")//会alert十次 helloworld, 每次间隔5秒 知识点：arguments 和 apply的用法1234567891011121314function repeat(func, times, wait) &#123; return function () &#123; var handle, i = 0,arg = arguments handle = setInterval(function () &#123; if (i++ === times) &#123; clearInterval(handle); return; &#125; func.apply(null, arg); &#125;, wait); &#125; &#125; var repeatFun = repeat(console.log, 4, 1000); repeatFun("hellworld"); 12345678910var arr = [1,2,3];//问arr.map(parseInt);//等同于parseInt(1,0) // 1parseInt(2,1) // NaNparseInt(3,2) // NaN//因此答案是1,NaN,NaN 123456789var a = &#123;n:1&#125;;var b = a;a.x = a = &#123;n:2&#125;;//问a.x //undefined//a.x = (a = &#123;n:2&#125;)//此时的a = &#123;n:2&#125;,里面没有x,因此a.x == undefined]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 CSS相关题目]]></title>
    <url>%2F2018%2F07%2F18%2FCSS%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[与CSS有关的面试题汇总 选择器有哪些选择器，以及选择器的权重 三栏布局编写CSS，实现三栏水平布局，其中left、right定宽，main宽度自适应。 布局：三栏布局（7种方法三栏布局的5种解决方案及优缺点圣杯布局、双飞翼布局、Flex布局和绝对定位布局的几种经典布局的具体实现示例 圣杯布局特点：圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。 123456789101112131415161718192021222324/* 给容器设置padding-left 和 padding-right */#box&#123; padding-left:100px; padding-right:50px;&#125;/* 给儿子们设置左浮动 和 相对定位 */.center,.left,.right&#123; float: left; position:relative;&#125;/* 左儿子margin-left 和 left */.left&#123; left:-100px; margin-left:-100%;&#125;/* 右儿子margin-left 和 right *//* 注意！！！右儿子margin的是left，而定位的是right */.right&#123; right:-50px; margin-left:-50px;&#125; 【点击查看圣杯布局在线代码】 双飞翼布局特点：为了中间div内容不被遮挡，直接在div.mian内部创建子div.inner用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。【不需要设置相对定位来解决遮挡问题】 【双飞翼布局在线例子】 浮动布局兼容性好，但是会脱离文档流，需要清除浮动 浮动布局的html代码，center放在最后面！！！！！！！！！！！！！【点击查看代码】 绝对定位快捷，但是它脱离文档流，导致后面的子元素也会脱离文档流，使得可使用性较差 【绝对定位实现三栏布局在线例子】 table布局高度由内容决定。 给容器设置display:table,然后width:100%撑开给儿子们设置display:table-cell12345678#box&#123; display:table; width:100%; min-height:300px;&#125;#box &gt; div&#123; display:table-cell;&#125; 【点击查看代码】 flex布局这种布局方式，高度由内容决定。 【flex实现三栏布局在线例子】 grid布局123456#box&#123; display:grid; width:100%; grid-template-rows: 300px; /*设置行高*/ grid-template-columns: 100px auto 50px; /*左边100px 中间自适应 右边50px*/&#125; 【点击查看代码】 flex布局Flex 布局教程：语法篇 box-sizing CSS3的box-sizing的取值及各值的说明 隐藏元素 通过CSS隐藏元素的方法，并说明其区别。 移动端适配方案 列出移动端适配各种屏幕尺寸的解决方案(至少3种)]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 HTML相关题目]]></title>
    <url>%2F2018%2F07%2F18%2FHTML%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[与HTML有关的面试题汇总 doctype(文档类型)的作用]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 readme的写法]]></title>
    <url>%2F2018%2F07%2F06%2Freadme%E7%9A%84%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在readme文件中，如何描述项目 有赞商城 此项目是基于 vue2.0 + element-ui + node+mongodb 构建的后台管理系统，所有的数据都是从服务器实时获取的真实数据，具有真实的注册、登录、数据显示、新增数据、修改数据、删除数据等功能。如果此开源系列对你有帮助，你可以点右上角 “star”一下，以表支持，非常感谢！ 🤞 效果演示这里改成预览图预览链接👉 xxx.comPC端建议使用chrome浏览器，然后快捷键Ctrl + Shift + I开启调试模式食用更佳 技术栈vue + vue-cli + vue-router + vuex + axios + easy-mock + mint-ui + es6 用法运行前请先到官网安装node.js然后将项目clone到本地。执行下面的命令 12345678# 首先安装依赖npm i# 然后运行项目npm start# 发布打包npm run build 插件 qs：处理查询参数，将字符串格式的查询参数转变成键值对格式 swiper：轮播图插件 velocity：动画效果 功能 [x] 底部导航 [ ] 首页index [x] 轮播图 [ ] 优店推荐 [x] 最热商品推荐 -[x]触底无限加载 [ ] 分类页category [x] 分类项目 [x] 热门品牌 [x] 热门分类 [x] 搜索商品 [ ] 购物车页cart [x] 商品全选联动 [x] 自动计算总价 [ ] 编辑功能 [x] 商品数量的加减 [x] 单个商品的删除 [x] 左滑删除功能 [ ] 个人中心页member [x] 管理收货地址 [x] 修改收货地址 [x] 新增收货地址 [ ] 商品详情页goods [x] 商品展示轮播图 [ ] 进入店铺 [x] 加入购物车功能 功能 [x] 根据模板，在线生成精美的个人简历 [x] 注册登录之后，可以将简历保存到云端，方便在不同设备之间编辑 [x] 可以生成pdf文件 [x] 可以生成在线预览链接，方便分享给他人在线预览 [x] 除了默认主题色，还支持另外3种颜色(换肤功能) 更新日志 将换肤组件(ChangeSkin.vue)和登录组件(Login.vue)定义为异步组件，按需加载，从而节省首次加载的时间，提高页面打开的速度 右上角添加Github图标链接 登录框添加动画效果 添加上传头像功能 添加换肤功能 添加分享链接 &amp; 预览功能 添加打印功能 项目总结 html对标签名和属性名(双引号外边的内容)大小写不敏感 v-on:myFn=”xxx”,这种写法是不行的，html会将双引号外面的内容全部转换成小写；不过双引号里面可以大写，比如v-on:myfn=”aBc”是可以的 :shareLink=&quot;xxx&quot;,这种写法是不行的，html会将双引号外面的内容全部转换成小写；应该写成:sharelink=&quot;xxx&quot;或者:share-link=&quot;xxx&quot;]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 数组常用api]]></title>
    <url>%2F2018%2F07%2F02%2F%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8api%2F</url>
    <content type="text"><![CDATA[数组常用的一些属性和方法菜鸟教程：数组的属性和方法 数组菜鸟教程：数组手册 创建数组1var arr = [1,2,3,4] 修改数组12arr[1] = 'x'arr // [1,'x',3,4] 查找数组1arr[0] //1 属性length设置或返回数组元素的个数12var arr = [1,2,3]arr.length //3 prototype允许你向数组对象添加属性或方法。123456789Array.prototype.myUcase=function()&#123; for (i=0;i&lt;this.length;i++)&#123; this[i]=this[i].toUpperCase(); &#125;&#125;var fruits = ["Banana", "Orange", "Apple", "Mango"];fruits.myUcase();fruits // ["BANANA", "ORANGE", "APPLE", "MANGO"] #方法 splice(index, howmany, newValue)删除后插入splice() 方法用于插入、删除或替换数组的元素。 删除1234var arr = [0,1,2,3,4]var remove = arr.splice(1,3)remove //[1,2,3]arr //[0,4] 替换(删除后插入)1234var arr = [0,1,2,3,4]var remove = arr.splice(1,3,123) //从第1项开始，往后删除3个，并插入123remove // [1,2,3]arr // [0,123,4] slice(起始index, 截止index)截取1234var arr = [0,1,2,3,4]var newArr = str.slice(1,3) //截取第1~第3项newArr //[1,2]arr //[0,1,2,3,4] slice也可以用来截取字符串12var str = '012345'str.slice(1,4) //"123" concat() 连接concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会return一个连接后的数组。1234var arr1 = [1,2,3]var arr2 = [4,5,6]var x = arr1.concat(arr2)x // [1,2,3,4,5,6] every() 判断所有元素是否满足给定的条件12let ages = [32, 33, 16, 40];ages.every(age =&gt; age&gt;18);//false some() 判断是否至少有一个元素满足给定的条件12let ages = [3, 10, 18, 20];ages.some(age =&gt; age&gt;18);//true sort() 排序123456789101112[10111, 1101, 111].sort(function (a, b) &#123; return a - b;&#125;)// [111, 1101, 10111]//高级用法var students = ['小明','小红','小花']; var scores = &#123; 小明: 59, 小红: 99, 小花: 80 &#125;;students.sort(function(a,b) &#123; return scores[a]-scores[b]; //按照scores从小到大排序&#125;);//["小明", "小红", "小花"] 对象的排序123456789101112[ &#123; name: "张三", age: 30 &#125;, &#123; name: "李四", age: 24 &#125;, &#123; name: "王五", age: 28 &#125;].sort(function (o1, o2) &#123; return o1.age - o2.age;&#125;)// [// &#123; name: "李四", age: 24 &#125;,// &#123; name: "王五", age: 28 &#125;,// &#123; name: "张三", age: 30 &#125;// ] map() 对数组里的元素进行处理，然后return新的数组1234var numbers = [1, 2, 3];var newNum = numbers.map(function(value,index) &#123; return value + 1;&#125;); forEach() 遍历数组元素1234var arr = [1,2,3];arr.forEach((item,index) =&gt; &#123; console.log(item);&#125;) filter() 筛选出符合条件的元素1234var result = [1, 2, 3, 4, 5].filter(value =&gt; &#123; return (value &gt; 3); //结果为true的元素组成一个新数组返回&#125;)// [4, 5] Array.prototype.xxx.call()处理字符串https://www.jianshu.com/p/0362b6cd90d6 通过“借用”数组的方法可以很方便的处理字符串。可以“借用”数组的非变更方法，但不能“借用”数组的可变更方法。 123456789101112var a = 'foo';// 数组的非变更方法,即不改变原有数组的方法var b = Array.prototype.join.call(a, '-');var c = Array.prototype.map.call(a, v =&gt; v.toUpperCase()).join()var d = Array.prototype.slice.call(a);console.log(b); // 'f-o-o'console.log(c); // 'FOO'console.log(d); // ['f', 'o', 'o']// 数组的可变更方法,即能够改变原有数组的方法var e = Array.prototype.reverse.call(a);// 报错]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 移动端豆瓣电影项目笔记]]></title>
    <url>%2F2018%2F06%2F30%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录开发移动端豆瓣电影项目时，学到的一些新知识！ 手机端调试工具browsersynciconfont的用法css知识点 calc(100vh-50px) flex布局 -webkit-overflow-scrolling: touch：滚动时，增加弹性效果 $.ajax()的用法豆瓣api数组拼接字符串导演：[导演1,导演2,导演2]通过join方法变成 导演：导演1、导演2、导演3 请求加锁函数节流代码封装MVC注意点在JQuery中,.value要变成.val()]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yarn使用教程]]></title>
    <url>%2F2018%2F06%2F25%2Fyarn%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[yarn,快速、可靠、安全的依赖管理。有了npm，为什么还要用yarn？因为yarn比npm快速！ 安装方法1：进入官网进行安装，然后重启电脑！！！！方法2：npm i yarn -g直接通过npm工具全局安装 yarn -v : 查看版本号 yarn self-update：更新 Yarn 到最新可用版本（该命令可能存在bug，最好手动安装更新） yarn -h ：查看帮助 yarn config get registry : 查看当前镜像，默认https://registry.yarnpkg.com yarn config set registry https://registry.npm.taobao.org:切换成淘宝镜像 yarn config set loglevel http：显示所有http请求 yarn config delete loglevel:删除loglevel这项配置 yarn config set progress false yarn config set strict-ssl false 使用 yarn init -y : 初始化项目,生成package.json文件【对应npm init -y】 yarn ：安装package.json里的全部包，相当于npm i yarn add vue : 添加vue，会记录在 package.json 的 dependencies 下 yarn add vue --offline:可以离线添加之前已经缓存过的包 yarn global add vue-cli : 全局安装，注意global必须接在yarn的后面！ yarn global list : 查看全局安装的包 yarn add vue@2.3.0 : 指定版本号 yarn add bable -D : 添加到开发环境package.json 的 devDependencies下 yarn remove vue ： 移除vue yarn cache dir:会打印出当前的 yarn 全局缓存在哪里 yarn cache clean : 清除缓存 yarn run dev、yarn start、yarn run build：运行package.json里script下的脚本 yarn autoclean -I：通过从依赖文件中移除不需要的文件和文件夹来释放空间 减少了 node_modules 的体积 小技巧一次添加多个库12345# npmnpm i -S vue vuex vue-router# yarnyarn add vue vuex vue-router 更多命令点此查看 相关博文：https://blog.csdn.net/mjzhang1993/article/details/70092902 可供选择的镜像 https://registry.yarnpkg.com https://registry.npmjs.org https://r.cnpmjs.org https://registry.npm.taobao.org]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加github-corner图标]]></title>
    <url>%2F2018%2F06%2F24%2F%E6%B7%BB%E5%8A%A0github-corner%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[在右上角添加github图标链接的方法 直接拷贝代码http://tholman.com/github-corners/ 在这个网站可以直接生成图标 js插件github-corners 使用：1&lt;script data-href="https://www.baidu.com" data-target="_blank" src="https://unpkg.com/github-corners/dist/embed.min.js"&gt;&lt;/script&gt; 修改样式：1234body .github-corner &gt; svg &#123; fill: red; //背景色 color:green; //章鱼猫的颜色&#125; 【在线查看效果】 vue插件vue-gh-cornershttps://www.npmjs.com/package/vue-gh-corners 安装：1npm i vue-gh-corners 使用：12345import Vue from 'vue';import VueGitHubCorners from 'vue-gh-corners';import 'vue-gh-corners/dist/vue-github-corners.css'; Vue.use(VueGitHubCorners); 123&lt;div id="app"&gt; &lt;github-corners repo="gluons/vue-gh-corners"&gt;&lt;/github-corners&gt;&lt;/div&gt; API:相关api点此查看 【在线查看效果】 vue2-github-cornershttps://www.npmjs.com/package/vue2-github-corners 安装：1npm i vue2-github-corners 使用：123import Vue from 'vue';import &#123; VueGithubCorners &#125; from 'vue2-github-corners'Vue.component('VueGithubCorners', VueGithubCorners) 123&lt;div id="app"&gt;&lt;VueGithubCorners repoUrl="repoUrl" catColor="catColor" bgColor="bgColor"&gt;&lt;/VueGithubCorners&gt;&lt;/div&gt; 演示地址：https://weichiachang.github.io/vue-github-corners/dist/]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测客户端信息ua-parser-js]]></title>
    <url>%2F2018%2F06%2F23%2F%E6%A3%80%E6%B5%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BF%A1%E6%81%AFua-parser-js%2F</url>
    <content type="text"><![CDATA[ua-parser-js用于检测客户端信息 引入CDN引入：1&lt;script src="https://cdn.jsdelivr.net/npm/ua-parser-js@0/dist/ua-parser.min.js"&gt;&lt;/script&gt; NPM引入：12npm i ua-parser-jsimport UAParser from 'ua-parser-js' 使用123var parser = new UAParser();var result = parser.getResult();console.log(result); api123456789var parser = new UAParser();var result = parser.getResult();result.browser //&#123;name: "Chrome", version: "66.0.3359.139", major: "66"&#125;result.device //&#123;vendor: "Apple", model: "iPhone", type: "mobile"&#125;result.os //&#123;name: "iOS", version: "11.0"&#125;result.os.version //11.0result.engine //&#123;name: "WebKit", version: "604.1.38"&#125;result.cpu 原生js判断浏览器信息123if(!!window.ActiveXObject || "ActiveXObject" in window)&#123; document.body.innerHTML = '&lt;h1 style="font-size:30px;"&gt;请使用chrome浏览器打开此页！&lt;/h1&gt;';&#125;]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tween.js使用教程]]></title>
    <url>%2F2018%2F06%2F05%2Ftweenjs%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Tween.js使用教程中文README中文指南 引入CDN引入 或者 NPM引入 例子点击页面回到顶部12345678910111213141516171819document.onclick=function()&#123; // 设置循环动画function animate(time) &#123; requestAnimationFrame(animate); TWEEN.update(time);&#125;requestAnimationFrame(animate);var position = &#123; x: 0, y: pageYOffset &#125;; // 起始点var tween = new TWEEN.Tween(position) // 创建一个新的tween用来改变 'position' .to(&#123; x: 0, y: 0 &#125;, 1000) // 在1s内移动至 (0, 0) .easing(TWEEN.Easing.Quadratic.Out) // 使用缓动功能使的动画更加平滑 .onUpdate(function() &#123; // 在 tween.js 更新 'position' 后调用 // 移动到 'position' 所描述的位置，配合 CSS 过渡 window.scrollTo(position.x,position.y) &#125;); .start(); // 执行tween&#125;; 【点击查看在线例子】 缓动动画公式：.easing(TWEEN.Easing.缓动函数.缓动方式) 缓动函数各种缓动效果曲线图缓动效果源码缓动函数： Linear：线性匀速运动 Quadratic：二次方缓动 Cubic：三次方缓动 Quartic：四次方缓动 Quinitic：五次方缓动 Sinusoidal：正弦曲线的缓动 Exponential：指数曲线的缓动 Circular：圆形曲线的缓动 Elastic：指数衰减的正弦曲线的缓动 Back：超过范围的三次方的缓动 Bounce：指数衰减的反弹缓动 缓动方式(easing类型) In：加速，嫌慢后壳 Out：减速，先快后慢 InOut：前半段加速，后半段减速 es6-tweenes6-tween主页 123456789101112131415var box = document.createElement('div');box.style.setProperty('background-color', '#008800');box.style.setProperty('width', '100px');box.style.setProperty('height', '100px');document.body.appendChild(box);TWEEN.autoPlay(true);// Setup the animation loop.let coords = &#123;x: 0,y: 0&#125;;let tween = new TWEEN.Tween(coords) .to(&#123;x: 100,y: 400&#125;, 1000) .easing(TWEEN.Easing.Bounce.In) .on('update', (&#123;x, y&#125;) =&gt; &#123; box.style.setProperty('transform', `translate($&#123;coords.x&#125;px, $&#123;coords.y&#125;px)`); &#125;) .start(); 【点击查看在线例子】 【点击查看在线例子】 repeat和yoyo实现循环往复文档:repeat和yoyo 【点击查看在线例子】 滚动到顶部的其他库animated-scroll-tomoveto]]></content>
      <categories>
        <category>效果及美化</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue仿移动端电商网站]]></title>
    <url>%2F2018%2F05%2F28%2Fvue%E9%87%8D%E6%9E%84%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%9C%89%E8%B5%9E%E5%95%86%E5%9F%8E%2F</url>
    <content type="text"><![CDATA[记录项目的完整流程 踩坑 ./index.css表示同级文件夹下的index.css 给body和html同时添加overflow:hidden;height:100%可以阻止弹出层滚动 1234567watch:&#123; popSeen(newVal,oldVal)&#123;//监听popSeen的变化 document.body.style.overflow = newVal ? 'hidden' : 'auto'; document.querySelector('html').style.overflow = newVal ? 'hidden' : 'auto'; document.body.style.height = newVal ? '100%' : 'auto'; document.querySelector('html').style.height = newVal ? '100%' : 'auto';&#125; {}、[]是true值，因为{}、[]都是对象，所有的对象都是true值 :class=&quot;{&#39;active&#39;:list.length}&quot;,在开发模式下,active没有单引号不报错，但是打包时就会报错！【active不加单引号，就表示是data里面的变量active】 &lt;a href=&quot;/abc.html&quot;&gt;的路径是github.io/abc.html,&lt;a href=&quot;abc.html&quot;&gt;和&lt;a href=&quot;./abc.html&quot;&gt;的路径是github.io/vue-youzan/abc.html 开发流程项目经理 –&gt; UI设计师 –&gt; 后端接口 github搜索搜索stars:&gt;10000就能搜索出star数大于1w的项目 接口管理平台rapapi、easy-mock等 配合mock生成随机数据根据mock文档，结合接口管理平台，生成随机数据 使用nrm切换镜像仓库github:nrm 安装nrmnpm install -g nrm 使用nrmnrm:https://github.com/Pana/nrm nrm ls:查看有哪些镜像仓库 nrm test：测试速度 nrm use taobao：使用taobao镜像 vue-cligithub:vue-clivue-cli中文文档 安装vue-cli123npm i vue-cli -g //全局安装一次，之后就可以用vue命令了目前2.9.4有bug，暂时用2.9.3npm i vue-cli@2.9.3 -g 12345//TBOOKC:\Users\stage\AppData\Roaming\npm\vue-init -&gt; C:\Users\stage\AppData\Roaming\npm\node_modules\vue-cli\bin\vue-initC:\Users\stage\AppData\Roaming\npm\vue-list -&gt; C:\Users\stage\AppData\Roaming\npm\node_modules\vue-cli\bin\vue-listC:\Users\stage\AppData\Roaming\npm\vue -&gt; C:\Users\stage\AppData\Roaming\npm\node_modules\vue-cli\bin\vue+ vue-cli@2.9.4 static和src/assets的区别 static里的内容不会处理，比如ico放入这个文件夹，然后在html里面引入 src/assets里的静态文件(js,css,图片)会被处理,比如图片转换成base64 用yarn创建项目webpack模板 123456789yarn global add vue-clivue init webpack youzanyarnnpm run devnpm run build 多页面mpa调整https://github.com/tonyfree/blog/issues/1 vue生命周期beforeCreatevue的实例还没创建出来，此时拿不到data和methods created此时vue实例创建完成在created(){}阶段，可以拿到this（即vue实例），此时可以处理vue实例下的data和methods了12345678data:&#123; id:0,&#125;,created()&#123; axios.get('https://www.xxx.com').then(res=&gt;&#123; this.id = res.id; &#125;)&#125; 此时还没有挂载到DOM，所以暂时获取不到DOM节点 DNS预解析1&lt;link rel=dns-prefetch" href="https://www.xxx.com/"&gt; 假设页面中的图片都是在www.xxx.com域名下，那么通过DNS预解析可以加快速度 vue相关组件库饿了么出品：mint-uivuxweui 使用mint-uimint-ui文档 npm i mint-ui -S 如果要按需引入，还需要安装npm i babel-plugin-component -D 根据文档配置.babelrc 然后引入要使用的组件 qs处理查询参数用于处理网址路径问号后面的内容(?a=1&amp;b=2),不包括问号 npm i qs安装 12345678//?name=stage&amp;age=24import qs from 'qs';let obj = qs.parse(location.search.substring(1));//查询参数包含问号，因此用substring将问号截掉obj//经过qs处理，查询参数变成对象&#123;name:stage,age:24&#125;如果要获取name,利用对象的解构赋值let &#123;name&#125; = qs.parse(location.search.substring(1)); velocity中文教程回到顶部transform:matrix在线矩阵将transform转换成matrixmatrix的6个参数详解 【点击查看在线例子】 vue-touchgithub:vue-touch 安装12# vue2.0以上要用next分支npm i vue-touch@next 使用12import VueTouch from 'vue-touch'Vue.use(VueTouch, &#123;name: 'v-touch'&#125;) 12345&lt;!-- 默认渲染成div --&gt;&lt;v-touch v-on:swipeleft="onSwipeLeft"&gt;Swipe me!&lt;/v-touch&gt;&lt;!-- 通过tag可以渲染成其他的标签 --&gt;&lt;v-touch tag="a" v-on:tap="onTap"&gt;Tap me!&lt;/v-touch&gt; 移动端事件移动端的click有300ms延迟的问题，因为在移动端，连续两次点击是缩放操作，所以在用户点击屏幕后，浏览器会检查在300ms内是否有另一次点击，如果没有则触发click事件，否则缩放。 touch事件 touchstart touchmove touchend ev.changedTouches[0].clientX Get Start初始化项目前提：电脑已经全局安装过webpack和vue-cli1234vue init webpack project-name //初始化项目cd project-name //进入项目npm run dev //启动项目npm run build //打包 Unexpected end of JSON input while parsing near错误解决办法1234567npm cache clean --force# 上面方法不行的话，将镜像切换回官方镜像npm set registry https://registry.npmjs.org/# 再不行的话，将npm降级到4npm i npm@4 -g 打包时不要map文件：12去src/config/index.js中改一个参数： productionSourceMap:false 调整为多页面应用基于vue-cli搭建一个多页面应用 加入静态页面资源 静态页面资源下载链接: https://pan.baidu.com/s/1skF4Kpv 密码: 29qn 将index.html和index.css放入index文件夹下，公共css和公共js放入modules文件夹下 src/pages/下的 各个文件夹 里的js文件是入口文件，通过import引入css和js npm i axios 通过axios获取数据，通过vue渲染到页面 单文件组件 将html剪切到&lt;template&gt; git branch lesson1：创建分支 git checkout lesson1：进入分支]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>教程</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端性能优化方案]]></title>
    <url>%2F2018%2F05%2F27%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[web前端性能优化：让用户觉得网页加载贼快根据用户按下回车键后的一系列事件，找出对应的优化方案chrome的Audits 目的让用户觉得网页加载贼快 实现原理当用户输入完网址、按下回车键后 看本地有没有缓存 DNS查询 建立tcp连接 发送请求 等待服务端处理，然后发送响应 接收响应 接收完成后得到HTML，逐行解析HTML 解析到css则下载css文件【多个css文件可以最多同时下载4个】 解析到js则下载js文件，js会阻塞HTML渲染 优化方案css放在head里，js放在body最后 把CSS放在HTML头部是为了让浏览器尽早生成CSSOM，然后往下解析HTML的时候可以一次性生成最终的 RenderTree，渲染一次即可。如果把CSS放在底部，会出现渲染卡顿的现象，影响性能和体验。 由于js会阻塞渲染，因此把js放在底部，可以保证浏览器优先渲染完所有的HTML内容，让用户先看到内容，体验好。另外，JS中可能涉及到DOM的操作，得等到DOM解析完，才能获取DOM元素。 减少域名数量，降低DNS查询假设baidu.com/index.html的css文件放在a.com/xxx.css,js文件放在b.com/xxx.js那么DNS就会查询3次(分别查询baidu.com、a.com、b.com的DNS)将所有文件放在1个域名下，这样就只有1次DNS查询了 DNS预解析12&lt;meta http-equiv="x-dns-prefetch-control" content="on"&gt; &lt;!-- 强制打开a标签的DNS预解析 --&gt;&lt;link rel="dns-prefetch" href="//img.alicdn.com"&gt; tcp连接复用在请求头加上keep-alive http/2.0多路复用发送请求时减小cookie浏览器每次发送请求时都会带上cookie，所以减小cookie体积可以优化web性能 增加域名数量，从而增加资源下载的并发数浏览器可以最多同时下载4个文件，假设有10个js文件，那么必须等前4个下载完，才能继续下载后面的js文件。这时，如果将前4个js文件放在a.com,5~8放在b.com,9、10放在c.com，那么这10个js文件就能同时一起下载！注意：当文件数量少时，减少域名数量，降低DNS查询；当文件数量很多时，增加域名数量，从而增加资源下载的并发数 压缩合并文件，减少HTTP请求将多个css合并到1个css文件将多个js合并到1个js文件 雪碧图多个图片合并到一张图上 小图标用data:url压缩css、js、图片文件利用浏览器缓存浏览器缓存分为强缓存和协商缓存 浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从本地缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到服务器； 当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会返回304，但是不会下载这个资源，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从本地缓存中去加载这个资源； 强缓存与协商缓存的共同点是：如果命中，都是从本地缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发送请求到服务器，协商缓存会发送请求到服务器。 当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。 强缓存Expires 和 Cache-Control 都是强缓存。强缓存表示在缓存期间不发送请求,直接使用本地缓存 1Expires: Wed, 22 Oct 2018 08:41:00 GMT 表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 属于绝对时间，如果手动修改了本地时间，可能会造成缓存失效。 1Cache-control: max-age=300 表示资源会在 300 秒后过期，需要再次请求。属于相对时间，不受本地时间的影响。 同时存在时，听 Cache-control 的 协商缓存如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存会向服务端发送http请求，询问是否继续使用本地缓存，如果要使用本地缓存，则服务端返回304状态码。 Last-Modified 和 If-Modified-Since Last-Modified 表示文件最后修改日期第一次访问后端，后端返回文件和Last-Modified(假设2018-01-01)；再次访问后端时，请求头的If-Modified-Since会把Last-Modified的值给带上，后端接收到该值后，与服务器上的文件进行比较，如果服务器上的文件最后修改日期是2018-01-01，那就说明文件没有修改过，只返回304，不返回文件；如果服务器上的文件最后修改日期是2018-02-01，说明文件有更新，于是返回新的文件和Last-Modified值但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改【此时最后修改时间改变，但是文件本身没有做修改，造成重新下载资源】，所以在 HTTP / 1.1 出现了 ETag 。 ETag 和 If-None-Match 假设1分钟前请求了a.css，服务器下发了一个Etag是xxxxx；当浏览器再次请求a.css时，请求头中的 If-None-Match 会将这个 ETag值 发送给服务器，后端比较该资源 ETag 是否相同，两端的Etag值不同的话说明文件有更新，则发送新的资源和Etag。如果服务器发现该资源的Etag没有变动，那么只发送响应304(not modified)，而不会下载这个css文件ETag 优先级比 Last-Modified 高。 !注意：Etag会发送请求，返回304，不下载文件；Cache-Control直接不发送请求 开启Gzip压缩服务器用gzip压缩HTML、CSS、JS等各种文件后，将压缩包发送给浏览器浏览器接收到压缩包后，发现响应头是Content-Encoding:gzip，于是浏览器解压压缩包!注意：浏览器解压压缩包会消耗浏览器cpu，所以体积较小的文件不需要gzip，体积较大的文件适用gzip 使用CDN CDN可以增加域名数量，从而增加请求的并发数，达到同时下载多个文件的目的 内容分发网络：将静态资源分发到全球各地，让不同地区的人都能快速访问距离你最近的那个服务器 CDN没有cookie，因为cookie是发送给自己的服务器的 尽量使用css3动画代替js动画使用transform:translate3d(0,0,0) 开启GPU加速尽量使用translateX/Y代替left/top的移动使用事件委托减少监听器懒加载1&lt;img id="img1" src="loading.png" data-lazy="真实图片地址"&gt; 首先展示loading图 当执行到尾部的js文件时，再将图片链接换成真实的图片地址12var img1 = document.getElementById('img1');img1.src = img1.getAttribute('data-lazy'); 预加载减少DOM操作 缓存DOM查询,在for循环中缓存元素的length 合并DOM插入，利用文档片段【document.createDocumentFragment】 使用SSR后端渲染直接返回渲染好的html文件，这样就不需要发送ajax请求获取数据了 节流1234if(timer)&#123; clearTimerout(timer);&#125;timer = setTimeout(fn,1000); chrome调试方法chrome开发者工具 –&gt; Audits –&gt; Perform an audit –&gt; run audit运行完后会告诉你哪里需要进行优化]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>web前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mixin,柯里化,高阶函数]]></title>
    <url>%2F2018%2F05%2F25%2Fmixin-%E6%9F%AF%E9%87%8C%E5%8C%96-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[mixin混入柯里化（curry）高阶函数 mixin混入类的装饰器：ES6 中优雅的 mixin 式继承 什么是 mixin 呢？ 最基本的 mixin 其实就是简单地将一个对象的属性复制给另一个对象：1234567891011function mixin(target, src) &#123; for (var key in src) &#123; target[key] = src[key] &#125;&#125;var person = &#123;name: "akira", age: 25&#125;;var student = &#123;grade: 1,age:2&#125;;mixin(student, person);console.log(student); //&#123;grade: 1, name: "akira", age: 25&#125; JQuery的extend实现mixin12345678910111213var obj1 = &#123; apple: 0, banana: &#123; weight: 52, price: 100 &#125;, cherry: 97&#125;;var obj2 = &#123; banana: &#123; price: 200 &#125;, durian: 100&#125;;// 将obj2合并进obj1里$.extend( obj1, obj2 ); Object.assign1234let obj1=&#123;name:'stage',age:18&#125;;let obj2=&#123;city:'shanghai',gender:'男'&#125;;Object.assign(obj1,obj2);console.log(obj1) //&#123;name: "stage", age: 18, city: "shanghai", gender: "男"&#125; curry 柯里化gitbooks:第 4 章: 柯里化（curry） 函数f(x,y) = x+2y当x=1时，f(1,y) = 1+2y，此时只剩下自变量yg(y) = 1+2y我们把f(x,y)变成g(y)的过程称为柯里化柯里化的作用：减少自变量123456789function f(x,y)&#123; return x+2*y;&#125;function g(y)&#123; return f(1,y);//当x=1时&#125;//f(1,2) === g(2) === 5 上面的g(y)是将x=1定死，如果x的值不确定呢？1234567891011function f(x,y)&#123; return x+2*y;&#125;function g(x)&#123; //首先将参数x确定下来 return function(y)&#123; //然后return一个关于y的函数 return f(x,y); &#125;&#125;g(1)(2) //5 这样，将原本f(x,y)变成了g(x)(y)，每次只传一个参数 再来看个例子1234567891011var temp=[];function add(n)&#123; if(n)&#123; temp.push(n); return add; &#125;else&#123; return temp.reduce((sum,val)=&gt;sum+val,0); &#125;&#125;add(1)(2)(3)() //6 关于柯里化从纯粹的语义上，curry化就是lambda表达式(λ)的一个糖柯里化是因为 lambda 演算(λ)只有一个参数才被发明的，程序里用你除了恶心自己恶心别人并没有什么卵用。知乎：柯里化在工程中有什么好处? underscore中的_.partial高阶函数满足以下条件中的任意一个就是高阶函数： 接受一个或多个函数作为参数传入 return出一个函数]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象之继承]]></title>
    <url>%2F2018%2F05%2F25%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[从原型链 –&gt; 继承ES5的继承ES6的继承 原型链ps：prototype叫做原型，理解为“公有属性/方法”123456789101112var arr = new Array();arr.push();arr.valueOf();arr.__proto__指向Array的公有属性(Array.prototype)Array.prototype上有个push方法,因此arr顺着原型链找到push方法Array.prototype.__proto__指向Object的共有属性(Object.prototype),上面有valueOf()方法，因此arr顺着原型链找到了valueOf方法Object.prototype.__proto__指向null JS中没有类的概念，因此也就没有继承的说法。因此，只能把构造函数看作类本身公有属性里不存在的，需要顺着原型链找的属性/方法看作继承如果硬要说的话，arr的valueOf方法继承自Objectarr的push方法不是继承来的，而是实例属性（因为arr是个数组，而push是数组本来就有的公有属性，但valueOf与数组无关） 把构造函数看作类ES6之前，JS没有类的概念，因此只得把构造函数当做类12function Human()&#123;&#125;var person = new Human(); 继承继承可以使得子类具有父类所有的属性和方法。 ES5的继承 首先，声明一个父类Human 1234567function Human(name)&#123; this.name=name;&#125;Human.prototype.say=function()&#123; console.log('我叫'+this.name);&#125;var stage = new Human('stage'); 然后，声明一个子类Male 1234567function Male()&#123; this.gender = "男性";&#125;Male.prototype.hobby = function()&#123; console.log("男生喜欢玩电动");&#125;var Jack = new Male(); 接着，让子类Male继承父类Human的私有属性 12345function Male(name,age)&#123; Human.call(this,name);//将父类的私有属性name传过来 this.gender = "男性"; this.age = age;&#125; 现在，子类Male继承了父类Human的属性，只差让子类的 原型 链接到 父类的prototype 最后，让子类继承父类的公有属性(prototype) 12Male.prototype.__proto__ = Human.prototype;//Male的 原型 链接到 Human的 原型 至此，子类Male继承了父类Human的name属性和say()方法 最终写法：12345678910111213141516171819202122//父类function Human(name)&#123; this.name=name;&#125;Human.prototype.say=function()&#123; console.log('我叫'+this.name);&#125;//子类function Male(name,age)&#123; Human.call(this,name);//将父类的私有属性name传过来 this.gender = "男性"; this.age = age;&#125;Male.prototype.hobby = function()&#123; console.log("男生喜欢玩电动");&#125;Male.prototype.__proto__ = Human.prototype;var stage = new Male('stage',22); 兼容IE的继承由于IE11以下不支持Male.prototype.__proto__ = Human.prototype;所以这一句要改写成123function Fn()&#123;&#125; //声明一个空的构造函数Fn.prototype = Human.prototype;Male.prototype = new Fn(); 因此，ES5兼容IE的继承写法12345678910111213141516171819202122232425//父类function Human(name)&#123; this.name=name;&#125;Human.prototype.say=function()&#123; console.log('我叫'+this.name);&#125;//子类function Male(name,age)&#123; Human.call(this,name);//将父类的私有属性name传过来 this.gender = "男性"; this.age = age;&#125;//将父类的公有属性传过来function Fn()&#123;&#125; //声明一个空的构造函数Fn.prototype = Human.prototype;Male.prototype = new Fn();Male.prototype.hobby = function()&#123; console.log("男生喜欢玩电动");&#125;var stage = new Male('stage',22); new做了些什么 var this = {} 产生一个空对象，且this指向这个空对象 this.proto = 构造函数.prototype【举例：var stage = new Human(‘stage’)，则stage.proto === Human.prototype】 执行构造函数.apply(this,arguments) return this(生成的对象) ES6的继承在ES6中，将私有属性写在constructor里面，公有属性写在外面12345678910111213141516171819202122232425//定义父类class Human&#123; constructor(name)&#123; //私有属性 this.name = name; &#125;; //公有属性 say()&#123; console.log("我叫"+this.name); &#125;;&#125;//子类class Male extends Human&#123;//将子类的prototype.__proto__链接到Human的公有属性 constructor(name,age)&#123; super(name); //将父类的私有属性name传进来 this.gender = '男'; this.age = age; &#125;; hobby()&#123; console.log('男生喜欢玩电动'); &#125;;&#125;let stage = new Male('stage',22); ES6中class的缺陷在ES5中，类的私有属性和公有属性上都可以有属性(变量)1Human.prototype.race = '人族'; 而在ES6中，公有属性上只能放方法(函数)，如果要放属性(变量),非常麻烦，要用get12345678910111213141516//定义父类class Human&#123; constructor(name)&#123; //私有属性 this.name = name; &#125;; //公有属性/方法 //属性 get race()&#123; return '人族'; &#125;; //方法 say()&#123; console.log("我叫"+this.name); &#125;;&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
        <tag>es6</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的组件通信]]></title>
    <url>%2F2018%2F05%2F22%2Fvue%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[数据通信的4种方式：绑定引用类型(Object地址)、emit自定义事件、全局eventHub、Vuex父子组件通信爷孙组件通信兄弟组件通信 更新最新文档中提出，可以使用$root来访问根实例的数据 数据通信的方式 引用类型数据：v-bind引用data里的数据 自定义事件：子组件emit一个自定义事件，父组件监听这个自定义事件 全局事件：eventHub 状态管理：Vuex 引用类型数据当引用的类型是对象(Object)时，由于引用的是对象的内存地址，因此，当子组件修改数据时，父组件也会跟着修改（因为他们指向同一个地址）1234&lt;div id="app"&gt; &#123;&#123;obj.age&#125;&#125; &lt;xxx :obj="obj"&gt;&lt;/xxx&gt;&lt;/div&gt; 123456789101112131415161718192021Vue.component('xxx',&#123; props:['obj'], template:`&lt;h1&gt;&#123;&#123;obj2.age&#125;&#125;&lt;/h1&gt;`, data()&#123; return &#123; obj2:this.obj, &#125; &#125;, created()&#123; setTimeout(()=&gt;&#123; this.obj2.age=1; &#125;,5000) &#125;&#125;);new Vue(&#123; el:'#app', data:&#123; obj:&#123;age:18&#125; &#125;&#125;) 父组件的obj和子组件的obj2指向同一个内存地址，因此，当子组件的obj2修改数据时，父组件的obj也会跟着修改 【点击查看例子】 为了避免子组件修改数据时对父组件的影响，需要对Object类型的数据进行深拷贝12345data()&#123; return &#123; obj2:JSON.parse(JSON.stringify(this.obj)) &#125; &#125;, 【点击查看例子】 父子组件通信 父传子通过props父组件使用 props 传递数据给子组件123&lt;div id="app"&gt; &lt;message msg="hello world"&gt;&lt;/message&gt;&lt;/div&gt; 12345678Vue.component('message',&#123; props:['msg'], template:`&lt;div&gt;&lt;p :title="msg"&gt;我是儿子，我的父亲说&lt;b&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&lt;b&gt;&lt;/div&gt;`,&#125;);new Vue(&#123; el:'#app',&#125;); Prop验证12345678910111213141516171819202122232425262728293031Vue.component('my-component', &#123; props: &#123; propA: Number, propB: [String, Number], // 必填的字符串 propC: &#123; type: String, required: true &#125;, // 带有默认值的数字 propD: &#123; type: Number, default: 100 &#125;, // 带有默认值的对象 propE: &#123; type: Object, // 对象或数组的默认值需要写成函数形式return出去 default() &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数validator,参数value是父组件传过来的值 propF: &#123; validator(value) &#123; // /验证父组件传进来的值是否满足以下条件 return value &gt; 10; &#125; &#125; &#125;&#125;) $parent访问父组件实例$parent 属性可以让子组件访问父组件的实例。它可以直接触达父组件，以替代将数据以 props 的方式传入子组件。这种直接获取父组件数据的方式不推荐使用，因为这会使得你的应用更难调试和理解。123Vue.component('Hello',&#123; template:'&lt;p&gt;&#123;&#123;this.$parent.msg&#125;&#125;&lt;/p&gt;'&#125;) 【点击查看例子】 子传父父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，就需要使用自定义事件！ 我们可以使用 v-on 绑定自定义事件, 每个 Vue 实例都实现了事件接口(Events interface)，即： 使用 $on(eventName) 监听事件 使用 $emit(eventName) 触发事件 子组件无法直接修改父组件的数据，必须通过$emit()通知父组件，让父组件修改父组件的数据 如果这个事件处理函数是一个方法：1234&lt;div id="app"&gt; &lt;child-say @say="doSomethig"&gt;&lt;/child-say&gt; &lt;div v-if="seen"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/div&gt; 那么组件$emit 发出的第一个参数 将会作为该方法的第一个参数：12345678910111213141516171819202122Vue.component('child-say',&#123; template:`&lt;button @click="handleClick"&gt;儿子说&lt;/button&gt;`, methods:&#123; handleClick()&#123; this.$emit('say',&#123;a:'hello',b:'world'&#125;); &#125;, &#125;,&#125;);new Vue(&#123; el:'#app', data:&#123; seen:false, msg:'' &#125;, methods:&#123; doSomethig(data)&#123; //第一个参数就是子组件$emit 发出的第一个参数 this.seen = !this.seen; this.msg=data.a+' '+data.b &#125;, &#125;,&#125;); 另一个例子【点击查看例子】 一个简单的TodoList【点击查看例子】 $refs访问子组件实例你可以通过 ref 特性为每个子组件赋予一个唯一的ID引用,然后就能直接访问每个子组件实例了。这种直接获取子组件数据的方式不推荐使用，因为这会使得你的应用更难调试和理解。1234567&lt;div id="app"&gt; &lt;a-cp ref="a"&gt;&lt;/a-cp&gt; &lt;b-cp ref="b"&gt;&lt;/b-cp&gt; &lt;c-cp ref="c"&gt;&lt;/c-cp&gt; &lt;button @click="getMsg"&gt;获取C组件里的msg&lt;/button&gt; &#123;&#123;msg&#125;&#125;&lt;/div&gt; 1234567891011new Vue(&#123; el:'#app', data:&#123; msg:'暂未获取' &#125;, methods:&#123; getMsg()&#123; this.msg = this.$refs.c.msg; &#125; &#125;&#125;) JS Bin【点击查看例子】 在HTML中通过$event获取参数https://cn.vuejs.org/v2/guide/components.html#%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E6%8A%9B%E5%87%BA%E4%B8%80%E4%B8%AA%E5%80%BC 如果这个事件处理函数不在methods里，而是在HTML中。那么通过$event获取$emit 发出的第一个参数 12//组件中$emit('say',&#123;a:'hello',b:'world'&#125;); 在HTML中，父级通过 $event 访问到$emit发出的第一个参数1234&lt;div id="app"&gt; &#123;&#123;msg&#125;&#125; &lt;child-say @say="msg=$event"&gt;&lt;/child-say&gt;&lt;/div&gt; 【点击查看例子】 组件绑定原生事件在 Vue 2.0 中，为自定义组件绑定原生事件必须使用 .native 修饰符：1&lt;my-component @click.native="handleClick"&gt;Click Me&lt;/my-component&gt; .sync 修饰符文档：sync修饰符在有些情况下，我们可能需要对一个 prop 进行“双向绑定”，使子组件的prop修改时，父组件的data也跟着改变。为了方便起见，我们为这种模式提供一个缩写，即 .sync 修饰符,其实它是v-on:update的语法糖1234Vue.component('child-say',&#123; props:['msg'], template:`&lt;button @click="$emit('update:msg','儿子的值')"&gt;儿子改变父亲的data&lt;/button&gt;`,&#125;); 1234&lt;child-say :msg="msg" v-on:update:msg="msg = $event"&gt;&lt;/child-say&gt; 上面的代码用.sync语法糖改写如下：1&lt;child-say :msg.sync="msg"&gt;&lt;/child-say&gt; 【点击查看例子】 爷孙通信 爷孙之间无法直接通信 爷爷必须先通过props将数据传给父组件，然后靠父组件将数据传给孙组件 孙组件必须先通过$emit通知父组件，然后靠父组件将数据传回给爷组件 12345&lt;div id="grandfather"&gt; 我是爷爷 &lt;button @click="seen=true"&gt;打开孙子&lt;/button&gt; &lt;father :seen="seen" @close="seen=false"&gt;&lt;/father&gt;&lt;/div&gt; 123456789101112131415161718Vue.component('father',&#123; props:['seen'], template:`&lt;div&gt;我是父亲 &lt;child v-show="seen" @close="$emit('close')"&gt;&lt;/child&gt;&lt;/div&gt;`,&#125;);Vue.component('child',&#123; template:`&lt;div&gt;我是孙子&lt;button @click="$emit('close')"&gt;关闭&lt;/button&gt;&lt;/div&gt;`, &#125;);new Vue(&#123; el:'#grandfather', data:&#123; seen:false, &#125;,&#125;); 兄弟组件通信(利用事件总线)利用eventHub(也叫eventBus)实现兄弟组件通信通过使用事件中心，允许组件自由交流，无论组件处于组件树的哪一层。由于 Vue 实例实现了一个事件分发接口，你可以通过实例化一个空的 Vue 实例来实现这个目的。 目前事件总线是解决兄弟间通信，祖父祖孙间通信的最佳方法 一个组件通过bus.$emit(&#39;自定义事件名&#39;,参数)来发布事件 另一个组件在created阶段，监听bus.$on(&#39;自定义事件名&#39;,(参数) = &gt;{ 执行代码 }) 1234&lt;div id="app"&gt; &lt;gege&gt;&lt;/gege&gt; &lt;didi&gt;&lt;/didi&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233var eventHub = new Vue();//事件管理中心Vue.component('gege',&#123; template:`&lt;div&gt;哥哥说：&lt;input @keyup="handleKeyup" type="text" v-model="gege_say"&gt;&lt;/div&gt;`, data()&#123; return &#123; gege_say:'', &#125; &#125;, methods:&#123; handleKeyup()&#123; eventHub.$emit('gegeSay',this.gege_say); &#125;, &#125;,&#125;);Vue.component('didi',&#123; template:`&lt;div&gt;我是弟弟，我的哥哥他说：&#123;&#123;msg&#125;&#125;&lt;/div&gt;`, data()&#123; return &#123; msg:'', &#125; &#125;, created()&#123; eventHub.$on('gegeSay',data=&gt;&#123; this.msg=data; &#125;); &#125;,&#125;);new Vue(&#123; el:'#app',&#125;); 改进为了避免全局变量，将eventHub放到Vue的原型上https://blog.csdn.net/a5534789/article/details/53415201https://juejin.im/entry/59828fdd6fb9a03c5754b8abObject.defineProperty(Vue.prototype, ‘$axios’, { value: axios })1234567891011121314151617181920212223242526272829303132333435//将空的 Vue 实例放到vue的原型上作为事件中心Vue.prototype.$eventHub = new Vue();Vue.component('gege',&#123; template:`&lt;div&gt;哥哥说：&lt;input @keyup="handleKeyup" type="text" v-model="gege_say"&gt;&lt;/div&gt;`, data()&#123; return &#123; gege_say:'', &#125; &#125;, methods:&#123; handleKeyup()&#123; this.$eventHub.$emit('gegeSay',this.gege_say); &#125;, &#125;,&#125;);Vue.component('didi',&#123; template:`&lt;div&gt;我是弟弟，我的哥哥他说：&#123;&#123;msg&#125;&#125;&lt;/div&gt;`, data()&#123; return &#123; msg:'', &#125; &#125;, created()&#123; this.$eventHub.$on('gegeSay',data=&gt;&#123; this.msg=data; &#125;); &#125;,&#125;);new Vue(&#123; el:'#app',&#125;); 另一个例子【点击查看例子】 再看一个例子1234&lt;div id="app"&gt; &lt;cp-a&gt;&lt;/cp-a&gt; &lt;cp-b&gt;&lt;/cp-b&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930Vue.prototype.$bus = new Vue();Vue.component('cp-a',&#123; template:`&lt;div&gt;组件A&lt;button @click="handleClick"&gt;将组件A的msg传给组件B&lt;/button&gt;&lt;div&gt;`, data()&#123; return &#123; msg:'来自组件A的问候' &#125; &#125;, methods:&#123; handleClick()&#123; this.$bus.$emit('xxx',this.msg); &#125; &#125;&#125;);Vue.component('cp-b',&#123; template:`&lt;div&gt;组件B -- &#123;&#123;msg&#125;&#125;&lt;/div&gt;`, data()&#123; return &#123; msg:'' &#125; &#125;, created()&#123; this.$bus.$on('xxx',msg=&gt;&#123; this.msg = msg; &#125;); &#125;&#125;); JS Bin【点击查看例子】 eventHub123//eventHub.jsimport Vue from 'vue';export default new Vue(); 1234567891011121314151617//子组件&lt;template&gt; &lt;h1 @click="hello()"&gt;&#123;&#123; xxx &#125;&#125;&lt;/h1&gt;&lt;/template&gt;&lt;script&gt;import eventHub from "../eventHub.js";export default &#123; props: ["xxx"], methods: &#123; hello() &#123; eventHub.$emit('hello','yoooooo'); &#125; &#125;&#125;&lt;/script&gt; 12345678910111213141516171819202122232425262728//父组件&lt;template&gt; &lt;div id="app"&gt; &lt;HelloWorld :xxx="xxx"/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from "./components/HelloWorld";import eventHub from "./eventHub.js";export default &#123; components: &#123; HelloWorld &#125;, created() &#123; eventHub.$on("hello", str =&gt; &#123; this.xxx = str; &#125;); &#125;, data() &#123; return &#123; xxx: "stage" &#125;; &#125;&#125;;&lt;/script&gt; $root访问根组件实例为什么要弄个 Bus？直接 this.$root.$on、this.$root.$emit 不更简单粗暴？答：按照文档上的说法是专门用一个空的 Vue 实例（Bus）来做中央事件总线更加清晰也易于管理。掘金：非父子组件通信方法 文档：$root在每个 new Vue 实例的子组件中，其根实例可以通过 $root 属性进行访问。例如，在这个根实例中：123456789101112// Vue 根实例new Vue(&#123; data: &#123; foo: 1 &#125;, computed: &#123; bar()&#123; /* ... */ &#125; &#125;, methods: &#123; baz()&#123; /* ... */ &#125; &#125;&#125;) 所有的子组件都可以将这个实例作为一个全局 store 来访问或使用。1234567891011// 获取根组件的数据this.$root.foo// 写入根组件的数据this.$root.foo = 2// 访问根组件的计算属性this.$root.bar// 调用根组件的方法this.$root.baz() 【点击查看例子】 简书：vuejs填坑-父子组件之间的访问 在组件上使用 v-modelhttps://cn.vuejs.org/v2/guide/components.html#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-v-model 1&lt;my-input v-model="searchText"&gt;&lt;/my-input&gt; 为了让它正常工作，这个组件内的 input 必须： props: [‘value’] $emit(‘input’, $event.target.value) 123456789Vue.component('my-input', &#123; props: ['value'], template: ` &lt;input :value="value" @input="$emit('input', $event.target.value)" &gt; `&#125;) JS Bin【点击查看例子】 在非表单控件的组件上也能用v-modelv-model本质上是个语法糖，它与value绑定，并监听input事件。因此，只要满足以下条件，就能在非表单控件上使用v-model props:[‘value’] this.$emit(‘input’,参数) 1&lt;hello v-model="count"&gt;&lt;/hello&gt; 12345678910Vue.component('Hello',&#123; props:['value'], template:'&lt;button @click="handleClick"&gt;&#123;&#123;value&#125;&#125;&lt;/button&gt;', methods:&#123; handleClick()&#123; this.value++; this.$emit('input',this.value); &#125; &#125;&#125;) 【点击查看例子】 Vuex进行状态管理对于大多数复杂情况，更推荐使用一个专用的状态管理层：Vuex。 小技巧自定义事件名https://cn.vuejs.org/v2/guide/components-custom-events.html#%E4%BA%8B%E4%BB%B6%E5%90%8D 自定义事件始终使用 kebab-case 的事件名【跟组件和 prop 不同，事件名不会自动进行大小写转换。】123this.$emit('my-event')&lt;my-component @my-event="doSomething"&gt;&lt;/my-component&gt; 绑定多个事件1&lt;div v-on="&#123;clickSaveBtn, print, clickLogout&#125;"&gt;&lt;/div&gt; 组件绑定原生事件在 Vue 2.0 中，为自定义组件绑定原生事件必须使用 .native 修饰符：1&lt;my-component @click.native="handleClick"&gt;Click Me&lt;/my-component&gt; $emit()中的事件名称始终用kebab-case12this.$emit('myEvent') //报错this.$emit('my-event') 1&lt;my-component @my-event="doSomething"&gt;&lt;/my-component&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的选项卡]]></title>
    <url>%2F2018%2F05%2F14%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%80%89%E9%A1%B9%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[将面向过程的选项卡改写成面向对象的形式 面向过程的选项卡123456789101112131415window.onload = function()&#123; var aBtn = document.getElementsByTagName('button'); var aDiv = document.getElementsByTagName('div'); for(var i=0;i&lt;aBtn.length;i++)&#123; aBtn[i].index=i; aBtn[i].onclick=function()&#123; for(var j=0;j&lt;aBtn.length;j++)&#123; aBtn[j].className=''; aDiv[j].style.display='none'; &#125; this.className='active'; aDiv[this.index].style.display='block'; &#125; &#125;&#125; 改写成面向对象 将嵌套的函数挪到外部,变成构造函数prototype上的方法 最大的那个函数变成构造函数 将变量变成属性，函数变成方法 所有属性和prototype上的方法前面添加this 调整this的指向 使用new运行这个构造函数 函数不能有嵌套，将嵌套的函数提到外面1234567891011121314151617window.onload = function()&#123; var aBtn = document.getElementsByTagName('button'); var aDiv = document.getElementsByTagName('div'); for(var i=0;i&lt;aBtn.length;i++)&#123; aBtn[i].index=i; aBtn[i].onclick = fnTab; &#125;&#125;function fnTab()&#123; for(var j=0;j&lt;aBtn.length;j++)&#123; aBtn[j].className=''; //此处无法获取aBtn，因为aBtn声明在onload的内部 aDiv[j].style.display='none';//此处无法获取aDiv，因为aDiv声明在onload的内部 &#125; this.className='active'; aDiv[this.index].style.display='block';&#125; 共用的变量要在外部先声明123456789101112131415161718192021//将共用的变量声明在全局var aBtn = null;var aDiv = null;window.onload = function()&#123; aBtn = document.getElementsByTagName('button'); aDiv = document.getElementsByTagName('div'); for(var i=0;i&lt;aBtn.length;i++)&#123; aBtn[i].index=i; aBtn[i].onclick = fnTab; &#125;&#125;function fnTab()&#123; for(var j=0;j&lt;aBtn.length;j++)&#123; aBtn[j].className=''; aDiv[j].style.display='none'; &#125; this.className='active'; aDiv[this.index].style.display='block';&#125; 将总集合的函数变成构造函数 变成构造函数 变量 -&gt; 属性(所有变量名前面加上this) 函数 -&gt; 方法(将函数放到构造函数的prototype上) 1234567891011121314151617181920//变成构造函数function TabSwitch()&#123; //将变量变成属性 this.aBtn = document.getElementsByTagName('button'); this.aDiv = document.getElementsByTagName('div'); for(var i=0;i&lt;this.aBtn.length;i++)&#123; this.aBtn[i].index=i; this.aBtn[i].onclick = this.fnTab; &#125;&#125;//函数变成构造函数prototype上的方法TabSwitch.prototype.fnTab = function()&#123; for(var j=0;j&lt;this.aBtn.length;j++)&#123; this.aBtn[j].className=''; this.aDiv[j].style.display='none'; &#125; this.className='active'; this.aDiv[this.index].style.display='block';&#125; 调整this的指向修改this1234567891011121314151617181920212223242526new TabSwitch();function TabSwitch()&#123; var _this = this; //_this === TabSwitch //将变量变成属性 this.aBtn = document.getElementsByTagName('button'); this.aDiv = document.getElementsByTagName('div'); for(var i=0;i&lt;this.aBtn.length;i++)&#123; this.aBtn[i].index=i; this.aBtn[i].onclick = function ()&#123; //通过闭包，获取函数外部的_this _this.fnTab(); //此处的this指向aBtn[i],而我要调用的是构造函数上的fnTab方法，所以要用_this &#125;; &#125;&#125;//函数变成构造函数prototype上的方法TabSwitch.prototype.fnTab = function()&#123; for(var j=0;j&lt;this.aBtn.length;j++)&#123; this.aBtn[j].className=''; this.aDiv[j].style.display='none'; &#125; this.className='active'; this.aDiv[this.index].style.display='block';&#125; 将构造函数内的this传给方法12345678910111213141516171819202122232425new TabSwitch();function TabSwitch()&#123; var _this = this; //_this === TabSwitch //将变量变成属性 this.aBtn = document.getElementsByTagName('button'); this.aDiv = document.getElementsByTagName('div'); for(var i=0;i&lt;this.aBtn.length;i++)&#123; this.aBtn[i].index=i; this.aBtn[i].onclick = function ()&#123; _this.fnTab(this); //this指向aBtn[i],将这个this传给方法fnTab &#125;; &#125;&#125;//函数变成构造函数prototype上的方法TabSwitch.prototype.fnTab = function(oBtn)&#123;//接收传过来的aBtn[i] for(var j=0;j&lt;this.aBtn.length;j++)&#123; this.aBtn[j].className=''; this.aDiv[j].style.display='none'; &#125; oBtn.className='active'; this.aDiv[oBtn.index].style.display='block';&#125; 最终代码]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 vue简历编辑器实战总结]]></title>
    <url>%2F2018%2F05%2F08%2Fvue%E7%AE%80%E5%8E%86%E7%BC%96%E8%BE%91%E5%99%A8%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[用vue做一个项目的详细步骤总结 初始化项目 npm init -y：在当前目录执行这条命令，生成package.json文件 引入LeanCloud eval的替代方法12345678function evil(str) &#123; var Fn = Function; //一个变量指向Function，防止有些前端编译工具报错 return new Fn('return ' + str)();&#125;//测试↓var obj = &#123;a:1&#125;;evil('obj.a'); // 1]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>教程</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 vue的相关面试题]]></title>
    <url>%2F2018%2F05%2F07%2Fvue%E7%9A%84%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[vue的相关面试题vue中文文档合集印记中文docschina 请简述MVVMMVVM是Model-View-ViewModel的缩写 view：HTML页面 ViewModel：业务逻辑层(一切js可以看作业务逻辑，比如表单提交、自定义事件的注册和处理逻辑都在vm里面负责监控两边的数据) model：数据层，用于对数据的处理(比如增删改查) 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，因此开发者不需要关注DOM操作了。 DOM Listeners和Data Bindings是实现双向绑定的关键。DOM Listeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化Data Bindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。 MVVM详细的实现 mvvm和mvc区别主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。 区别：vue数据驱动，通过数据来显示视图层而不是节点操作。场景：数据操作比较多的场景，更加便捷 vue.js的优点 简洁： HTML 模板 + JSON 数据，再创建一个 Vue 实例，就这么简单。 数据驱动： 自动追踪依赖的模板表达式和计算属性。 组件化： 用解耦、可复用的组件来构造界面。 轻量： ~24kb min+gzip，无依赖。 快速： 精确有效的异步批量 DOM 更新。 另一种答案： 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写易用灵活高效 vue与react和angular的对比响应式原理官方文档-深入响应式原理 MVVM详细的实现vue源码解析当面试官问你Vue响应式原理，你可以这么回答他 深入浅出响应式原理 生命周期视频讲解：https://jirengu.com/app/album/92 生命周期钩子函数Vue提供的可以注册的钩子都在上图片的红色框标注。 他们分别是： beforeCreate：在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。 created：实例创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，尚未挂载到DOM上，$el 还不可用。 beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted：el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 beforeUpdate：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。 | 钩子函数 | 描述 | 例子 || ——– | —— | ——— || beforeCreate | 实例初始化，$el 与 data 都未初始化 | 此时无法获取到this(data和methods) || created | 实例创建完成，data 配置完成但挂载还未开始 $el 仍未初始化 | 此时可以获取到this(data和methods)，一般用于异步数据的请求/初始化(将$bus绑定到this.prototype、读取localStorage等) || beforeMount |挂载开始前，render 函数被调用，$el 和 data 配置完成，但数据未在 DOM 上渲染 || mounted | 挂载完成，el 被新创建的 vm.$el 替换并挂载到实例上去，data里的初始数据在 DOM 上渲染完毕 | 此时可以获取由data里初始数据渲染后的DOM节点 || beforeUpdate | 数据更新时调用，但不进行 DOM 重新渲染 || updated | 数据更新并且 DOM 重新渲染，此时可执行依赖于 DOM 的操作 | 此时可以获取到异步请求的数据替换初始数据渲染后的DOM节点 || beforeDertroy | 实例销毁前 || destroyed | 实例销毁后 | 日期new Date()不能放在data:{time:new Date()}，这样日期不会实时变化，可以放在created或者mounted这两个生命周期函数内12345mounted()&#123; timer = setInterval(()=&gt;&#123; this.time = new Date(); &#125;,1000);&#125; 【时间与生命周期函数】 updated和this.$nextTick(callback)api：this.$nextTick(callback)在数据改变之后立即使用this.$nextTick，待 DOM 渲染完成之后，会执行nextTick里的callback123456789101112131415161718192021created:&#123; //异步请求 axios().then(()=&gt;&#123; this.lists = [4,5,6]; this.$nextTick(()=&gt;&#123; console.log('第1次更新'); &#125;); &#125;); axios().then(()=&gt;&#123; this.lists = [7,8,9,10]; this.$nextTick(()=&#123; console.log('第2次更新'); &#125;); &#125;);&#125;,updated:&#123; console.log(1); //每次数据有变化，都会执行updated //由于lists更新了2次，所以会打印2次1 //如果不希望每次数据变化都执行，或者想要执行不同的方法，可以用this.$nextTick&#125; 如果在数据变化并重新渲染DOM完成之后，要操作DOM，就用this.$nextTick如果不操作DOM，那就用watch侦听器updated：只要data里的任何一个数据发生变化，就会触发；watch可以侦听data里具体某个数据的变化 组件化组件化应用构建一个页面可能会有页头、侧边栏、内容区等界面，将这些界面抽象为一个个小型、独立和通常可复用的组件。通过 Prop 向子组件传递数据使用$emit事件向父组件抛出一个值举例子： 查看官方示例源码查看todoMVC示例,并能够自己写出来源码 单文件组件.vue单文件组件 单文件组件必须要有&lt;template&gt;；&lt;style&gt;可以有多个 style可以通过@import将样式引入进单vue文件的style里1234&lt;style scoped&gt; @import './member_base.css'; @import './member.css';&lt;/style&gt; vue-loadervue-loader 路由vue-routervue-router 状态管理vuexvuex vue的相关周边 github:vue-cli vue-cli中文文档 vue-devtools vue-webpack模板文档 面试题资料https://www.jianshu.com/p/b1dd80f4d542http://www.imooc.com/article/details/id/23787]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 面向对象初级知识]]></title>
    <url>%2F2018%2F05%2F03%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E7%BA%A7%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[面向对象基础知识(概念、特点)构造函数用new命令构造函数的缺陷(浪费内存) –&gt; 解决方法：公有方法放到原型prototype上原则上，构造函数内放私有属性，原型上放公有方法如果在构造函数内找不到，就会自动顺着原型链找【test.age === test.proto.age === Person.prototype.age】 面向对象的概念面向对象:只关心对象的使用，不关心内部的实现原理。比如数组Array的.sort()方法可以对数组进行排序，我们不需要知道它的内部实现原理，只要会用它的这个方法就行了。 jQuery就是面向对象。 面向对象编程(OOP)特点： 抽象：人有许多特性，如果写一个员工管理系统，只需要将姓名、工作时长、工资等关键特性抽出来就行了；如果写一个医疗系统，就需要将身高、体重、血型等抽出来。 封装：无需知道内部实现原理，就能使用对象的属性和方法 继承：var arr = [1,2,3]继承了数组Array的所有属性和方法，Array继承了Object的所有属性和方法；因此arr具有Array和Object的所有属性和方法，并且arr具有自己的一些新特性 多重继承：大箱子 + 卡车 = 集装箱货车 多态 this当前函数/方法属于谁，this就是谁12345678910111213141516171819202122oDiv.onclick = function()&#123; console.log(this);&#125;onclick方法属于oDiv,所以this指向oDiv------------function x()&#123; console.log(this);&#125;x();函数x属于window【等同于window.show=function()&#123;console.log(this)&#125;】,所以this指向window---------------var obj = &#123; a:12, show:function()&#123; console.log(this.a); &#125;&#125;obj.show(); //12show()这个方法属于obj，所以this指向obj,因此this.a就是12 构造函数(大写)典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。“类”就是对象的模板，对象就是“类”的实例。 但是，JavaScript，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。 JavaScript 使用构造函数（constructor）作为对象的模板。”构造函数”就是用来生成实例对象的函数。它是对象的模板，给实例对象内置一些属性和方法。一个构造函数，可以生成多个实例对象，这些实例对象都内置相同的属性和方法。 123var Vehicle = function () &#123; this.price = 1000;&#125;; 为了与普通函数区别，构造函数名字的第一个字母通常大写。 构造函数生成实例对象的时候，必须使用new命令。 new12var v = new Vehicle();v.price // 1000 用new命令时，默认给构造函数的起始位置加上var this = {}，结尾默认return this12345function x()&#123; console.log(this);&#125;x(); //windownew x(); //对象&#123;&#125; new做了些什么 var this = {} 产生一个空对象，且this指向这个空对象 this.proto = 构造函数.prototype【举例：var stage = new Human(‘stage’)，则stage.proto === Human.prototype】 执行构造函数.call(this,参数1,参数2...) return this(生成的对象) 工厂模式() 原料 加工 怵场 1234function Vehicle() &#123; //默认内部有一个var this = &#123;&#125; 作为原料 this.price = 1000; //加工 //默认最终将this return出去&#125; 原型对象prototype作用：将一模一样的属性和方法放到原型对象prototype上，构造函数内留私有方法 构造函数的缺陷12345678910111213function Cat(name, color) &#123; this.name = name; this.color = color; this.meow = function () &#123; console.log('喵喵'); &#125;;&#125;var cat1 = new Cat('大毛', '白色');var cat2 = new Cat('二毛', '黑色');cat1.meow === cat2.meow// false 系统资源浪费 上面代码中，cat1和cat2是同一个构造函数的两个实例，它们都具有meow方法。由于meow方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个meow方法。这就造成了系统资源浪费，因为所有meow方法都是一模一样的，完全可以共享。 这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。 123456789101112131415function Animal(name) &#123; this.name = name;&#125;Animal.prototype.color = 'white';Animal.prototype.walk = function () &#123; console.log(this.name + ' is walking');&#125;;var cat1 = new Animal('大毛');var cat2 = new Animal('二毛');cat1.walk(); //大毛 is walkingcat1.color // 'white'cat2.color // 'white'cat1.color === cat2.color //true 节省资源 当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。1234cat1.color = 'black';cat1.color // 'black'cat2.color // 'white' 如果构造函数里找不到，就会顺着原型链一步步找下去test.age === test.proto.age === Person.prototype.age12345678910function Person(name)&#123; this.name=name;&#125;Person.prototype.age='18岁';var test = new Person('stage');console.log(tset.name); //stageconsole.log(test.age); //18岁 【在它的原型上找到了属性age】test.age === test.__proto__.age === Person.prototype.age 类与实例对象类：模子 -&gt; 植入默认的属性和方法实例对象：产品 -&gt; 使用默认的属性和方法 总结原则： 构造函数用来加私有属性 原型用来加公有方法 如果构造函数里找不到，就会顺着原型链一步步找下去【test.age === test.proto.age === Person.prototype.age】]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 JQuery版云音乐]]></title>
    <url>%2F2018%2F04%2F17%2Fjquery%E7%89%88%E4%BA%91%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[云音乐需求分析利用LeanCloud用来存取数据利用七牛云存储保存静态文件(图片、mp3、视频、js文件、css文件) 需求分析用例图use-cases用户能够： 查看首页 歌曲列表页 评论 播放页 播放 暂停 歌词 搜歌 按歌名搜 按歌手搜 后台能够： 登录 注册 忘记密码 上传歌曲 拖拽上传 编辑歌曲 删除 线框图Sketchxiaopiu:网易云音乐原型图 架构图 LeanCloud的使用LeanCloud只能用来存数据/字符串，无法存文件(比如mp3、视频等)ACL(Access Control Layer)访问控制层：控制可读/可写SDK(api套件)：给你一堆api 用LeanCloud创建数据库 登录LeanCloud 创建应用(等同于创建了个数据库) 点开，选择创建Class,User用来存管理员信息，Song用来存歌曲信息，Playlist用来存歌单信息 使用 npm 的包管理工具安装 SDK1234 # 存储服务（包括推送和统计）$ npm install leancloud-storage --save等同于$ npm i leancloud-storage -S Git Bash创建本地仓库git --version：查看git Bash 版本号ll -a:罗列当前目录下的文件，包括隐藏的tree:展开当前目录下所有文件cd ..:返回上一级目录 新建一个目录，mkdir src文件夹放初始源码，mkdir dist文件夹用来放编译之后的代码 在当前目录下打开命令行，输入npm init -y:模块初始化 忽略node_modules文件夹，touch .gitignore新建忽略文件 –&gt;vi .gitignore用vi打开 –&gt; /node_modules填入要忽略的文件,这样这个文件夹就不会上传到github 退出vim: esc + : + w + q git init：初始化本地仓库 git status -sb,这个 ?? 表示 git 一脸懵逼，不知道你要怎么对待这些变动。另外，可以看到没有node_modules,说明成功ignore了 git add:你可以一个一个地add git add index.html,git add css/style.css，也可以add整个目录git add . git commit -m:你可以一个一个地 commit,git commit index.html -m &#39;添加index.html&#39;,git commit css/style.css -m &quot;添加 css/style.css&quot;,你也可以一次性 commit git commit . -m &quot;添加了几个文件&quot; git commit -v提交时显示所有diff信息 在src下新建index.html,开始写代码 初始化LeanCloud并验证初始化1234567var APP_ID = 'uTQBfXRvG7xxxxxxxxxxx-gzGzoHsz';var APP_KEY = 'xKkNrIrxxxxxxxxxxxxxxxfvNS';AV.init(&#123; appId: APP_ID, appKey: APP_KEY&#125;); 验证123456789101112测试代码：//在数据库中创建Class，名为TestObjectvar TestObject = AV.Object.extend('TestObject');//获取名为TestObject的Classvar testObject = new TestObject();testObject.save(&#123; //保存 words: 'Hello World!'到该Class中 words: 'Hello World!'&#125;).then(function(object) &#123; alert('LeanCloud Rocks!');&#125;) 存数据save123456789101112//在数据库中创建Class，名为Songvar Song = AV.Object.extend('Song');//获取名为Song的Classvar song = new Song();song.save(&#123; songName:'小幸运', singer:'田馥甄'&#125;).then(function(response) &#123; console.log("response:",response) alert('上传成功!');&#125;) 批量获取数据find数据存储开发指南 选择开发指南中的对象 –&gt; 批量操作获取数据：1234567var query = new AV.Query('Song');//对应数据库中的Class名称query.find().then(function(datas) &#123; console.log(datas);//获取全部数据 datas.forEach(function(value) &#123; console.log(value); //遍历数据 &#125;);&#125;); 更新数据打开文档 –&gt; 对象 –&gt; 更新对象 123456// 第一个参数是 className，第二个参数是 objectIdvar todo = AV.Object.createWithoutData('Todo', '5745557f71cfe40068c6abe0');// 修改属性todo.set('content', '每周工程师会议，本周改为周三下午3点半。');// 保存到云端todo.save(); 通过id获取某个数据1234567var query = new AV.Query('Todo'); query.get('57328ca079bc44005c2472d0').then(function (todo) &#123; // 成功获得实例 // todo 就是 id 为 57328ca079bc44005c2472d0 的 Todo 对象实例 &#125;, function (error) &#123; // 异常处理 &#125;); 用七牛云存储存文件利用七牛云存储保存静态文件(图片、mp3、视频、js文件、css文件) 创建存储空间：打开七牛 –&gt; 管理控制台 –&gt; 对象存储 –&gt; 新建存储空间 –&gt; 存储空间名称:cloud_music –&gt; 如果超过免费访问量时，就将访问控制改成“私有空间” –&gt; 确定创建 点击SDK（软件开发套件）&amp;工具 –&gt; javascript SDK 用catbox存储文件 用catbox存储文件 利用form表单的post实现跨域 form的traget=xxx指向页面中的iframe[name=xxx]，从而实现页面不跳转 通过查询参数获取歌曲]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>教程</tag>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿锤子3Dbanner]]></title>
    <url>%2F2018%2F04%2F17%2F%E4%BB%BF%E9%94%A4%E5%AD%903Dbanner%2F</url>
    <content type="text"><![CDATA[See the Pen 3D Banner by qingjin (@mqhe2007) on CodePen. 本文转载自：锤子官网3D翻转特效banner插件 预览效果 html页面代码1234567891011121314&lt;div class="container"&gt; //外层容器名 &lt;div class="banner"&gt;Hello&lt;/div&gt; //内层banner名&lt;/div&gt; &lt;script type="text/javascript"&gt; // 调用插件函数，传入参数实现效果 3dbanner(&#123; container:".container", banner:".banner", initDeg: 10, url: "../images/img1.jpg", con_height: 400 &#125;); &lt;/script&gt; 引入js插件使用说明12345678910111213141516// 该插件依赖于jquery// 使用者需要在页面中书写这样的标签// &lt;div class=""&gt;// &lt;div class=""&gt;&lt;/div&gt;// &lt;/div&gt;// 引入该插件后会得到一个3dBanner方法，可以全局调用// 方法的参数data 是一个对象// 下面是参数的说明// &#123;// container: 容器盒子的类名 字符串// banner： 展示banner盒子的类名 字符串// initDeg: 最大旋转角度 数值// url: banner背景图路径 字符串// con_height: 容器盒子的高度 数值 // &#125; js插件核心代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758(function(win)&#123; function fnBanner(data)&#123; var con_height=data.con_height || 400; var ban_height=con_height*0.7; var con_padding=con_height*0.15; $(data.banner).css(&#123; height:ban_height+"px", width:"80%", margin:"0 auto", transition:"transform 0.1s" &#125;).css("background","url("+data.url+") no-repeat center").css( "background-size","contain").css("box-shadow","0 0 15px rgba(0,0,0,0.3)") $(data.container).css(&#123;height:con_height+"px", padding:con_padding+"px 0", width:"100%", background:"white", border:"1px solid gray", perspective:"1000px" &#125;).css("box-sizing","border-box") $(data.container).on("mousemove",function(e)&#123; var offset=$(data.container).offset(); var x=e.pageX-offset.left; var y=e.pageY-offset.top; var centerX=$(data.container).outerWidth()/2; var centerY=$(data.container).outerHeight()/2; var distanceX=x-centerX; var distanceY=y-centerY; var perX=distanceX/centerX; var perY=distanceY/centerY; var initDeg=data.initDeg || 10; $(data.banner).css(&#123; transform:'rotateX('+initDeg*-perY+'deg) rotateY('+initDeg*perX+'deg)' &#125;) &#125;) $(data.container).on("mouseleave",function()&#123; $(data.banner).css(&#123; transform:'' &#125;) &#125;) console.log("ok"); &#125; win.banner3d=fnBanner;&#125;)(window);]]></content>
      <categories>
        <category>效果及美化</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 如何写简历]]></title>
    <url>%2F2018%2F04%2F16%2F%E5%A6%82%E4%BD%95%E5%86%99%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[简历里应该有哪些重要内容如何做出精美的简历如何投递简历https://www.zhihu.com/question/23150301 写简历简历的目的是展示自己会什么技能、有多么的牛叉 基本信息 姓名，年龄，性别，目标职位(写在pdf文件名里，比如stage-应聘前端工程师-2018)、期望薪资：税前月薪10k~12k，特别喜欢的公司可例外、学校 联系方式：手机(不要写在网上，只写在pdf里)、邮箱、QQ、微信 把工作经验 改成 前端经验，表示你学习前端的时间 技能描述【按照投递公司的需求对技能排序】了解 -&gt; 掌握 –&gt; 熟悉 –&gt; 精通 大多数简历上都会写「熟练掌握 HTML\CSS\JavaScript…」然而这些类同的太多了。只说自己掌握什么、熟悉什么但不提自己用它们做了些啥成果。最好能写上对一些特定领域或者常见技术的掌握，比如说： 能够编写语义化的HTML文档 熟悉ES5/ES6，对原型、闭包、继承等有自己的理解 熟悉CSS3，掌握flex布局和css3动画的用法 掌握Vue.js的用法，并在github上有相关开源项目 这样可以在面试中掌握主动权，反客为主。 小程序制作可以独立进行小程序开发，熟悉AAAA、BBB、CCCC相关API或组件的使用。 Vue【将别人博客文章里经常提到的技术关键字提炼出来】熟悉 Vue 常用功能，如组件、Vue-Router、双向绑定等。 jQuery熟悉 jQuery 的常用 API，能使用 jQuery 制作网站、轮播、Tab 组件等。 HTML 5 &amp; CSS 3能独立制作精美网页，掌握 CSS 3 动画、过渡效果、响应式等常用技术。 移动端页面会使用 REM、vw/vh、FastClick 等技术制作适配手机设备的页面。 前端框架理解 MVC、MVVM 等思想，可以熟练使用相关的库，如 Vue、React ES6会使用ES6的let、const、解构赋值、箭头函数 JS熟悉js，对闭包、原型、原型链有一定的了解。 项目展示数量：6~8个，给方方看，让他删选。一定要配预览截图项目种类： 手机端项目 框架（Vue、React） CSS 3（皮卡丘） 原生 JS、jQuery（网易云音乐）:表示即使没有框架也能做项目 Node.js 命令行 小程序、React、echarts.js 项目只要好看，就是好项目。只要不好看就会扣分。给面试官看的东西，不要有明显的缺点。如果是在线网页，网页里的图片大小全部都不能超过 300kb 项目的写法：列出技术栈(知识点)、介绍背景、项目上线后的收益、后续的优化点 画板 给源码链接 预览链接（手机预览给二维码 https://cli.im） 关键词：原生 JavaScript、Canvas、响应式、jQuery、Vue 描述【用3句话:①通过xx技术实现了yyy功能。②由自己独立开发③用到了VUE-Router、Webpack、第三方库(比如swiper、axios)等】：该项目使用原生JS实现，主要调用 Canvas API，实现了划线、调色、橡皮擦、保存等功能。完全由我独立开发。用 XXX实现了 XXX 功能，用 XXX 实现了 XXX 功能。 简历生成器 源码链接 预览链接 关键词：Vue、原生 JS、Vue-Router、响应式、webpack、SASS、Babel、vue-cli 描述：该项目使用 Vue - 实现了一个可编辑简历的工具，该工具可以在线修改简历、分享简历、换主题等。这是我通过两周的学习，实现的第一个 Vue 项目，目前已经发布上线。我用 Vue-Router 实现了路由功能，使用 webpack 打包代码…… 网易云音乐 主要使用jQuery实现基本功能，并根据MVC思想对代码进行封装，主要有xxx功能、xxx功能和xxx功能 教育经历本科，xxx学士学位。【也可以写到基本信息里】 工作经历经历如果跟编程无关，就简单描述，比如在机械相关行业做过1年，最后加一句自学前端半年。经历跟前端有关，就说技术名称，如 Java、Linux命令行、HTTP，自学前端半年。 在工作经历中，必须提到业绩/给公司带来哪些收益，攻克了哪些技术难题，用了什么新的想法来解决遗留问题 链接：博客链接、GitHub链接 博客：至少有8篇 GitHub：要有点绿再给面试官看 你翻译的文章链接 你在 MDN 上贡献的编辑 其他 得奖 英语四六级 计算等级考试 其他可能有两点的东西 投递简历直接私信内部人员是最有效的方法！！！！ 社交网站，比如微博搜「前端招聘」，也可以用推特搜，找到内部人员的社交账号，私信他简历 拉勾、boss直聘、脉脉、大街网里起薪低于9k的你都可以尝试。 BOSS直聘，如果没有技术面试直接录取，就别去，可能是传销。 智联招聘、前程无忧、大街网、猎聘网等基本都是外包。 去搜公司的官网，在官网找「加入我们」「招聘」字样 v2ex，可能被喷 从培训班出来之后找工作的经历，教会了我这五件事 一个炫酷的简历模板 面试词典：什么叫精通？什么叫熟悉？什么叫了解？ 平时你从哪里获取前端知识？ 如果中国前端已经一半海水了，那么 Java、iOS 和安卓就…… HR的心态假想面试官刚吃完早饭，10分钟后去开会，现在要看10份简历，你的简历是否能脱颖而出，是否有亮点，没有亮点是否有美图。 把所有学过的东西随意组合（不要自己设计），让自己的简历跟同学的不一样。 美化简历，添加效果Demo 和项目的区别，一言以蔽之，那就是「是否好看！」。如果一个 Demo，代码漂亮、配图高大上、字体选择合理，给人一种走心的感觉，那么它就是一个可以放到简历上的项目。如果一个项目，配色惨不忍睹、排版错乱、错字连篇，那么做得再复杂，也给人是一种 Demo 的感觉。 搜索关键词：js amazing effects如果要搜库，就在后面加上关键词 lib前端在线简历能用到的炫酷UI库 简历应该体现出以下几点简历是敲门砖简历要根据招聘网站上的技能要求来写比如你想去百度地图web前端，那么要在简历里提到你研究过地图定位，了解HTML Genolocation定位接口 简历是反客为主的菜单简历是给面试官用来提问的【菜单】。面试官会根据你简历上提到的技能、项目、经历来进行提问，所以这是反客为主的好手段。 必须将简历中提到的技能和项目做好知识点梳理，预想面试官可能会问的问题，并准备好应答策略。 应付面试官介绍一下自己在介绍中铺陈自己的技术特长、优势、做的项目，让面试官了解你与众不同的地方和优势，并引导面试官来问自己准备好了的问题： 你好，我叫xxx，今年24岁，毕业于xxx大学。最开始通过广告过滤插件了解到前端，让我对web前端的开发工作越来越感兴趣。我通过看网上的在线视频以及技术博客【阮一峰】和前端社区，目前自学前端半年。我用vue做了4个项目………其中几个项目正在用Less重写……….目前正在学习node.js 说半句留半句：说话说一半，另外一半引导面试官提问题： 我平常喜欢逛各种技术社区（话说一半，引导面试官问你：那你平时都去哪些技术社区） 没有工作经验/说说你的缺点是的，我没有相关工作经验/非计算机专业出身，因此我写了很多项目来弥补经验上的不足。 平时是如何学习前端开发的?介绍做的项目介绍背景做这个项目的原因是什么？不要一上来就说结论性的内容。结论性内容：我们的项目采用了Vue来做框架【这样介绍不好】项目背景：之前这个项目是用jQuery做的，现在已经过时了，所以我们决定用Vue进行重构【这样介绍就比较好】 承担角色自己在项目中负责哪些内容，要求把细节和技术方案说清楚 最终的结果项目经过多久上线，上线后的数据如何，是否达到预期，后期是否带来新的问题，又是如何补救的？ 总结反思 收获有哪些？ 哪里感觉做的不足，还可以如何改进，是否有更好的解决方案 是否具有可迁移性：比如这个项目中的代码片段或者解决方案，可以迁移到别的项目中直接使用 项目中遇到过最难的技术问题是什么？这种问题讲究【一波三折】https://www.zhihu.com/question/35323603/answer/338796153 面试官问了你不会的问题怎么办？https://www.zhihu.com/question/266017827 第一步，重复一遍你理解的问题给面试官听，确认自己理解没错。【这个问题是在问异步操作吗？】第二步，让面试官指点一下，给点提示，然后尝试着说一下自己的看法，哪怕不懂，也要尝试一下。【async/await是为了让异步代码写的更优雅】第三步，不要浪费太多时间，告诉面试官自己不会【但要表现自己主动好学】，然后引导面试官转向另一个你会的问题。【具体的用法我没写过，我一般都使用Promise来写异步代码的，等我回去后立马去MDN上补充async/await这一方面的知识】 如何看待加班 加班就像同学问你借钱，救急不救穷【这一类加班有一个特点，就是能够预期到加班何时结束。比如年底赶进度、项目急着上线、项目临时有变更等，这些都能预期到何时能结束。这一类的加班我可以接收】 要看是由于我自身能力不足导致的加班，还是公司制度导致的加班，如果是我的能力不足，导致进度缓慢，我会主动加班的 你有什么要问面试官的？ 你们前端团队有多少人 主要技术栈 公司最近负责的项目 我主要负责做哪些事情 职业规划/未来3~5年的规划 半年让leader放心，能把项目又快又好的完成【让自己更好】 输出组件给组员用，让他们的效率变快【让他人更好】 心态上以leader的角度思考，拿到一个需求后，思考这个需求的可行性、 有没有更好的解决方案，不再先想如何写代码，而是先思考如何高效地完成这个需求【让团队更好】 三年内可以带新人 工资询问HR公司的工资构成：五险一金(是按照全额缴，还是最低标准缴？) + 年终奖 + 餐补 + 季度奖 + 项目提成试用期工资怎么算(按80%的工资？？)]]></content>
      <categories>
        <category>简历</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios的使用教程]]></title>
    <url>%2F2018%2F04%2F14%2Faxios%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[axios中文文档axios发送GET、POST请求axios拦截器的使用 安装npm i axios -S 用axios代替ajaxAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。axios中文文档 配置默认值 配置后端host 1axios.defaults.baseURL = 'https://api.example.com'; 这样，url就不需要写成https://api.example.com/user，只需要写成/user即可 配置withCredentials 1axios.defaults.withCredentials = true; 表示跨域请求时带上凭证 配置POST请求格式1axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8'; 基础用法1234567891011121314151617181920212223242526272829303132// 发送 GET 请求axios(&#123; method: 'get', url: '/user', params: &#123; //只有GET是用params发送参数，会显示在地址栏 ID: 12345, &#125;&#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);;// 发送 POST 请求【params用于GET时发送参数，会显示在地址栏；除此以外的用data发送参数，显示在开发者工具的Form Data里】axios(&#123; method: 'post', url: '/user', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);; 执行GET请求123456789101112131415161718192021// 为给定 ID 的 user 创建请求axios.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 可选地，上面的请求可以这样做axios.get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;) .then(response =&gt; &#123; console.log(response); &#125;) .catch(error =&gt; &#123; console.log(error); &#125;); 带查询参数的GET请求1234567891011axios.get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;) .then(res =&gt; &#123; console.log(res); &#125;) .catch(error =&gt; &#123; console.log(error); &#125;); 执行POST请求GET请求可以直接/user?ID=12345，数据会显示在地址栏；POST请求为了安全，不能直接在url后面接数据 在axios中的post请求要非常注意两个地方： 要设置合适的请求头，一般采用x-www-form-urlencoded即可 发送的数据要用qs序列化，因为axios默认的格式是Request Payload(打开控制台的Network -&gt; Headers)。 12345678910111213141516171819import axios from 'axios';import qs from 'qs';axios.post('/user', qs.stringify(&#123; firstName: 'Fred', lastName: 'Flintstone' &#125;), &#123; headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' &#125; &#125; ).then((&#123;data&#125;) =&gt; &#123; console.log(data); &#125;) .catch(error =&gt; &#123; console.log(error); &#125;); 此时，打开Network -&gt; Headers,可以看到数据在Form Data中了。 拦截响应，返回自定义假数据123456789101112131415161718192021// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 let &#123;config:&#123;url,method,data&#125;&#125; = response; //↑ 分解成let url = response.config.url; if (url === '/book/1' &amp;&amp; method === 'get') &#123; response.data = &#123; name: stage, &#125; &#125; else if (url === '/books/1' &amp;&amp; method === 'put') &#123; data = JSON.parse(data) Object.assign(book, data) response.data = book &#125; return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); 更多axios配置axios(config)123456789101112131415161718axios(&#123; baseURL: 'https://some-domain.com/api', url: '/user', method: 'get', // 默认是 get // params 只有GET时能用，参数会显示在地址栏 params: &#123; ID: 12345 &#125;, // GET以外的方法，用data传送参数，会显示在开发者工具的Form Data里 data: &#123; firstName: 'Fred' &#125;, headers: &#123; Content-Type:'application/x-www-form-urlencoded; charset=UTF-8' &#125;, //跨域时，把cookie传给第三方服务器 withCredentials: true&#125;) 将axios添加到vue的prototype上12345import axios from 'axios';Vue.prototype.$axios = axios;//然后就可以通过this.$axios来使用axios//这样就不需要每个文件内都import axios了 vue-jsonpnpm i vue-jsonp 使用this.$jsonp(url, dataObj, timeout) 12345678910111213141516import Vue from 'vue'import VueJsonp from 'vue-jsonp'Vue.use(VueJsonp) // Use it in Vue Component. methods: &#123; getData() &#123; this.$jsonp('https://api.douban.com/data',&#123; name: 'stage', age: 24 &#125;) .then(res =&gt; &#123; // Success. &#125;) .catch(err =&gt; &#123; // Failed. &#125;) &#125; &#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 webpack入门]]></title>
    <url>%2F2018%2F04%2F13%2Fwebpack%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前端工程化：自动化(用命令行自动转译)、模块化、性能优化模块自动化构建工具：webpack的使用postcss：自动添加浏览器私有前缀sass：sass转cssless：less转cssbabel：es6转es5extract-text-webpack-plugin：分离出独立的css文件webpack4参考教材webpack：从入门到真实项目配置关于 webpack 的面试题有哪些？简书：webpack4入门 前端工程化大公司里怎样开发和部署前端代码? 个人：写html、css、js 大公司：工程化(自动化、模块化、性能优化) 自动化(命令行自动实时转译) 用Less命令行将less自动转成css 用Bable命令行将es6语法自动转成es5 用Autoprefixer命令行将css3自动加上浏览器私有前缀 webpack模块自动化构建工具什么是模块？在 webpack 下，所有类型的文件都可以是模块，包括 CSS、图片、JSON，等等。 前端工程化遇到的问题： Less、Babel、Autoprefixer等必须全部开着命令行监控文件的变化，才能实时自动转译。 前端发展很快，html–&gt;pug–&gt;slim, css–&gt;less–&gt;sass–&gt;scss–&gt;stylus, js–&gt;es6–&gt;Typescript 能不能不要开那么多命令行窗口呢？并且根据文件后缀名自动转成标准的前端文件呢？用模块自动化构建工具(打包工具)！ 模块自动化构建工具(打包工具)发展史Grunt –&gt; Gulp –&gt; Webpack –&gt; Parcel 项目目录结构 .bin:binary,可执行的 dist:distributable,可分发的 12345678910111213|||-- src //source，未经转译过的源文件| |-- imgs //图片放这里| |-- js //原始js代码放这里| |-- style //原始样式代码(.less,.scss,.sass)放这里||-- dist //distribution，转译后的代码| |-- index.html||-- node_modules //通过npm下载的第三方库||-- vendors //自己找的第三方库 使用步骤 退出vim：esc +：+ w + q $ node_modules/.bin/webpack –watch //监听变动并自动打包 $ node_modules/.bin/webpack -p //压缩混淆脚本，这个非常非常重要！ $ npm list -g –depth=0 查看所有全局安装 先全局安装[不推荐全局安装 webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中，可能会导致构建失败。]npm i webpack webpack-cli -g 进行全局安装【如果出现npm install出现”Unexpected end of JSON input while parsing near”错误,执行npm cache clean --force】 在项目目录下打开命令行，npm init -y初始化模块，生成package.json npm i webpack webpack-cli -D（-D表示--save-dev），安装webpack到当前目录(局部安装) webpack装在了node_modules文件夹下一个.bin文件夹里(binary:可执行的) 创建./src/index.js 打开package.json并添加 1234"scripts": &#123; "dev": "webpack --mode development", "build": "webpack --mode production" &#125; 这样，在执行npm run dev时吐出未压缩的包，执行npm run build时吐出压缩后的包 webpack4参考教材：https://blog.zfanw.com/webpack-tutorial/ 默认入口和出口 创建文件./src/index.js 从webpack 4开始，不需要定义入口点：它会将./src/index.js作为默认值！【可以创建webpack.config.js进行修改】 打开package.json并添加一个构建脚本：”scripts”: { “build”: “webpack”}保存并关闭文件 执行npm run build，默认在 ./dist/main.js中获得该软件包。webpack4会查找./src/index.js作为默认入口点。 而且，它默认会在./dist/main.js中吐出这个包。 创建./dist/index.html,并引入main.js 配置入口和出口如果不想要默认配置，可以自定义配置 新建webpack.config.js（这个配置文件可以拷贝官方文档） 1234567module.exports = &#123; entry: './src/a.js' //入口 a.js可以简写成a output: &#123; //出口 path: path.resolve(__dirname, 'dist'), //__dirname表示当前目录,后面的参数表示文件夹名 filename: 'bundle.js' &#125;&#125;; 这样，我们只需要执行npm run build，就可以将src下的a.js打包到dist下的bundle.js(压缩模式) 1234567891011多入口，多出口配置module.exports = &#123; entry: &#123; home: './src/home.js', //home.js可以简写成home signup: './src/signup.js' &#125;, output: &#123; //出口 path: path.resolve(__dirname, 'dist'), //__dirname表示当前目录,后面的参数表示文件夹名 filename: '[name].bundle.js' //生成home.bundle.js和signup.bundle.js &#125;&#125;; 生产模式production和开发模式development生产模式build：压缩，体积小开发模式dev：未压缩，体积大 事实上，如果你注意npm run build的输出，你会看到一个很好的警告： The ‘mode’ option has not been set. Set ‘mode’ option to ‘development’ or ‘production’ to enable defaults for this environment.（“mode”选项尚未设置。 将“mode”选项设置为“development”或“production”以启用此环境的默认值。） 打开package.json并添加1234"scripts": &#123; "dev": "webpack --mode development", "build": "webpack --mode production" &#125; 这样，在执行npm run dev时吐出未压缩的包，执行npm run build时吐出压缩后的包 配置环境process.env.WEBPACK_MODE慕课网笔记：小记webpack4.x升级过程 在webpack.config.json填入set WEBPACK_ENV1"dev": "set WEBPACK_MODE=development &amp;&amp; webpack --mode development 然后在webpack.config.js中就能获取到1console.log('process.WEBPACK_MODE : '+process.env.WEBPACK_MODE) 获取npm run xxxnpm 提供一个npm_lifecycle_event变量，返回当前正在运行的script名称，比如dev、build、watch等 在webpack.config.json填入12var currentTarget = process.env.npm_lifecycle_event;console.log('npm run : '+currentTarget) 文件实时更新【会自动更新mian.js】打开package.json并添加123"scripts": &#123; "watch": "webpack --mode development --watch" &#125; 这样，执行npm run watch就可以实时监控文件，一旦文件有变化就自动更新 自动刷新浏览器【更新的文件保存在缓存中】webpack-dev-server 为你提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)。安装：npm i webpack-dev-server -D打开package.json并添加123"scripts": &#123; "start": "webpack-dev-server --mode development --content-base ./dist --open",&#125; 这样，在执行npm start就会看到浏览器自动加载页面。 注意：你启动webpack-dev-server后，你在./dist/main.js中是看不到编译后的文件的,实时编译后的文件都保存到了浏览器内存当中。因此很多同学使用webpack-dev-server进行开发的时候都看不到编译后的文件【解决办法】多开一个命令行串口，用npm watch实时监控文件变动随时编译就行了。webpack-dev-server的端口怎么修改?【解决方法】用–port来制定参数，比如webpack-dev-server --port 8888 配置命令详解12345"scripts": &#123; "build": "webpack --profile --progress --colors --display-error-details", "dev": "webpack --display-modules --profile --progress --colors --display-error-details", "start": "webpack-dev-server --config" &#125; color 输出结果带彩色，比如：会用红色显示耗时较长的步骤 profile 输出性能数据，可以看到每一步的耗时 progress 输出当前编译的进度，以百分比的形式呈现 display-modules 默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块 display-error-details 输出详细的错误信息 webpack-dev-server 将会开启热更新 更多请参考官网 cli LOADER转译器Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件(ES6,less,sass,scss等)，就需要使用 loader 进行转换。 css相关loadersass-loader 把sass转成csscss-loader 会遍历 CSS 文件，然后找到 url() 表达式然后处理他们style-loader 把CSS 代码插入页面中的一个 style 标签中。 sass-loadernpm i -D css-loader style-loadernpm i -D sass-loader node-sassnpm i -D less less-loadernpm i -D extract-text-webpack-plugin@nextnpm i -D postcss-loader //添加前缀12345678910111213141516171819202122232425262728创建postcss.config.jsmodule.exports = &#123; plugins: &#123; 'postcss-import': &#123;&#125;, 'postcss-cssnext': &#123;&#125;, 'cssnano': &#123;&#125; //压缩css代码 &#125;&#125;``` 在index.js中将样式表引入`import ../css/style.scss`### babel-loadernpm i -D babel-core babel-preset-env babel-loader在webpack.config.json填入 ```javascriptmodule: &#123; rules: [&#123; test: /\.js$/, //以.js结尾的文件 exclude: /(node_modules|bower_components)/, //排除 use: &#123; loader: 'babel-loader', options: &#123; presets: ['env'] &#125; &#125; &#125;] &#125; babel-polyfill转换es6的apiBabel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。举例来说，ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill。 Babel默认不转码的API非常多，详细清单可以查看babel-plugin-transform-runtime模块的definitions.js文件。 12345678910安装：npm i babel-polyfill -S 然后需要时，在入口文件最顶部通过 import 将 polyfill 引入import "babel-polyfill";或者直接暴力在 webpack.config.js 中，将 babel-polyfill 加到你的 entry 数组中：module.exports = &#123; entry: ["babel-polyfill", "./app/js"]&#125;; 上面这种方法将整个polyfill引入，会导致文件过大！ core-js转换es6的api推荐手动引入core-js使用方法:1234567891011在入口文件的顶部引入import 'core-js/fn/object/assign';import 'core-js/fn/string/repeat';如何就可以在自己的js文件中用Object.assign、str.repeat了var data = &#123;a:1&#125;Object.assign(data,&#123;b:2,c:3&#125;);console.log(data);var x = 'h'.repeat(10);console.log(x); 参考内容： cnblog:babel不转换新API的解决办法 github:core-js的用法 github:core-js的definitions文件 babel中文官网：关于polyfill purifycss去除无用css安装：npm i -D purifycss-webpack purify-css 在webpack.config.js中配置1234567891011121314const glob = require("glob");const PurifyCSSPlugin = require("purifycss-webpack");//插件:用于生产模板和各项功能 plugins:[ //把CSS独立出来，不要打包到js文件中去里面写的就是独立出来后的路径 new extracTextPlugin("/css/index.css"), //去除无用css(必须配合extract-text-webpack-plugin这个插件) new PurifyCSSPlugin(&#123; paths:glob.sync(path.join(__dirname,"src/*.html")) &#125;) ] 常用指令用npx可以自动找到命令行工具所在位置，比如npx webpack --mode development --watch等同于./node_modules/.bin/webpack --mode development --watch这样就不需要安装到global全局也能使用，比如原本http-server要安装到全局，然后才能http-server -c-1 -o，现在可以不安装到全局，直接npx http-server -c-1 -o打开 npx webpack -v：查看webpack版本号 npm run dev 打包成不压缩的文件 npm run build 打包成压缩文件 npm run watch 启动watch监视，并实时打包成新文件 npm run start 打开本地服务器调试 导入导出modules导出12属性:module.exports.age=12;方法:module.exports.sayAge=function()&#123;&#125; 具体如下12345678910//login.js&#123; let userName="stage"; module.exports.userName=userName; module.exports.sayName=function()&#123; return userName; &#125;;&#125; 引入12import loadsh from 'lodash' // 从模块目录查找import a from './src/js/a.js' // 按相对路径查找【文件的后缀名可加可不加】 这里注意一下：模块查找和相对目录的查找的写法，模块查找是不需要”./“,直接写上模块名字，这里的模块一般是通过npm i下载到node_modules的模块。 具体如下1234&#123; import xxx from './src/js/login.js';//引用模块 alert(xxx.sayName());//使用 引用模块的方法&#125; 去除.map文件打包时不要map文件：12去config/index.js中改一个参数： productionSourceMap:false 发布到githut 将config -&gt; index.js 里build配置项里的assetsPublicPath修改成这样→assetsPublicPath: &#39;./&#39;, 关于-D和-Shttps://segmentfault.com/p/1210000009653830/read npm i xxx -D:模块名将被添加到 devDependencies 开发依赖,在我们开发的时候会用到的一些包，只是在开发环境中调试时需要用到的包 npm i xxx -S:模块名将被添加到 dependencies npm在下载模块时，默认-S，所以npm i xxx等同于npm i xxx -S 面试题http://ovenzeze.coding.me/]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>教程</tag>
        <tag>打包工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[console.log添加样式及图片]]></title>
    <url>%2F2018%2F04%2F13%2Fconsole-log%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F%E5%8F%8A%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[console.log在控制台打出css样式的文字及图片 console.log增强api谷歌开发者中心上面关于谷歌浏览器控制台console.log()的文档 Format Specifier %s Formats the value as a string. %d or %i Formats the value as an integer. %f Formats the value as a floating point value. %o Formats the value as an expandable DOM element (as in the Elements panel). %O Formats the value as an expandable JavaScript object. %c Formats the output string according to CSS styles you provide. 可以看到，通过占位符%c,可以对输出到console控制台的文字进行CSS控制。 格式如下： console.log(&quot;%c需要输出的信息 &quot;, &quot;css 代码&quot;); 输出3D TEXT1console.log("%c3D Text"," text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);font-size:5em") 彩色背景文字1console.log("%c彩色文字","background: rgba(252,234,187,1);background: -moz-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%,rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -webkit-gradient(left top, right top, color-stop(0%, rgba(252,234,187,1)), color-stop(12%, rgba(175,250,77,1)), color-stop(28%, rgba(0,247,49,1)), color-stop(39%, rgba(0,210,247,1)), color-stop(51%, rgba(0,189,247,1)), color-stop(64%, rgba(133,108,217,1)), color-stop(78%, rgba(177,0,247,1)), color-stop(87%, rgba(247,0,189,1)), color-stop(100%, rgba(245,22,52,1)));background: -webkit-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -o-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -ms-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: linear-gradient(to right, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#fceabb', endColorstr='#f51634', GradientType=1 );font-size:5em") 文字颜色1console.log('%c我是蓝色字','color:blue;font-size:24px'); 设置不同的css1console.log("%c 第一 %c 第二 %c 第三", "color:red","color:green","color:green") 在Chrome控制台输出图片1console.log("%c", "padding:50px 300px;line-height:120px;background:url('http://www.iconpng.com/png/tailwaggers_free/pug.png') no-repeat;"); 参考资料https://www.cnblogs.com/Wayou/p/chrome_dev_tool_style_console.html]]></content>
      <categories>
        <category>效果及美化</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>js</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端性能优化：HTTP缓存资源(文件)]]></title>
    <url>%2F2018%2F04%2F12%2Fhttp%E7%BC%93%E5%AD%98cachecontrol%2F</url>
    <content type="text"><![CDATA[如何加速网页访问(减少HTTP请求)？HTTP缓存！Cache-Control:max-age=30000ExpiresEtagLast-Modified菜鸟教程：HTTP 通过Cache-Control加快请求速度前端性能优化中,减少HTTP请求可以提高页面的响应速度后端对某个要传送的文件设置Cache-Control响应头,使其缓存30秒，然后发送给浏览器；浏览器在30秒内刷新，不会再次发送请求，而是直接从缓存中取得该文件。超过30秒后刷新，会向服务器发送请求。1response.setHeader('Cache-Control', 'max-age=30') 必须是相同的Request URL才能在过期前从缓存中取文件。通过更改Request URL的查询参数（比如http://a.b.com/main.js?v1），每次向服务器发送的请求就都不一样了，于是不会从缓存中取文件。 文件在后端有升级怎么办设置main.js缓存10年，这样每次请求main.js时都会从缓存中获取。如果中途main.js有升级，就将main.js的Request URL的查询参数改成main.js?v2，这样就可以获取最新的js文件，并且新文件缓存10年；如果再升级，就将main.js的Request URL的查询参数改成main.js?v3 chrome调试如果在chrome的开发者工具 –&gt; network 中选择disable cache，那么就不会从缓存中获取文件，而是向服务器发送请求 Expires从前人们用Expires缓存现在人们用Cache-Control缓存如果设置了Cache-Control响应头，那么Expires响应头就会被忽略 后端程序员通过Expires响应头，设置过期时间1response.setHeader('Expires', 'Thu, 19 Apr 2018 08:17:46 GMT') //GMT格式 Expires与Cache-Control的区别Expires设置具体的过期时间(绝对时间点)Cache-Control设置多长时间段后过期(相对时间段) 如果用户修改了本地的时间，那么Expires就会受到影响。比如Expires到2018年x月x日过期，用户将本地时间改成2019年x月x日，那么Expires就失效了。而Cache-Control是一个相对过期时间，所以不存在这个问题。 Etag/If-None-MatchEtag/If-None-Match要配合Cache-Control使用。当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。服务器收到请求后发现有头If-None-Match 则与被请求资源的Etag值进行比对，决定返回200或304。 Etag 服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）后端程序员通过Etag响应头，设置Etag值(唯一标识)1response.setHeader(&apos;Etag&apos;, &apos;xxxxxxxxx&apos;) 浏览器首次发送请求后，服务器会传给浏览器Etag查看响应头123456Response HeadersCache-Control:max-age=600Connection:keep-aliveContent-Length:0Etag:xxxxxxxxx If-None-Match 浏览器再次发送请求时，在Request Headers里的If-None-Match带上Etag值：123Request HeadersIf-None-Match:xxxxxxxxx 如果发送请求时带上的这个If-None-Match的值与服务端的Etag值一样，那么就返回304，且不下载资源 304304 Not Modified：未曾修改过后端返回304，则不下载响应体(文件) Etag与Cache-Control的区别Cache-Control设置资源有效期10年，那么只要这个资源的Request URL不变，则10年内后端都不会收到请求【直接不请求】服务器给浏览器种下Etag后，浏览器发送请求时会在请求头带上If-None-Match，服务器收到请求后，对比If-None-Match的值与服务器上的Etag值，如果一样，则返回304，不下载资源文件【有请求，但不下载】Cache-Control更好，因为Cache-Control直接不发送请求，提高了页面的响应速度 Last-Modified/If-Modified-SinceLast-Modified/If-Modified-Since要配合Cache-Control使用。 Last-Modified：标示这个响应资源的最后修改时间。服务器在响应请求时，告诉浏览器资源的最后修改时间。 If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向服务器请求时带上头 If-Modified-Since，表示请求时间。服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源最近有改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用本地缓存文件。 总结浏览器第一次请求： 浏览器再次请求时： 参考资料：浏览器缓存机制]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>http</tag>
        <tag>web前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步与回调]]></title>
    <url>%2F2018%2F04%2F11%2F%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%9B%9E%E8%B0%83%2F</url>
    <content type="text"><![CDATA[同步与异步的区别通过【回调】获得异步任务的结果输出结果的优先级：同步 =&gt; 异步 =&gt; 回调参考资料：方应杭：异步与回调 代码执行顺序同步优先、异步靠边、回调垫底12345console.log(1)setTimeout(function()&#123; console.log(2)&#125;,0)console.log(3) 上面代码的书写顺序是 1 -&gt; 2 -&gt; 3； 但是执行顺序是 1 -&gt; 3 -&gt; 2。 中间的 console.log(2) 就是异步执行的。 你现在知道了「代码的书写顺序和执行顺序居然可以不同！」 同步与异步的区别同步：你用饿了么点外卖，然后在楼下一直等外卖小哥，直到他把外卖送到异步：你用饿了么点外卖，然后去玩游戏，过一会外卖小哥打电话说外卖送到楼下了，你再下楼去取外卖。【其中，外卖小哥打电话通知你的这个行为称为“回调”】 同步：一定要等任务执行完了，得到结果，才执行下一个任务。123456function taskSync()&#123; return '同步任务的返回值'&#125;var result = taskSync() // 那么 result 就是同步任务的结果nextTask() // 然后执行下一个任务 异步：不等任务执行完，直接执行下一个任务。123456789function taskAsync()&#123; var result = setTimeout(function()&#123; console.log('异步任务的结果') &#125;, 3000) return result&#125;var result = taskAsync() // result 不是异步任务的结果，而是一个 timer idotherTask() // 立即执行其他任务，不等异步任务结束 我们拿到的 result 不是异步执行的结果，而是一个 timer id,那么要怎么拿到异步任务的结果呢？ 答案是用【回调】！ 回调将一个函数作为参数传递给另一个函数，作为参数的这个函数就是回调函数。 同步回调1234567891011var callback = function(arg3) &#123; console.log('cb:' + arg3) &#125;function fn(arg1, arg2, cb) &#123; var Total = arg1 + arg2; cb(Total); console.log('fn1:' + Total)&#125;fn(2, 2, callback) // 调用fn()函数，并传入2, 2, callback作为参数 上面的代码执行结果为：12cb:4fn1:4 不对啊！ 回调函数不是应该在主函数的最后执行吗？上面的例子是一个同步回调函数，函数的执行顺序依然自上而下顺序执行。那么什么是异步回调呢？ 异步回调在异步回调中，同步 =&gt; 异步 =&gt; 回调123456789101112function f2() &#123; console.log('f2 finished') &#125;function f1(cb) &#123; setTimeout(cb,1000) //用setTimeout()模拟耗时操作 console.log('f1 finished')&#125;f1(f2); //得到的结果是 f1 finished ，f2 finished 「回调」经常用于获取「异步任务」的结果:1234567891011function taskAsync(callback)&#123; var result = setTimeout(function()&#123; callback('异步任务的结果') &#125;, 3000) return result&#125;taskAsync(function(result)&#123; console.log(result) // 三秒钟后，这个 callback 函数会被执行&#125;)otherTask() // 立即执行其他任务，不等异步任务结束 回调函数的参数 将回调函数的参数作为与回调函数同等级的参数进行传递 回调函数的参数在调用回调函数内部创建]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储状态:cookie、session、localStorage、sessionStorage与登入注册]]></title>
    <url>%2F2018%2F04%2F10%2Fcookie%E4%B8%8E%E7%99%BB%E5%85%A5%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[参考书目：图解HTTP若愚：cookie、session、localStorage分别是什么？有什么作用？读图解http有感：认识HTTP—-Cookie和Session篇复习HTTP请求与响应cookie的相关知识通过cookie发送sessionIDlocalStorage与cookie的区别sessionStorage Cookie、Session、Cache-Control https://zh.wikipedia.org/wiki/Cookie https://zhuanlan.zhihu.com/p/22396872?refer=study-fe Session 维基百科：https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6) Cache-Control 注意！这是响应头，不是请求头！！ 复习HTTP的请求与响应chrome 发送Request请求 –&gt; server12345GET /xxx HTTP/1.1Content-Type:application/x-www-form-urlencoded;charset=UTF-8Content-Length:160回车换行name=stage&amp;age=24 server 发送Response响应 –&gt; chrome12345HTTP/1.1 200 OKContent-Type:text/html; charset=utf-8Content-Length:23570回车换行&lt;!DOCTYPE html&gt;&lt;html&gt;.....省略&lt;/html&gt; 登入注册功能用到的代码：https://github.com/FrankFang/sign-in-demo cookiecookie是存储在浏览器上的一小段数据，用来记录某些当页面关闭或者刷新后仍然需要记录的信息。 服务端通过Set-Cookie设置响应头发送给浏览器，告诉浏览器保存Cookie。response.setHeader(&#39;Set-Cookie&#39;,sign_in_email=${email}) 浏览器得到cookie后，以后每次向该服务器发送请求时都会自动带上cookie 服务器读取到浏览器发送过来的cookie后，对比服务器上的数据，就知道用户的信息(email)了 cookie的特点 cookie不安全，可以直接在浏览器里篡改。Session 可以解决这个问题，防止用户篡改 cookie默认在关闭浏览器后失效（可以人为设置过期时间） 大小在4kb以内 如何操作cookie阮一峰：cookie注意！每个cookie以分号+空格 隔开:name=stage; expires=Thu, 01 Jan 1970 00:00:00 GMTkey与value之间的等号不能有空格：name=stage不能写成name = stage 前端操作cookie 获取cookie：var x = document.cookie; 设置/添加cookie：document.cookie=&quot;username=stage&quot;;【如果您设置了另一个 cookie，旧的 cookie 不会被覆盖。 】 修改：创建同名Cookie，覆盖原来的Cookie 设置过期时间(以 UTC 或 GMT 时间）：document.cookie=&quot;username=stage; expires=Thu, 18 Dec 2018 12:00:00 GMT&quot;;则username这一条数据将在该时间过期 expires属性的值为 GMT 格式，表示具体过期的时间点 max-age属性的值为秒数，表示xx秒后过期 如果同时指定了expires和max-age，那么max-age的值将优先生效。 删除指定cookie：document.cookie = &quot;username=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;; 后端操作cookie 设置过期时间：response.setHeader(&#39;Set-Cookie&#39;, &#39;name=stage; Expires=Thu, 18 Dec 2018 12:00:00 GMT&#39;); Expires属性指定一个具体的到期时间，到了指定时间以后，浏览器就不再保留这个 Cookie。 Max-Age属性指定从现在开始 Cookie 存在的秒数，比如60 60 24 * 365（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。 Expires根据用户电脑时间，如果用户电脑时间不对，会影响cookie的过期时间，而Max-Age是一个相对时间，因此不受用户电脑时间的影响。 如果同时指定了Expires和Max-Age，那么Max-Age的值将优先生效。 删除cookie，只需要设置为以前的时间：response.setHeader(&#39;Set-Cookie&#39;, &#39;name=stage; Expires=Thu, 01 Jan 1970 00:00:00 GMT&#39;) Sessioncookie存在的问题：用户可以随意篡改 Cookiesession很安全，用户无法篡改session的有效期采用发呆时间，默认是用户不操作超过20分钟（可以人为修改发呆时间），服务器会把长时间没有活动的Session从服务器内存中清除。 Cookie与Session当一个用户打开淘宝登录后，刷新浏览器仍然展示登录状态。服务器如何分辨这次发起请求的用户是刚才登录过的用户呢？ Cookie 服务器通过设置 Set-Cookie 响应头给浏览器一串字符串(种下cookie) 浏览器每次访问相同域名的网页时，必须带上这段字符串 浏览器要在一段时间内保存这个Cookie Cookie 默认在用户关闭页面后就失效，后台代码可以任意设置 Cookie 的过期时间 大小大概在 4kb 以内 没有Cookie信息状态下的请求 第2次以后（存有Cookie信息状态）的请求 HTTP 请求报文和响应报文的内容如下①请求报文（没有Cookie 信息的状态）123GET /reader/ HTTP/1.1Host: hackr.jp*首部字段内没有Cookie的相关信息 ②响应报文（服务器端生成Cookie 信息）12345HTTP/1.1 200 Set-Cookie: name=stage; path=/; expires=Wed,10-Oct-12 07:12:20 GMTDate: Thu, 12 Jul 2012 07:12:20 GMTServer: ApacheContent-Type: text/plain; charset=UTF-8 ③请求报文（自动带上Cookie信息发送给服务器）123GET /image/ HTTP/1.1Host: hackr.jpCookie: name=stage Session 服务器通过 Cookie 发送给浏览器一个 SessionID（随机数) 服务器有一块内存（哈希表）保存了所有 session 每次浏览器访问服务器时自动带上SessionID 服务器通过读取SessionID，我们可以得到对应用户的隐私信息，如 id、email 这块内存（哈希表）就是服务器上的所有 session 12345服务端：var sessions=&#123;&#125;;var sessionID = Math.random()*100000; //随机数sessions[sessionId] = &#123;sign_in_email: email&#125;;response.setHeader('Set-Cookie', `sessionID=$&#123;sessionID&#125;`) 由于SessionID是随机数，无法知道另一个用户的SessionID，因此无法篡改。 cookie与session的区别 session是基于cookie实现的。 cookie是session的基石。 cookie不安全，可以直接在浏览器里篡改。 session通过cookie给浏览器发送sessionID(随机数)，因此用户无法篡改 cookie默认在关闭浏览器后失效（可以人为设置过期时间） session的有效期采用发呆时间，默认是用户不操作超过20分钟（可以人为修改有效期），服务器会把长时间没有活动的Session从服务器内存中清除。 cookie和session不归前端管，交给后端去设置和读取！ localStoragecookie和session在浏览器每次发送请求时都会被自动带上，如果cookie或session太多太大，对传输效率会有影响。 localStorage是HTML5提供的Web 存储 session是存储在服务器上的哈希表(浏览数据) localStorage是存储在本地的哈希表(浏览数据) 特点 LocalStorage 跟 HTTP 无关，浏览器发送请求时不会带上 LocalStorage 的值 只有相同域名的页面才能互相读取 LocalStorage（没有同源那么严格） 每个域名 localStorage 最大存储量为 5Mb 左右（每个浏览器不一样） 常用场景：记录有没有alert过用户，记录用户有没有点过赞（记录不敏感的信息，不能记录密码） LocalStorage 永久存储，除非用户清理缓存(chrome -&gt; 清除浏览数据 -&gt; 高级 -&gt; Cookie及其他网站数据) localStorage相关api 存值：localStorage.setItem(&#39;key&#39;,&#39;value&#39;); 或者 localStorage.key = &#39;value&#39;; 只能存字符串，如果是对象，要通过Json.stringify(obj)转成字符串123456789var x = localStorage;x.setItem('name','stage');等价于 localStorage.name = 'stage'可以用中文：x.setItem('姓名','stage');x.setItem('obj',JSON.stringify(&#123;'name':'stage'&#125;))查看所有值：console.log(x) 取值：localStorage.getItem(&#39;key&#39;) 12x.getItem('name');x.getItem('obj'); 删除单个数据：localStorage.removeItem(&#39;key&#39;); 清空：localStorage.clear(); 得到某个索引的key：localStorage.key(index); localStorage与cookie的区别cookie参与网络传输。每次浏览器发送请求时， Request headers 中都会带上cookie。localStorage是本地存储，不参与网络传输。 cookie最大4kblocalStorage最大5mb sessionStoragesessionStorage的特点与localStorage的前3个特点一样与localStorage的区别在于，sessionStorage在用户关闭页面后（会话结束）就失效。 sessionStorage的api与localStorage的用法一样1234567891011var x = sessionStorage;存值：x.setItem('name','stage');等价于x.name = 'stage';取值：x.getItem('name');查看所有值：console.log(x)删除单个数据：x.removeItem('name');清空：x.clear(); sessionStorage与localStorage的区别LocalStorage 永久存储，除非用户清理缓存sessionStorage在用户关闭页面时（会话结束）就失效。 关于有效期cookie在关闭浏览器后失效(可以人为修改过期时间)session采用发呆时间，服务器会把长时间没有活动的Session从服务器内存中清除，此时Session便失效。默认用户超过20分钟不操作就失效。(可以人为修改发呆时间)sessionStorage在关闭当前页面时失效localStorage永久存储，除非人为清空缓存]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
        <tag>http</tag>
        <tag>请求与响应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 JS高级基础知识考试]]></title>
    <url>%2F2018%2F04%2F07%2FJS%E9%AB%98%E7%BA%A7%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[原型链new命令的作用，以及new命令中的thisjson和javascriptMVC的概念ES5实现类Promise的使用 填空题123456789101112131415161718var object = &#123;&#125;object.__proto__ === ????填空1???? // 为 truevar fn = function()&#123;&#125;fn.__proto__ === ????填空2???? // 为 truefn.__proto__.__proto__ === ????填空3???? // 为 truevar array = []array.__proto__ === ????填空4???? // 为 truearray.__proto__.__proto__ === ????填空5???? // 为 trueFunction.__proto__ === ????填空6???? // 为 trueArray.__proto__ === ????填空7???? // 为 trueObject.__proto__ === ????填空8???? // 为 truetrue.__proto__ === ????填空9???? // 为 trueFunction.prototype.__proto__ === ????填空10???? // 为 true 答： Object.prototype Function.prototype Object.prototype Array.prototype Object.prototype Function.prototype Function.prototype Function.prototype Boolean.prototype Object.prototype 构造函数，new命令中的this1234function fn()&#123; console.log(this)&#125;new fn() new fn() 会执行 fn，并打印出 this，请问这个 this 有哪些属性？这个 this 的原型有哪些属性？答：这里的this指向fn的实例对象，此处是一个空对象，因此这个this没有什么属性。this 的原型有constructor 属性，以及从Object.prototype继承的属性 知识点 在构造函数或者构造函数原型对象中this指向构造函数的实例所谓”构造函数”，就是专门用来生成实例对象的函数。new命令的作用，就是执行构造函数，返回一个实例对象。new命令做了以下几件事： 创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。(this指向这个自动生成的空对象) 然后执行构造函数内部的代码。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。 12345678910111213141516//不使用new指向windowfunction Person (name) &#123; console.log(this); // window this.name = name;&#125;Person('inwe');//使用newfunction Person (name) &#123; this.name = name; console.log(this); // xxx self = this; &#125; var xxx = new Person('iwen'); console.log(self === xxx) //true//这里new改变了this指向，将this由window指向Person的实例对象xxx new 操作为了记录「空对象是由哪个构造函数创建的」，所以会自动给「构造函数.prototype」加了一个 constructor 属性： constructor 属性返回对象的构造函数。 返回值是函数的引用(比如数组 constructor 属性返回 function Array() { [native code] })，而不是函数名： 1234567function P()&#123; console.log(this);&#125;var x = new P();P.prototype.constructor === P // truex.constructor === P // truep.constructor === P.prototype.constructor // true constructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。12var x = new Array(1,2,3);x.constructor === Array // true Object的共有属性所有对象都继承了Object.prototype的属性。这就是所有对象都有valueOf和toString方法的原因，因为这是从Object.prototype继承的。 JSON 和 JavaScript JSON 和 JavaScript 是什么关系？JSON 和 JavaScript 的区别有哪些？答：关系： JS 是一门语言，JSON 是另一门语言 json这门语言是道格拉斯抄袭js的语言 JSON 使用 Javascript语法来描述数据对象 道格拉斯还写了本《javascript语言精粹》，俗称蝴蝶书，来吐槽js中垃圾的地方 区别：json里的字符串必须用双引号，不能用单引号！json没有undefined和function| js语法 | json语法 || :—-: |:———:|| 123 | 123 || ‘stage’ | “stage” || true | true || [‘a’, ‘b’] | [“a”, “b”] || {name: ‘stage’} | {“name”: “stage”} || null | null || undefined | json没有undefined || function fn(){} | json没有function | 此外，JSON有2个api，分别是JSON.parse(str)和JSON.stringify(obj) 前端 MVC前端 MVC 是什么？请用代码大概说明 MVC 三个对象分别有哪些重要属性和方法。(不用写详细代码，只需要说明重要属性的名称即可)MVC是一种设计模式 Model（模型）- 通常模型对象负责在数据库中存取数据。 View（视图） - 通常视图是将模型里的数据可视化。 Controller（控制器） - 从视图读取数据，控制用户输入，并向模型发送数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var model = &#123; fetch: function()&#123; /* 获取服务端数据 */ &#125; save: function(data)&#123; /* 将数据保存到服务端 */ &#125;&#125;var view = document.querySelector('xxx');var controller = &#123; view: null, model: null; init: function(view,model)&#123; this.view = view; this.model = model; this.form = view.querySelector('form'); this.getData(); this.saveData(); this.bindEvent(); &#125;, getData: function()&#123; this.model.fetch().then(function()&#123;&#125;); &#125;, saveData: function()&#123; this.model.save(data).then(function()&#123;&#125;) &#125;, bindEvent: function()&#123; this.form.addEventListener('submit', function(ev)&#123; ev.preventDefault(); this.saveData(); &#125;) &#125;&#125;controller.init(view, model);``` # 在 ES5 中如何用函数模拟一个类？```javascriptfunction Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job;&#125;Person.prototype.country = 'china';var zs = new Person("张三","29","teacher");var ls = new Person("李四","22","doctor");zs.name // 张三zs.age // 29ls.job // doctorzs.country // chinals.country // china 关于Promise用过 Promise 吗？举例说明。如果要你创建一个返回 Promise 对象的函数，你会怎么写？举例说明。答：Promise的使用：1234567891011121314151617$.get(url).then(function(data)&#123;console.log(data)&#125;,function()&#123;console.log('失败')&#125;);``` 创建： ```javascriptfunction preloadImage(path) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;;preloadImage('/xxx.jpg').then(function()&#123;console.log('成功')&#125;,function()&#123;console.log('失败')&#125;); 知识点Promise 对象是 JavaScript 的异步操作解决方案，从而不必一层层地嵌套回调函数endFn。传统的写法可能需要把f2作为回调函数传入f1，比如写成f1(f2)，异步操作完成后，在f1内部调用f2。Promise 使得f1和f2变成了链式写法。不仅改善了可读性，而且对于多层嵌套的回调函数尤其方便。1234567891011121314151617// 传统回调写法step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // ... &#125;); &#125;); &#125;);&#125;);回调地狱！！// Promise 的写法(new Promise(step1)) .then(step2) .then(step3) .then(step4); 创建一个返回 Promise 对象的函数:1234567891011function preloadImage(path) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;;preloadImage('/xxx.jpg').then(function(data)&#123;console.log('成功');console.log(data)&#125;, function(data)&#123;console.log('失败');console.log(data)&#125;); Promise 对象的状态Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。 pending等待态: 初始状态，既不是成功，也不是失败状态。 fulfilled完成态: 异步操作成功。 rejected拒绝态: 异步操作失败。 上面三种状态里面，fulfilled和rejected合在一起称为resolved（已定型）。这三种的状态的变化途径只有两种。 从“未完成”到“成功” 从“未完成”到“失败” 一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。 因此，Promise 的最终结果只有两种。 异步操作成功，从 pending 变为 fulfilled 异步操作失败，从 pending 变为 rejected。 只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 一开始，我们先设置好等状态从 pending 变成 fulfilled 和 rejected 的预案（当成功后我们做什么，失败时我们做什么）。 Promise 启动之后，当满足成功的条件时我们让状态从 pending 变成 fullfilled （执行 resolve）；当满足失败的条件，我们让状态从 pending 变成 rejected（执行 reject） Promise简单理解原始写法： 12345678910111213141516171819202122232425262728function fn1(callback) &#123; setTimeout(()=&gt;&#123; console.log('fn1') callback() &#125;, 1000)&#125;function fn2(callback) &#123; setTimeout(()=&gt;&#123; console.log('fn2') callback() &#125;, 1000)&#125;function fn3() &#123; setTimeout(()=&gt;&#123; console.log('fn3') &#125;, 1000)&#125;回调地狱↓fn1(function()&#123; fn2(function()&#123; fn3() &#125;)&#125;)//fn1,fn2,fn3 Promise写法：1234567891011121314151617181920212223242526272829303132333435function fn1() &#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log('fn1...') resolve(); &#125;, 1000) &#125;)&#125;function fn2() &#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log('fn2...') resolve(); &#125;, 1000) &#125;)&#125;function fn3() &#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log('fn3...') resolve(); &#125;, 1000) &#125;)&#125;function onerror() &#123; console.log('error')&#125;fn1().then(fn2).then(fn3).catch(onerror) Promise快速用法：123$.get('https://www.xxx.com/').then((data)=&gt;console.log(data),(error)=&gt;&#123;console.log(error);document.write(error.responseText)&#125;)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逻辑运算符 || 和 &&]]></title>
    <url>%2F2018%2F03%2F30%2F%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[&amp;&amp;与运算，有假就返回第一个的假值，全真就返回最后一个真值||或运算，有真就返回第一个的真值，全假就返回最后一个假值&amp;&amp; 的优先级高于 || 与运算 &amp;&amp;&amp;&amp;在运算时找falsy值，只要找到假值，那么输出的值为找到的第一个假值；没找到就输出最后面那个运算结果1234561 &amp;&amp; 0 //01 &amp;&amp; 0 &amp;&amp; 2 &amp;&amp; 3 //0 与运算看到0后就不执行后面的运算了1 &amp;&amp; null &amp;&amp; 3 //null1 &amp;&amp; 0 &amp;&amp; console.log(3) //0 1 &amp;&amp; 2 &amp;&amp; 3 //3 或运算 ||||在运算时找truy值，只要找到第一个真值，那么输出的值为找到的第一个真值。如果没找到真值，那么输出的值为最后面那个运算结果12340 || null || 1 //10 || null || 1 || 2 //1null || undefined || 0 //0 因此，var a = b || {}表示，如果b已经声明了，那么a = b，否则a = {} &amp;&amp; 的优先级高于 ||&amp;&amp; 的优先级高于 ||，先运算&amp;&amp;,再运算||12341 || 'a' &amp;&amp; 2 //1先进行&amp;&amp;运算，结果为2，在运行1 || 2，最终结果为1(1 || 'a') &amp;&amp; 2 //2]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 面向对象编程(OOP)]]></title>
    <url>%2F2018%2F03%2F30%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[面向对象OOP(Object Oriented Programming)特点：继承、封装、多态 面向对象面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。 名词解释 Class 类定义对象的特征。它是对象的Property属性和Method方法的模板. Object 对象类的一个实例。对象是一个容器，封装了属性（property）和方法（method）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。 Property 属性对象的特征，比如颜色。 Method 方法对象的能力，比如行走。 Constructor 构造函数对象初始化的瞬间, 被调用的方法. 通常它的名字与包含它的类一致. Inheritance 继承一个类可以继承另一个类的特征。 Encapsulation 封装一种把数据和相关的方法绑定在一起使用的方法. Abstraction 抽象结合复杂的继承，方法，属性的对象能够模拟现实的模型。 Polymorphism 多态多意为‘许多’，态意为‘形态’。不同类可以定义相同的方法或属性。 用new执行构造函数new命令的作用，就是执行构造函数，返回一个实例对象。下面的例子中，humanX 这个对象本身具有属性 name 和 cityhumanX.proto 对应的共有属性（也就是原型）具有物种（species）、走（walk）和使用工具（useTools）这几个属性 humanX.proto.constructor === Human 为 true123456789101112function Human(options)&#123; //构造函数建议开头大写 //自有属性 this.name = options.name; this.city = options.city;&#125; //共有属性(自带constructor属性和Object.prototype)Human.prototype.species = '人族';Human.prototype.walk = function()&#123;&#125;;Human.prototype.useTools: function()&#123;&#125;var humanX = new Human(&#123;name:'stage', city: 'shanghai'&#125;);]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务器LeanCloud的使用]]></title>
    <url>%2F2018%2F03%2F28%2F%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8LeanCloud%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[云服务器LeanCloud的使用通过一个小demo了解基本用法完整文档数据结构：学生选课系统 初始化 登陆 选择应用 -&gt; 创建新应用 (相当于创建一个服务器) 设置完新应用名称后，点击创建 这样就创建了一个服务器 点击应用名称进入对应服务器 点击创建Class，从而创建数据库 输入Class名称后，点击创建Class 根据帮助手册操作 选择开发语言或平台 -&gt; 选择 LeanCloud 应用 获取SDK：选择CDN加速，将av-min.js引入html文件中，得到window.AV对象 初始化：将代码引入js文件中进行初始化 验证：ping一下，看看能否访问LeanCloud的服务器 ping通后，在项目中编写提供的测试代码 然后打开 控制台 &gt; 存储 &gt; 数据 &gt; TestObject，如果看到如下内容，说明 SDK 已经正确地执行了上述代码，安装完毕。 1234567var APP_ID = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';var APP_KEY = 'xxxxxxxxxxx';AV.init(&#123; appId: APP_ID, appKey: APP_KEY&#125;); 保存数据123456789101112//在数据库中创建Class，名为Songlet Song = AV.Object.extend('Song');//获取名为Song的Classlet song = new Song();song.save(&#123; songName:'小幸运', singer:'田馥甄'&#125;).then(function(res) &#123; console.log(res) alert('上传成功!');&#125;) 一个一个set除了song.save({数据})，你也可以一个一个地set1234567891011var Song = AV.Object.extend('Song');var song = new Song();// 设置名称song.set('name','小幸运');// 设置歌手song.set('singer','田馥甄');song.save().then(function (res) &#123; console.log(res);&#125;, function (error) &#123; console.error(error);&#125;); 修改数据打开文档 –&gt; 对象 –&gt; 更新对象 123456// 第一个参数是 className，第二个参数是 objectIdlet todo = AV.Object.createWithoutData('Todo', '5745557f71cfe40068c6abe0');// 修改属性todo.set('content', '每周工程师会议，本周改为周三下午3点半。');// 保存到云端todo.save(); 获取数据获取所有数据数据存储开发指南 选择开发指南中的对象 –&gt; 批量操作获取数据：12345678var query = new AV.Query('Message');//对应数据库中的Class名称//query.include('owner'); 包含用户信息,否则返回的owner里面为空query.find().then(function(datas) &#123; console.log(datas.toJSON());//获取全部数据 datas.forEach(function(value) &#123; console.log(value); //遍历数据 &#125;);&#125;); .toJSON()如果需要一次性获取返回对象的所有属性（比如进行数据绑定）而非显式地调用 get(属性名)，可以利用 AV.Object 实例的 toJSON() 方法 https://leancloud.cn/docs/leanstorage_guide-js.html#hash-1546606634 1234567var query = new AV.Query('Todo');query.get('558e20cbe4b060308e3eb36c').then(function (todo) &#123; console.log(todo.toJSON());&#125;).catch(function (error) &#123; // 异常处理 console.error(error);&#125;); 统计数量count查询结果数量123456//获取Todo的总数量var query = new AV.Query('Todo');query.count().then(function (count) &#123; console.log(count);&#125;, function (error) &#123;&#125;); 按条件统计数量1234567//统计Todo中，title为test的数量var query = new AV.Query('Todo');query.equalTo('title', 'test');query.count().then(function (count) &#123; console.log(count);&#125;, function (error) &#123;&#125;); 返回指定属性返回Todo中的title和content字段123456789var query = new AV.Query('Todo');query.select(['title', 'content']);query.find().then(function (todo) &#123; console.log(todo.get('title')); // √ console.log(todo.get('content')); // √ console.log(todo.get('location')); // undefined&#125;, function (error) &#123; // 异常处理&#125;); 所指定的属性或字段也支持 Pointer 类型。例如，获取 Todo 这个对象的所有者信息（owner 属性，Pointer 类型），仅展示这个所有者的 username：1query.select('owner.username'); 返回满足条件的数据https://leancloud.cn/docs/leanstorage_guide-js.html#hash-1971670686返回表Todo中，所有title:头条新闻的项,返回的是个数组123456var query = new AV.Query('Todo');//query.include('user');query.equalTo('title', '头条新闻');//筛选出title为头条新闻的数据query.find().then(res =&gt; &#123; console.log(res);&#125;) 限定返回数量和排序限定返回数量和排序 设置返回 10 条结果：12345678910var query = new AV.Query('Todo'); // 按时间，从最老的开始返回 query.ascending('createdAt'); // 按时间，选出最新的返回 query.descending('createdAt');query.limit(10);// 最多返回 10 条结果query.find().then(res =&gt;&#123; console.log(res)&#125;) 分页将 skip 与 limit 搭配使用可以实现翻页效果。例如，在每页显示数量为 10，要获取第 3 页的对象：1234567var query = new AV.Query('Todo');query.descending('createdAt');//从最新的返回query.limit(10);// 最多返回 10 条结果query.skip(20);// 跳过 20 条结果(从第21条开始)query.find().then(res=&gt;&#123; console.log(res) &#125;) 根据objectId获取某个数据12345678let query = new AV.Query('Todo');//query.include('owner'); 包含用户信息,否则返回的owner里面为空query.get('57328ca079bc44005c2472d0').then(function (todo) &#123; // todo 就是 id 为 57328ca079bc44005c2472d0 的 Todo 对象实例 console.log(todo.toJSON())&#125;, function (error) &#123; // 异常处理&#125;); 删除数据通过destroy删除数据123456var todo = AV.Object.createWithoutData('Todo', '57328ca079bc44005c2472d0');todo.destroy().then(function (success) &#123; // 删除成功&#125;, function (error) &#123; // 删除失败&#125;); 判断当前用户是否登录状态文档 -&gt; 用户 -&gt; 登录 -&gt; 当前用户 1234567891011var currentUser = AV.User.current(); if (currentUser) &#123; // 如果true，说明用户已经处于登录状态 console.log(currentUser) currentUser.save(&#123; title:'1' &#125;); &#125; else &#123; //currentUser 为空时，跳转到注登录界面… &#125; 新用户注册1234567891011121314151617// 新建 AVUser 对象实例var user = new AV.User();// 设置用户名user.setUsername('Tom');// 设置密码user.setPassword('cat!@#123');// 设置邮箱user.setEmail('tom@leancloud.cn');//设置自定义属性，不如头像user.set('avatar','头像网址')user.signUp().then(function (loginedUser) &#123; console.log(loginedUser); console.log(loginedUser.toJSON())&#125;, function (error) &#123; //console.dir(error); alert(error.rawMessage);&#125;); 当用户忘记密码时，可以使用LeanCloud提供的通过邮箱重置密码服务 如果注册不成功，请检查一下返回的错误对象。错误代码 202，即 _User 表中的 username 字段已存在相同的值，此时需要提示用户该用户名已被别人注册过了。同样，邮件 email 和手机号码 mobilePhoneNumber 字段也要求在各自的列中不能有重复值出现，否则会出现 203(邮箱已被注册过)、214(手机号已被注册过) 错误。 用户名和密码登录https://leancloud.cn/docs/leanstorage_guide-js.html#hash-452075549 12345678910111213AV.User.logIn('Tom', 'cat!@#123').then(function (loginedUser) &#123; console.log(loginedUser); console.log(loginedUser.toJSON()); loginedUser.set('avatar', '头像网址');//设置自定义属性 loggedInUser.save().then(res =&gt; console.log(res.toJSON())); //查看更新后的数据&#125;, function (error) &#123; console.dir(error); if(error.code===211)&#123; alert('该用户不存在'); &#125;else if(error.code===210)&#123; alert('用户名和密码不匹配'); &#125;&#125;); 错误代码 211，表示用户名不存在210，用户名和密码不匹配200，成功~~ owner字段12345678910111213var currentUser = AV.User.current();var Product = AV.Object.extend('Product');if (currentUser)&#123;//如果登录了 var product = new Product(); product.save(&#123; title:'苹果', price:'12元', owner:currentUser //指向User //owner:AV.User.current() &#125;).then(data =&gt; &#123; console.log(data); &#125;);&#125; 登出文档 -&gt; 用户 -&gt; 重置密码 -&gt; 登出 1234AV.User.logOut();//此时currentUser为nullvar currentUser = AV.User.current(); 错误码error.codehttps://leancloud.cn/docs/error_code.html 上传图片文档讨论区 1&lt;input id="file" type="file"&gt; 123456789var avFile;var f = document.querySelector('#file');var filename = f.files[0].name;f.addEventListener('change', function() &#123; avFile = new AV.File(filename, f.files[0]).save() .then(data=&gt;console.log(data.url()),error=&gt;console.log(error));&#125;);//data =&gt; console.log(data.thumbnailURL(200, 200)) //返回200x200的图片地址 JS Bin]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>数据库</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包基础知识]]></title>
    <url>%2F2018%2F03%2F27%2F%E9%97%AD%E5%8C%85%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[什么是闭包闭包的作用闭包的例子 什么是闭包123456(function ()&#123; var local = '变量'; function fn()&#123; console.log(local); &#125;&#125;)(); 「函数」和「函数内部能访问到的变量」的总和，就是一个闭包。上面代码中的函数fn，它里面可以访问到 local 变量，那么函数fn和local变量形成一个闭包。 闭包的作用闭包的作用是用来「间接访问一个变量」。换句话说，「隐藏一个变量」。利用闭包可以将函数内部的变量传递到外部，从而实现在外部访问另一个函数内部的局部变量。 123456789101112131415(function()&#123; var person = window.person = &#123;//将这个对象的Address赋给window.person name: 'stage', &#125; var a=1;//传不出去&#125;)();//访问上面这个立即执行函数内部的person(function()&#123; var person = window.person;//获取window.person的Address，并赋给变量person console.log(person);//可以访问到 console.log(a);//访问不到&#125;)(); 闭包的使用如果person等于window.person，别人就可以访问到person内的数据，这样看起来很不妥。万一别人不小心修改了person内的数据怎么办。所以我们不能让别人「直接访问」这个变量。怎么办呢？用局部变量。但是用局部变量别人又访问不到，怎么办呢？如何从外部读取函数内部的局部变量？暴露一个访问器（在函数的内部，再定义一个函数），让别人可以「间接访问」。 1234567891011121314151617181920(function()&#123; var person = &#123; name: 'stage', age: 24, &#125; window.addAge = function ()&#123; //访问器 person.age++; return person.age; &#125;&#125;)();(function()&#123; var person = window.person;//获取不到 console.log(person);//undefined //无法获取person的信息，只能操作它的addAge方法 var newAge = window.addAge(); console.log(newAge);&#125;)(); ！ 上面代码中，利用闭包，让别的函数无法获取和修改person的name和age，只能通过addAge间接给age加一，从而隐藏并保护了person内的数据。 再举个例子：123456789101112131415var xxx = (function()&#123; var a = 1; return &#123; getA:function()&#123; return a; &#125;, addA:function()&#123; a++; return a; &#125; &#125;&#125;)();xxx.addA();xxx.getA(); 总结 立即执行函数使得person无法被外部访问 闭包使得内部的匿名函数可以访问到person window.addAge保存了匿名函数的地址，该匿名函数用来操作person 从而，任何地方都可以通过window.addAge里的方法操作person，但却无法访问到person的详细数据 优化，去除window1234567891011121314151617//赋给全局变量addAgevar addAge = (function()&#123; var person = &#123; name: 'stage', age: 24, &#125; return function ()&#123; person.age++; return person.age; &#125;&#125;)(); //返回一个匿名函数，并赋给全局变量addAge(function()&#123; var newAge = addAge();//执行返回的这个匿名函数 console.log(newAge);&#125;)(); 12345678910111213var person = (function()&#123; return &#123; sayName : function(name)&#123; var _name = name || '无'; return _name; &#125;, sayAge : function(age)&#123; var _age = age || 18; return _age; &#125;, &#125;;&#125;)(); 上面代码可以写成下面这样，这样写可以清楚知道return的内容，但是需要在上面取名字： 12345678910111213141516171819202122 var person = (function()&#123; var _sayName = function(name)&#123; var _name = name || '无'; return _name; &#125;; var _sayAge = function(age)&#123; var _age = age || 18; return _age; &#125;; return &#123; sayName : _sayName, sayAge : _sayAge &#125;&#125;)(); console.log(person.sayName('lucy')); //lucyconsole.log(person.sayName());//无console.log(person.sayAge(20));//20 再看一个例子12345678910111213141516171819202122232425262728293031var person = (function ()&#123; var name, age, sex; return &#123; getName: function()&#123; return name; &#125;, setName: function(newName)&#123; name = newName; &#125;, getAge: function()&#123; return age; &#125;, setAge: function(newAge)&#123; age = newAge; &#125;, getSex: function()&#123; return sex; &#125;, setSex: function(newSex)&#123; sex = newSex; &#125;, &#125;&#125;)();person.setName('王花花');console.log(person.getName());person.setAge(20);console.log(person.getAge());person.setSex('女');console.log(person.getSex()); 面试题正确打印出下标 12345&lt;ul&gt; &lt;li&gt;index 00000&lt;/li&gt; &lt;li&gt;index 11111&lt;/li&gt; &lt;li&gt;index 22222&lt;/li&gt;&lt;/ul&gt; 用闭包： 123456789var oLi = document.getElementsByTagName('ul')[0].children;for (var i = 0; i &lt; oLi.length; i++)&#123; (function(index)&#123; oLi[index].onclick = function()&#123; console.log(index); &#125;; &#125;)(i);&#125; 闭包还有一种写法: 1234567for (var i = 0; i &lt; oLi.length; i++)&#123; oLi[i].onclick = (function(index)&#123; return function()&#123; console.log(index); &#125; &#125;)(i);&#125; 方法三：将下标index作为对象的一个属性，添加到每个数组元素中 123456for (var i = 0; i &lt; oLi.length; i++)&#123; oLi[i].index = i; oLi[i].onclick = function()&#123; console.log(this.index); &#125;;&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC模型视图控制器]]></title>
    <url>%2F2018%2F03%2F27%2FMVC%E6%A8%A1%E5%9E%8B%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[MVC模式一个事件发生的过程（通信单向流动）：1、用户在视图 V 上与应用程序交互2、控制器 C 触发相应的事件，要求模型 M 改变状态（读写数据）3、模型 M 将数据发送到视图 V ，更新数据，展现给用户 MVC模式是什么MVC是一种设计模式它是一种编程思想 Model（模型）- 通常模型对象负责在数据库中存取数据。 View（视图） - 通常视图是将模型里的数据可视化。 Controller（控制器） - 从视图读取数据，控制用户输入，并向模型发送数据。 MVC的步骤原始代码:1234567891011//黏着导航(function() &#123; var topNavbar = document.getElementById('top-navbar'); window.addEventListener('scroll', function() &#123; if (pageYOffset &gt; 0) &#123; topNavbar.classList.add('sticky'); &#125; else &#123; topNavbar.classList.remove('sticky'); &#125; &#125;);&#125;)(); 添加view和controller：1234567891011121314151617181920212223242526272829303132//黏着导航，控制HTML中的top-navbar那么top-navbar就是view(function() &#123; var view = document.querySelector('#top-navbar'); var controller = &#123; view: null ,init: function (view)&#123; this.view = view; this.bindEvents(); //this.bindEvents.call(this) &#125; ,bindEvents: function () &#123; var view = this.view; window.addEventListener('scroll', () =&gt; &#123; //箭头函数没有this if (pageYOffset &gt; 0) &#123; this.sticky(); &#125; else &#123; this.unsticky(); &#125; &#125;); &#125; ,sticky: function()&#123; this.view.classList.add('sticky'); &#125; ,unsticky: function()&#123; this.view.classList.remove('sticky'); &#125; &#125; controller.init(view);&#125;)(); MVC的作用 Model：用来存取数据。所有与服务器交互的操作(存储、获取数据)都放在Model里 View：数据可视化。要将数据展示在哪一块区域就将那一区域作为View。 Controller：处理用户交互的部分。其他所有的操作放在controller里 Controller监听View，当用户点击View，View就会通知Controller Controller接收到通知，就会调用Model Model向服务器请求数据，然后服务端将数据返回给Model Model将从服务器返回的数据传给Controller Controller得到数据后，更新View Controller不直接访问服务器，而是专门由Model来负责 参考答案： Model 操作数据 View 表示视图 Controller 是控制器 Model 和服务器交互，Model 将得到的数据交给 Controller，Controller 把数据填入 View，并监听 View用户操作 View，如点击按钮，Controller 就会接受到点击事件，Controller 这时会去调用 Model，Model 会与服务器交互，得到数据后返回给 Controller，Controller 得到数据就去更新 View]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>MVC模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机专用的自适应方案 - 动态rem]]></title>
    <url>%2F2018%2F03%2F23%2F%E6%89%8B%E6%9C%BA%E7%AB%AF%E5%8A%A8%E6%80%81rem%2F</url>
    <content type="text"><![CDATA[rem不是响应式方案，它只针对手机端一切尺寸以width为基准记得要加上meta:vp使html的 font-size 与 pageWidth 建立联系border和非根元素font-size建议用pxsublime插件：cssrem各家公司的rem方案 做手机端页面的流程首先让设计师给出PC端和手机端的效果图，然后才能开始做。PC端使用float/flex布局，一般定宽min-width:1000px手机端则使用下面的方法↓ 手机端布局的几种方法 宽高写死，body设置width:320px并居中这样在所有的手机上，效果都和在宽度320px的手机上一样 百分比布局，尺寸不写死，用% 但是百分比布局无法知道height，因此设置height:20%无效 整体缩放 rem如果设计稿的宽度640px，其中一个div尺寸320x320我们希望在宽度320px的手机上，这个div尺寸是160x160在宽度为414px的手机上，这个div的尺寸是207x207 什么是动态rem动态rem不是响应式方案，它只适用于手机端，电脑和ipad不适用比如https://h5.m.taobao.com/ 在电脑端打开就会看起来很奇怪 常用尺寸 px：1像素 em：一个汉字的宽度(实际上是一个M的宽度) rem：根元素(html)的font-size的大小 vh：视口高度的1/100，100vh等于整个视口的高度 vw：视口宽度的1/100，100vw等于整个视口的宽度 min-width:无论如何，都不会小于这个宽度max-width:无论如何，都不会比这个宽度大 面试题浏览器默认font-size: 16px;，此时1rem = 16px = 1emchrome默认字号最小只能到12px rem与em的区别123456html&#123; font-size: 20px; //如果不自定义，则默认16px&#125;p&#123; font-size: 2rem; // 40px&#125; 1234p&#123; font-size: 18px; width: 2em; // 36px&#125; rem的使用步骤 添加meta:vp 让html的font-size等于页面宽度 给body添加font:size:16px，从而使字体大小复原; border和非根元素font-size建议用px 123456&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt;&lt;script&gt; var pageWidth = document.documentElement.clientWidth; var html = document.documentElement; html.style.fontSize = pageWidth+'px'; //或者pageWidth/10+'px'&lt;/script&gt; 此时，1rem = 页面宽度如果设计稿中，有一个元素宽度是设计稿宽度的40%，高度是设计稿宽度的20%,margin是设计稿宽度的5%那么这个元素width:0.4rem，height:0.2rem，margin:0.05rem拖动改变宽度，然后再次点击“run with js”查看效果 优化html.style.fontSize = pageWidth/10+&#39;px&#39;;这样1rem = 页面宽度的十分之一如果设计稿中，有一个元素宽度是设计稿宽度的40%，高度是设计稿宽度的20%,margin是设计稿宽度的5%那么这个元素width:4rem，height:2rem，margin:0.5rem注意，font-size不能是页面宽度的1/100,因为浏览器最小字号限制12px，假设页面宽度360px，那么字号是3.6px，会有bug border和非根元素font-size建议用px px2rem用Less将px自动转成rem假设1rem = 页面宽度的十分之一,那么123456789101112//Less:@design:640; //设计稿的宽度@px2rem: (1/@design)*10rem; //乘以10是因为页面宽度的十分之一div &#123; wifth:320*@px2rem;&#125;//css结果：div &#123; wifth: 5rem;&#125;]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>css</tag>
        <tag>js</tag>
        <tag>笔记</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime使用技巧]]></title>
    <url>%2F2018%2F03%2F23%2Fsublime%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[sublime快捷键常用插件snippet的使用 常用插件emmet前身是zencoding，作为前端界最出名（我觉得没有之一）的插件，几乎是可以稳定的提升50%的书写效率，用得多了以后的后遗症就是，好多CSS属性本来的拼法都记不清了。 emmet使用技巧 lorem可以打出一长串无意义字符串 lorem4可以打出4个字符串 jQuery主要是用来直接调出AJAX语法块，以及绑定事件响应。 SublimeGit好用到哭的git插件，妈妈再也不用担心我改出bug无法回滚了。几年前一个前辈教导我说，哪怕不做开源，自建一个本地仓库用git来管理代码也是很有必要的。一方面是能够控制代码版本，出了问题可以分步回滚，另一方面也是有一个task的概念，培养自己把软件开发任务做粒度的划分，便于估计自己的开发能力，预估工期。 JsFormat作为一个上升处女座的程序员，难以忍受凌乱的格式，更加难以忍受按无数次tab对齐代码，JsFormat可以格式化HTML，CSS和js代码。不过在写react的时候遇到很麻烦，你们懂的。目前还没有找到可以把react代码格式化做的很漂亮的插件。 a file icon根据文件类型显示不同的文件图标 其他Terminal、SideBarEnhancements、MarkdownLight、OmniMarkdownPreviewer CSSREMsublime px转rem插件：cssrem 快捷键 Esc ： 关闭搜索框，命令框等 Ctrl+D：选择单词，重复可增加选择下一个相同的单词 Ctrl + Shift + D：复制并同时粘贴整行 Alt+F3：一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中所有相同的变量名、函数名等。 Ctrl+P,搜索侧边栏中的文件名 shift+end ： 选择行，从光标当前所在位置开始选中到行尾 Ctrl+L：选择整行，重复可依次增加选择下一行 Ctrl+KK：从光标处删除至行尾 Ctrl+Shift+K：删除整行 Ctrl+Z：撤销 Ctrl+Y：恢复撤销 Alt+.：闭合当前标签 Ctrl+Shift+A：选择标签内部的内容(比如&lt;div&gt;我是内部内容&lt;/div&gt;) shift+home ： 从光标当前所在位置开始选中到行首 Ctrl+Shift+M ：选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。 Ctrl+M ：：光标移动至括号内结束或开始的位置。 Ctrl+F :打开底部搜索框，查找关键字。 Ctrl+shift+F :在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。 Ctrl+P :打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl+G :打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 Ctrl+R: 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl+: :打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 ctrl+alt+ ↓ ： 光标选择多行进行编辑(比如可以给多行前面添加-) Ctrl+J：合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。 Ctrl+G：跳转到第几行 Ctrl+W：关闭当前打开文件 Ctrl+F：查找内容 Ctrl+/：用//注释当前行 Ctrl+Shift+/ : 用/**/注释多行 ctrl+shift+enter： 在上一行插入新行 ctrl+[ ： 折叠代码 ctrl+] : 展开代码 Ctrl+KT：折叠属性，只显示标签 Ctrl+K0：展开属性 Ctrl+X ： 剪切 shift+ → ： 右移并选中 Shift+ ↑ ： 上移并选中 ctrl+shift+ → ： 光标按\w规则跳跃移动 alt+ → ： 光标按单词移动 alt+shift+ → ： 按单词移动并选择 home : 光标移到行首 end ： 光标移到行尾 ctrl+home ： 滚到文件最前面 ctrl+end ： 滚到文件最后面 Ctrl+Shift+上下键：整行移动交换位置 Ctrl+Shift+Y：选中计算表达式后按这个快捷键可以计算出结果 Ctrl+J：合并到一行 Ctrl+KU：改为大写 Ctrl+KL：改为小写 snippet点击工具 &gt; 插件开发 &gt; 新建代码片段 就可以创建一个新的snippet 在线生成工具：https://snippets.now.sh/1234567891011&lt;snippet&gt;&lt;!-- $&#123;1&#125;代表的是第一个光标位置，代码片会默认选中this，当按下tab之后，会选中$&#123;2&#125;中的snippet --&gt; &lt;content&gt;&lt;![CDATA[Hello, $&#123;1:this&#125; is a $&#123;2:snippet&#125;.]]&gt;&lt;/content&gt; &lt;!-- 设置关键词↓ --&gt; &lt;!-- &lt;tabTrigger&gt;hello&lt;/tabTrigger&gt; --&gt; &lt;!-- 设置生效的语言环境text.html,source.css,source.js --&gt; &lt;!-- &lt;scope&gt;source.js&lt;/scope&gt; --&gt;&lt;/snippet&gt;]]></content>
      <categories>
        <category>sublime</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[封装$.ajax]]></title>
    <url>%2F2018%2F03%2F22%2F%E5%B0%81%E8%A3%85ajax%2F</url>
    <content type="text"><![CDATA[ajax设置请求头的四部分ajax获取响应头的四部分封装$.ajax使用ES6解构赋值进行优化Promise的使用 头headers的4部分 请求头Request Headers请求头Request Headers的4部分：123451 GET /data.json HTTP/1.1 //动词 路径 协议/版本2 Host: 127.0.0.1:80802 Content-Type: application/x-www-form-urlencoded4 要上传的数据 响应头Response Headers响应Response Headers的4部分：123456781 HTTP/1.1 200 OK2 Content-Length: 24432 Content-Type: text/html2 Date: Tue, 10 Oct 2017 09:14:05 GMT2 Last-Modified: Mon, 23 Jan 2017 13:24:45 GMT4 &lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; 后面太长，省略了…… ajax操作第一部分设置请求用xhr.open()设置第一部分的请求方式和路径1操作第一部分 xhr.open('GET', '/data.json', true); 获取响应123xhr.status // 获取状态码，比如200xhr.statusText // 状态码对应的英文解释 比如200表示OK// 200 OK ajax操作第二部分设置请求用POST发送请求时，必须设置content-type用xhr.setHeader()设置第二部分设置请求头时，必须在xhr.send()之前设置123操作第一部分 xhr.open('post', '/xxx', true);操作第二部分 xhr.setHeader('content-type','x-www-form-urlencoded');操作第四部分 xhr.send(); 获取响应123xhr.getResponseHeader('content-type') // x-www-form-urlencodedxhr.getResponseHeader('content-length')xhr.getAllResponseHeaders() //获得所有的第二部分(请求头) ajax操作第四部分设置请求在用POST发送请求时，用xhr.send()可以设置第四部分将数据传给后端1操作第四部分 xhr.send('username=stage&amp;age=24'); 获取响应1xhr.responseText; 封装$.ajax123456789101112131415161718192021222324window.$.ajax(&#123; method: 'get' ,url: 'php.php' ,data: 'fname=stage&amp;age=24' //用for-in遍历↓ ,headers: &#123; 'content-type': 'application/x-www-form-urlencoded', test: 89 &#125; ,success: function (xhr)&#123;console.log(JSON.parse(xhr.responseText));&#125; ,fail: function (xhr) &#123; f1(xhr); f2(xhr); &#125;&#125;);&#125;function f1(xhr) &#123;console.log(xhr.status);&#125;function f2(xhr) &#123;console.log(xhr.statusText);&#125; 12345678910111213141516171819202122232425262728293031323334window.jQuery = &#123;&#125;;window.jQuery.ajax = function (options)&#123; var method = options.method; var url = options.url; var data = options.data; var success = options.success; var fail = options.fail; var headers = options.headers; /* 上面代码可以用ES6解构赋值（解析结构然后赋值）来进行优化 window.jQuery.ajax = function (&#123;method, url ,data, headers, success, fail&#125;)&#123; */ var xhr = new XMLHttpRequest(); xhr.open(method, url, true); for (var key in headers) &#123; xhr.setRequestHeader(key, headers[key]); &#125; xhr.onreadystatechange = function() &#123; if (this.readyState === 4) &#123; if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) &#123; success(xhr); &#125; else &#123; fail(xhr); &#125; &#125; &#125;; xhr.send(data);&#125;window.$ = window.jQuery; ES6解构赋值的用法交换a和b的值12345let a = 1;let b = 2;[a,b] = [b,a];a // 2b // 1 问题是每个程序员的回调名不一样，我们无法知道成功函数和失败函数的具体名字，也许别的程序员取名叫done和error呢 Promise 解决了这个问题 用Promise进行优化JavaScript Promise 对象 语法：return new Promise(function (resolve, reject){ 代码 } 用Promise之后，就不需要给success和fail这两个回调函数取名字了1234567891011121314window.$.ajax(&#123; method: 'get' ,url: 'php.php' ,data: 'fname=stage&amp;age=24' ,headers: &#123; 'content-type': 'application/x-www-form-urlencoded', test: 89 &#125;&#125;).then( //不需要取名字了，成功时执行第一个函数，失败时执行第二个函数 xhr =&gt; &#123;console.log('success');console.log(JSON.parse(xhr.responseText));&#125;, xhr =&gt; &#123;console.log('fail');console.log(xhr.status);&#125; ); 12345678910111213141516171819202122232425window.jQuery = &#123;&#125;;window.jQuery.ajax = (&#123;method, url ,data, headers&#125;/*es6解构赋值*/) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123;//如果一切都正常，则调用 resolve解析，否则调用 reject拒绝 const xhr = new XMLHttpRequest(); xhr.open(method, url, true); for (let key in headers) &#123; xhr.setRequestHeader(key, headers[key]); &#125; xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 400) &#123;//用了箭头函数，this就不是xhr了，而是window resolve(xhr); //不需要取名字success了 &#125; else &#123; reject(xhr); //不需要取名字fail了 &#125; &#125; &#125;; xhr.send(data); &#125;);&#125;window.$ = window.jQuery; Promise总结原始函数1$.ajax(&#123;success:fn1, fail:fn2&#125;); Promise方法：1234$.ajax().then(fn1, fn2);//成功则调用fn1，失败调用fn2//$.ajax().then((data)=&gt;console.log(data),(error)=&gt;&#123;console.log(error);document.write(error.responseText)&#125;)$.ajax().then(fn1).then(fn3); //fn1调用完后，再调用fn3]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
        <tag>ajax</tag>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax,jsonp跨域]]></title>
    <url>%2F2018%2F03%2F21%2Fajax%2Cjsonp%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[阮一峰：浏览器同源政策及其规避方法同源政策:同协议、同域名、同端口阮一峰：ajax教程ajax用XMLHttpRequest向后端发送请求，但是AJAX无法跨源json语法；通过JSON.parse(string)将后端返回的字符串转换成JS对象jsonp动态添加script标签实现跨域请求，但jsonp只能发送GET请求CORS跨域，支持所有请求 jsonJSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）JSON 使用 Javascript语法来描述数据对象 JS 是一门语言，JSON 是另一门语言 json这门语言是道格拉斯抄袭js的语言 JSON 使用 Javascript语法来描述数据对象 道格拉斯还写了本《javascript语言精粹》，俗称蝴蝶书，来吐槽js中垃圾的地方 json铁轨图http://json.org json语法{&quot;a&quot;:1,&quot;name&quot;:&quot;stage&quot;,&quot;age&quot;:24} json里的【字符串】必须用双引号，不能用单引号！！json没有undefined和function| js数据 | json数据 || :—-: |:———:|| 123| 123 || ‘stage’| “stage” || true| true || [‘a’, ‘b’] | [“a”, “b”] || {name: ‘stage’} | {“name”: “stage”} || null | null || undefined| json没有undefined || function fn(){}| json没有function | 浏览器同源策略 同协议 同域名 同端口 举例来说，http://www.example.com/d/page.html这个网址，协议是http://，域名是www.example.com，端口是80（http默认端口80，https默认端口443）。12345http://www.example.com/d2/other.html // 同源http://example.com/d/other.html // 不同源（域名不同）http://v2.www.example.com/d/other.html // 不同源（域名不同）http://www.example.com:81/d/other.html // 不同源（端口不同）https://www.example.com // 不同源（协议不同） 不刷新页面，使用xhr发送请求局部更新数据：AJAXAJAX - 异步的 JavaScript 和 XMLAJAX就是使用XMLHttpRequest技术向服务端发送请求AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 使用 XMLHttpRequest 发请求 服务器返回 JSON 格式的字符串(后来人们不用XML，改用JSON了) JS 解析 JSON(通过JSON.parse(字符串) 将JSON格式的字符串转成JS对象)，并更新局部页面1234567891011121314var xhr = new XMLHttpRequest();xhr.open('GET', '/', true);xhr.onreadystatechange = function() &#123; if (this.readyState == 4) &#123; if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) &#123; // 成功! var string = this.responseText; var obj = JSON.parse(string); &#125; else &#123; // 失败 _(:з」∠)_ &#125; &#125;&#125;;xhr.send(); AJAX无法跨域同源政策规定，AJAX请求只能发给同源的网址，否则就报错。只有 协议 + 域名 + 端口 完全一模一样才能发AJAX请求12http://www.baidu.com 不可以向 http://baidu.com 发AJAX请求http://www.baidu.com:80 不可以向 http://www.baidu.com:81 发AJAX请求 如何解决AJAX无法跨域的问题？↓↓↓ 跨域方法：jsonp由于同源策略，我们无法从别的域名(网站)那获取数据，用jsonp可以解决这个问题。JsonP(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取数据，即跨域读取数据。它的基本思想是，网页通过动态添加&lt;script&gt;标签，&lt;script&gt;标签的src向跨域服务器请求JSON数据，同时传一个查询参数callback=随机名&amp;时间戳,这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。1234567891011121314151617181920function addScriipt(src) &#123; var script = document.createElement('script'); script.setAttribute("type","text/javascript"); script.src = src; document.body.appendChild(script); script.onload = function(ev)&#123; this.parentNode.removeChild(this);; //删除script标签 &#125;&#125;window.onload = function () &#123; addScriipt('http://example.com/ip?callback=JQuery173625173837');&#125;function JQuery173625173837(data) &#123;//服务器收到这个请求以后，会将数据放在回调函数的参数位置(data)返回。 console.log(data.a);&#125;;//后端返回：JQuery173625173837(&#123;a:123&#125;); //由于上面定义了该方法，因此后端返回后直接执行这个方法 上面代码通过动态添加&lt;script&gt;标签，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字(一般用随机数),这对于JSONP是必需的。此外还需要加一个时间戳，防止浏览器的缓存。 由于&lt;script&gt;标签请求的脚本会直接作为代码运行。这时，只要浏览器定义了名字为随机数的函数，该函数就会立即调用。于是请求方就能获得他要的数据。 jsonp面试题 什么是jsonp JSONP(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取数据，即跨域读取数据。它的基本思想是： 网页通过动态添加&lt;script&gt;标签，&lt;script&gt;标签的src向服务器请求数据，同时传一个查询参数callback=随机名&amp;时间戳给服务器,这种做法不受同源政策限制 服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 由于&lt;script&gt;标签请求的脚本会直接作为代码运行。这时，只要浏览器定义了对应名字的函数，该函数就会立即调用。 于是请求方就能获得他要的数据。 jsonp为什么不支持post方法 因为jsonp是通过动态创建&lt;script&gt;标签实现的，而script只能通过GET请求数据，不能POST 由于jsonp只能发GET请求，于是又有了CORS跨域↓↓↓ CORS跨源AJAX请求当使用ajax访问远程服务器时，请求失败，浏览器报No &#39;Access-Control-Allow-Origin&#39; header解决方案:后端程序员添加response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨域AJAX请求的根本解决方法。CORS允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。相比JSONP只能发GET请求，CORS允许任何类型的请求。 123后端程序员加上这句响应头：response.setHeader('Access-Control-Allow-Origin', 'http://stage.com:8000')告诉浏览器，http://stage.com:8000可以向我方服务器发送ajax请求 或者前端程序员设置将ajax请求中的dataType属性设置为“jsonp”，jsonp是专门用来解决跨域访问而诞生的。1234567891011121314$(function($)&#123; var url = 'http://*****/index'; $.ajax(url, &#123; data: &#123; 'cityname': '成都' &#125;, dataType: 'jsonp', crossDomain: true, success: function(data) &#123; if(data &amp;&amp; data.resultcode == '200')&#123; console.log(data.result.today); &#125; &#125; &#125;); chrome调试在用submit提交数据时，页面会刷新，因此：chrome开发者工具 → Network → Network → 点击preserve log(页面刷新时不清楚日志)]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
        <tag>ajax</tag>
        <tag>json</tag>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 期中考试]]></title>
    <url>%2F2018%2F03%2F18%2F%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[link标签的media属性script标签的charset属性使用svg标签画图 请写出一个符合 W3C 规范的 HTML 文件要求： 页面标题为「我的页面」 页面中引入了一个外部 CSS 文件，文件路径为 /style.css 页面中引入了另一个外部 CSS 文件，路径为 /print.css，该文件仅在打印时生效 页面中引入了另一个外部 CSS 文件，路径为 /mobile.css，该文件仅在设备宽度小于 500 像素时生效 页面中引入了一个外部 JS 文件，路径为 /main.js 页面中引入了一个外部 JS 文件，路径为 /gbk.js，文件编码为 GBK 页面中有一个 SVG 标签，SVG 里面有一个直径为 100 像素的圆圈，颜色随意12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;我的页面&lt;/title&gt; &lt;link rel="stylesheet" href="style.css"&gt; &lt;link media="print" rel="stylesheet" href="print.css"&gt; &lt;link media="all and (max-width:500px)" rel="stylesheet" href="mobile.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;svg version="1.1" baseProfile="full" width="200" height="200" xmlns="http://www.w3.org/2000/svg"&gt; &lt;circle cx="100" cy="100" r="100" fill="green" /&gt;&lt;/svg&gt; &lt;script src="main.js"&gt;&lt;/script&gt;&lt;script charset="GBK" src="gbk.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 移动端是怎么做适配的？2016年腾讯前端面试题：移动端是怎么做适配的？ 回答要点： meta viewport 媒体查询（教程） 动态 rem 方案（教程） 使用meta标签的viewport能优化移动浏览器的显示 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; 使用媒体查询可以针对不同的媒体类型定义不同的样式。举个例子：如果浏览器窗口小于 500px, 就让背景变为蓝色：1234567&lt;style&gt;@media all and (max-width: 500px) &#123; body &#123; background-color: blue; &#125;&#125;&lt;/style&gt; 你也可以利用link标签的media属性，针对不同的媒体使用不同的样式表 :&lt;link media=&quot;all and (max-width:500px)&quot; rel=&quot;stylesheet&quot; href=&quot;mobile.css&quot;&gt; 动态rem方案通过js，动态设置html的font-size，让它的字号与页面宽度建立联系(比如html的字号等于页面宽度的十分之一)12345&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt;&lt;script&gt; var pageWidth = document.documentElement.clientWidth; document.documentElement.style.fontSize = pageWidth/10+'px';&lt;/script&gt; 此时，1rem就等于页面宽度的十分之一 css3圆角矩形和阴影怎么做?2017年腾讯前端实习面试题（二面）：用过CSS3吗? 实现圆角矩形和阴影怎么做?12345圆角矩形：border-radius 阴影分为盒子阴影和文字阴影:盒子阴影：box-shadow文字阴影：text-shadow 什么是闭包，闭包的作用是什么？2017年腾讯前端实习面试题（二面）：什么是闭包，闭包的用途是什么？123456(function ()&#123; var local = '变量'; function fn()&#123; console.log(local); &#125;&#125;)(); 「函数」和「函数内部能访问到的变量」的总和，就是一个闭包。上面代码中的函数fn，它里面可以访问到 local 变量，那么函数fn和local变量形成一个闭包。 闭包的作用是用来「间接访问一个变量」。利用闭包可以将函数内部的变量传递到外部，从而实现在外部访问另一个函数内部的局部变量。 call、apply、bind 的用法分别是什么？2017年腾讯前端实习面试题（二面）：call、apply、bind 的用法分别是什么？利用call、apply、bind这三个方法，可以改变this的指向，使它指向我们期望的对象。123var n = 123;var o =&#123;n: 234&#125;;function a() &#123;console.log(this.n)&#125;; call:格式fn.call(thisValue, arg1, arg2, ...)第一个参数是this要指向的那个对象，后面的参数是调用时所需要的参数用法123456a.call() //123a.call(null) //123a.call(undefined) //123a.call(window) //123a.call(o) //234可以看到，如果call方法没有参数，或者参数为null或undefined，则this指向全局对象 call()方法可以传递两个参数。第一个参数是指定函数内部中this的指向（也就是函数执行时所在的作用域），第二个参数是函数调用时需要传递的参数。1234function add(a, b) &#123; console.log(a + b); &#125;add.call(null, 1, 2); //3 第一个参数是必须的，可以是null，undefined，this，但是不能为空。设置为null，undefined，this表明函数add此时处于全局作用域。第二个参数中必须一个个添加。而在apply中必须以数组的形式添加。 apply方法与call方法类似，使用格式如下：func.apply(thisValue, [arg1, arg2, ...])apply方法的第一个参数也是this所要指向的那个对象，如果没有第一个参数，或者设为null或undefined，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。用法12345a.apply() // 123a.apply(null) //123a.apply(undefined) //123a.apply(window) //123a.apply(o) //234 call的第二部分参数要一个一个传，apply要把这些参数放到数组中。这就是他们的区别，真的就这么点区别！！！12345function add(a, b) &#123; console.log(a + b); &#125; add.call(null, 2, 3); //5 add.apply(null, [2, 3]); //5 然后，不得不说的一点：它们的第二个参数都可以传arguments。 bind()和call与apply不同。bind方法用于指定函数内部的this指向（执行时所在的作用域），然后返回一个新函数。bind方法并非立即执行一个函数。call和apply方法都是在调用之后立即执行的。而bind调用之后返回一个函数，需要再调用一次才行 格式：fn.bind(thisValue, arg1, arg2, ...]) 用法123456a.bind() //返回一个改变了上下文的函数a.bind()(); // 123a.bind(null)(); // 123a.bind(undefined)(); // 123a.bind(window)(); // 123a.bind(o)(); // 234 同样，我们也可以给bind方法传递参数，第一个参数如果为null或者undefined，会将函数内部的this对象指向全局环境；第二个为调用时需要的参数，并且传递参数的形式与call方法相同,一个一个传入。1234567function add(a, b) &#123;return a + b;&#125;console.log(add.apply(null,[1,4])); //5console.log(add.call(null,1,4)); //5console.log(add.bind(null, 1, 4)); //add()console.log(add.bind(null, 1, 4)()); //5 bind方法除了绑定this以外，还可以绑定原函数的参数12345678910111213var add = function (x,y) &#123; return x*this.m + y*this.n;&#125;var obj = &#123; m: 2, n: 2&#125;;var newAdd = add.bind(obj, 5);//add()函数的第一次参数x绑定为5,如果给了两个参数，则同时给定了x、y的值newAdd(3); //16 add()函数的参数y绑定3等同于add.bind(obj)(5,3) 找出数组最大元素123var a = [2, 4, 5, 7, 8, 10];console.log(Math.max.apply(null, a)); //10console.log(Math.max.call(null,2, 4, 5, 7, 8, 10)); //10 将数组里的空元素变为undefined通过apply方法，利用Array构造函数将数组的空元素变成undefined。1console.log( Array.apply(null, [1, , 3])); // [1, undefined, 3] 空元素和undefined的差别在于，数组的foreach方法会跳过空元素，但是不会跳过undefined，因此遍历内部元素的时候，会得到不同的结果1234567var a = [1, , 3]; a.forEach(function(index) &#123; console.log(index); //1,3 ，跳过了空元素。 &#125;) Array.apply(null,a).forEach(function(index)&#123; console.log(index); ////1,undefined,3 ，将空元素设置为undefined &#125;) 类数组变成数组利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。被处理的对象必须有length属性，以及相对应的数字键。 arr.slice()用于提取数组中的元素，当不传入参数时，则提取所有的元素12345678Array.prototype.slice.apply(&#123;0:1,length:1&#125;)// [1]Array.prototype.slice.apply(&#123;0:1&#125;)// []Array.prototype.slice.apply(&#123;0:1,lengt:2&#125;)// [1, undefined]Array.prototype.slice.apply(&#123;length:1&#125;)// [] 总结call，apply，bind方法的联系和区别 第一个参数都是指定函数内部中this的指向（函数执行时所在的作用域），然后根据指定的作用域，调用该函数。 都可以在函数调用时传递参数。call，bind方法需要直接传入，而apply方法需要以数组的形式传入。 call，apply方法是在调用之后立即执行函数，而bind方法没有立即执行，需要将函数再执行一遍。有点闭包的味道。 改变this对象的指向问题不仅有call，apply，bind方法，也可以使用that变量来固定this的指向。1234567891011var a = 1;var b = 2;var obj=&#123;a:3, b:4&#125;;function add(x,y)&#123; return this.a*x + this.b*y;&#125;add(5,6); // 1*5+2*6=17add.call(null,5,6) // 1*5+2*6=17, this指向windowadd.call(obj,5,6) // 3*5+4*6=39 ,this指向objadd.apply(obj,[5,6]) // 3*5+4*6=39 ,this指向obj，apply的参数以数组形式传入add.bind(obj,5,6)() // 3*5+4*6=39 ,this指向obj，bind方法并非立即执行一个函数，需要再次调用 关于javascript的call，apply，bind，bind()与前两种的区别？js中的bind、call、apply组合使用 HTTP 状态码2017年腾讯前端实习面试题（二面）：请说出至少 8 个 HTTP 状态码，并描述各状态码的意义。参考菜鸟教程资料：http://www.runoob.com/http/http-tutorial.html1234567891011121314151617200 OK:请求成功201 created:已创建。成功请求并创建了新的资源。一般POST时返回该状态码301 Moved Permanently:永久重定向302 Found:临时重定向304 未修改Not Modified：所请求的资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。服务器返回此状态码时不会返回任何资源。400：无法找到请求的资源。401：访问资源的权限不够。 一般登陆时用户名和密码不对会返回401404 Not Found ：请求的资源(网页)不存在。403 Forbidden ：没有权限访问资源。405：需要访问的资源被禁止。407：访问的资源需要代理身份验证。414：请求的URL太长。500 Internal Server Error：服务器内部错误，无法完成请求502 Bad Gateway ：充当网关或代理的服务器，从远端服务器接收到了一个无效的请求（比如服务器关了） HTTP post 请求的4部分2017年腾讯前端实习面试题（二面）：请写出一个 HTTP post 请求的内容，包括四部分。其中第四部分的内容是 username=ff&amp;password=123第二部分必须含有 Content-Type 字段请求的路径为 /path参考菜鸟教程资料：http://www.runoob.com/http/http-tutorial.html1234567POST /path HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.54.0Accept: */*Content-Type: application/x-www-form-urlencodedusername=ff&amp;password=123 说出三种排序请说出至少三种排序的思路，这三种排序的时间复杂度分别为 O(n²) O(n log2 n) O(n + max) https://blog.csdn.net/gane_cheng/article/details/52652705https://blog.csdn.net/supercoooooder/article/details/52153923https://www.cnblogs.com/Unknw/p/6346681.htmlhttp://bubkoo.com/2014/01/17/sort-algorithm/archives/ 冒泡排序 O(n²)原理：对数组进行遍历，相邻元素根据大小进行交换，每次遍历将最小值推至最前方，然后对剩下的值再次进行比较以数组 arr = [5, 1, 4, 2, 8] 为例说明，加粗的数字表示每次循环要比较的两个数字： 第一次外循环 ( 5 1 4 2 8 ) → ( 1 5 4 2 8 )， 5 &gt; 1 交换位置( 1 5 4 2 8 ) → ( 1 4 5 2 8 )， 5 &gt; 4 交换位置( 1 4 5 2 8 ) → ( 1 4 2 5 8 )， 5 &gt; 2 交换位置( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 5 &lt; 8 位置不变 第二次外循环（除开最后一个元素8，对剩余的序列） ( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 1 &lt; 4 位置不变( 1 4 2 5 8 ) → ( 1 2 4 5 8 )， 4 &gt; 2 交换位置( 1 2 4 5 8 ) → ( 1 2 4 5 8 )， 4 &lt; 5 位置不变 第三次外循环（除开已经排序好的最后两个元素，可以注意到上面的数组其实已经排序完成，但是程序本身并不知道，所以还要进行后续的循环，直到剩余的序列为 1） ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )( 1 2 4 5 8 ) → ( 1 2 4 5 8 ) 第四次外循环（最后一次）( 1 2 4 5 8 ) → ( 1 2 4 5 8 ) 快速排序 O(n log2 n)原理：从数组中取一个值为基准值，并将剩下的值与之比较，小于基准值的放到左边，大于基准值的放到右边，并再次对左右两边进行快速排序，直至左右两边只剩一个元素。以数组 arr = [5, 2, 1, 4, 8, 6] 为例取第一个数5为基准值，小于基准值的数放在基准值左边，大于基准值的数放在右边123 基准值 ↓2 1 4 [5] 8 6 然后分别对左右两边进行快速排序，左边以第一个数2为基准值，右边以第一个数8为基准值123左基准值 右基准值 ↓ ↓1 2 4 [5] 6 8 当左右基准值的两边都只剩一个元素时，快排结束。 桶排序 O(n + max) 【计数排序也是O(n + max)，max表示桶的数量】原理：将数组分到有限数量的桶里，然后对每个桶再分别排序（有可能再使用别的排序算法），最后将各个桶中的数据有序的合并起来。以数组 array = [29, 25, 3, 49, 9, 37, 21, 43]为例，数组中最大数为 49，先设置 5个桶，然后分别将这些数放入自己所属的桶12345第1个桶的范围 0~9: 3, 9第2个桶的范围 10~19:第3个桶的范围 20~29: 29, 25, 21第4个桶的范围 30~39: 37第5个桶的范围 40~49: 49, 43 然后，分别对每个桶里面的数进行排序12345第1个桶的范围 0~9: 3, 9第2个桶的范围 10~19:第3个桶的范围 20~29: 21, 25, 29第4个桶的范围 30~39: 37第5个桶的范围 40~49: 43, 49 最后，将各个桶中的数据有序的合并起来13, 9, 21, 25, 29, 37, 43, 49 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？这一题是在挖掘你的知识边界，所以你知道多少就要答多少。可以先查阅一些资料再查，但是不要把自己不懂的东西放在答案里，面试官会追问的。答： 输入URL地址 DNS查询：浏览器通过DNS服务器查找对应的 IP 地址(比如 www.baidu.com（百度域名） 对应的一个IP地址是 220.181.112.244) 建立TCP连接 —— TCP三次握手知道了服务器的 IP 地址，下面便开始与服务器建立TCP连接了。建立需要经历以下三个过程：浏览器向服务器发送一个建立连接的请求（你好，我可以连你吗？）；服务器接到请求后发送同意连接的信号（好的，你来连我吧）；浏览器接到同意连接的信号后，再次向服务器发送了确认信号（那我连你咯！），自此，浏览器与服务器两者建立了连接。 当TCP连接建立完成以后，浏览器向服务器发送 HTTP 请求4.1 请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空）4.2 第三部分永远都是一个回车4.3 第4部分是要上传的数据4.4 第 2 部分中的 Content-Type 标注了第 4 部分的格式 12345671 POST / HTTP/1.12 Host: www.baidu.com2 User-Agent: curl/7.54.02 Accept: */*2 Content-Type: application/x-www-form-urlencoded3 4 1234567890 服务器接收、处理请求 服务器返回 HTTP 响应，响应由4部分组成6.1 第1部分表示 协议/版本号 状态码 状态解释6.2 第 2 部分中的 Content-Type 标注了第 4 部分的格式6.3 第3部分永远是个回车6.4 第4部分是要下载的HTML文件内容 1234561 HTTP/1.1 200 OK2 Content-Type: text/html2 Content-Length: 1793134 &lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; 后面太长，省略了…… 浏览器得到 HTML 文件 浏览器开始对 HTML文件 进行加载、解析、渲染8.1 加载：浏览器对一个html页面的加载顺序是从上而下的，并在加载过程并行进行解析渲染处理。8.2 浏览器发送静态资源请求:在加载过程中遇到link标签、image标签、script标签时，浏览器会再次向服务器发送请求获取css文件、图片资源、js文件，并执行js代码，同步进行加载解析8.3 浏览器发送异步请求（Ajax）8.4 解析、渲染： 解析的过程，其实就是生成dom树。dom树是由dom元素及属性节点组成，加上css解析的样式和js解析后的动作实现。而渲染，就是将DOM树进行可视化表示。下一步就来到了绘制网页的工作阶段 浏览器通过上面步骤计算得到渲染树，构建渲染树使页面以正确的顺序绘制出来，经过一系列的渲染工作，最终完成了页面展示 断开连接 —— TCP三次挥手○ 主机向服务器发送一个断开连接的请求（你把我断开吧）；○ 服务器接到请求后发送确认收到请求的信号（知道了）；○ 服务器向主机发送断开通知（那我断开咯？）；○ 主机接到断开通知后断开连接并反馈一个确认信号（嗯，你断开吧），服务器收到确认信号后断开连接；为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所以服务器先发送确认信号，等所有数据发送完毕后再同意断开。 What really happens when you navigate to a URL知乎：从输入 URL 到页面加载完成的过程中都发生了什么 【第8步补充】： 根据HTML结构生成DOM Tree 根据css生成 CSSOM 将DOM和CSSOM整合成Render Tree(渲染树) 浏览器根据 渲染树 开始渲染(Painting)和展示(Display) 遇到script标签时，浏览器会阻塞渲染【所以script要放在尾部。1.这样可以让页面先渲染出来；2.这样js才能获取到所有的元素】 img发送异步请求，不会阻塞下面的代码渲染 如何实现数组去重？假设有数组 arr = [1,5,2,3,4,2,3,1,3,4]你要写一个函数 unique，使得unique(arr) 的值为 [1,5,2,3,4]也就是把重复的值都去掉，只保留不重复的值。要求： 不要做多重循环，只能遍历一次 请给出两种方案，一种能在 ES 5 环境中运行，一种能在 ES 6 环境中运行（提示 ES 6 环境多了一个 Set 对象）123456789101112131415161718192021222324ES5:function unique(arr)&#123; return arr.filter(function (value, index) &#123; return arr.indexOf(value) === index; &#125;);&#125;//上面的方法不满足要求，因为filter和indexOf算作两次遍历//更新如下方法↓function unique(arr)&#123; var hash=[]; for (var i = 0; i &lt; arr.length; i++) &#123; if(hash.indexOf(arr[i])==-1)&#123; hash.push(arr[i]); &#125; &#125; return hash;&#125;ES6:function unique4(arr)&#123; return [...new Set(arr)];&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>面试题</tag>
        <tag>css</tag>
        <tag>js</tag>
        <tag>http</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件]]></title>
    <url>%2F2018%2F03%2F17%2F%E4%BA%8B%E4%BB%B6%2C%E5%86%92%E6%B3%A1%2C%E6%8D%95%E8%8E%B7%2F</url>
    <content type="text"><![CDATA[DOM事件addEventListener()捕获和冒泡 DOM事件(默认冒泡)在 W3C 2 级 DOM 事件（DOM Level 2）中规范了事件模型。 面试题-事件如何触发函数事件通常与函数结合使用，下面哪种写法可以正确调用函数(方法)1234567&lt;div id="x" onclick="myFn"&gt;&lt;/div&gt; // ×&lt;div id="y" onclick="myFn()"&gt;&lt;/div&gt; // √&lt;div id="z" onclick="myFn.call()"&gt;&lt;/div&gt; // √x.onclick = myFn; // √x.onclick = myFn(); // × undefined，因为myFn()没有写return，则默认return undefinedx.onclick = myFn.call(); // × addEventListener()方法http://www.runoob.com/jsref/met-element-addeventlistener.html 如果一个对象绑定了多个click事件，那么就得用addEventListener()方法语法：ele.addEventListener(‘click’, myFn, 在捕获or冒泡阶段执行)，默认参数空或者false表示冒泡执行监听的事件绑定一个队列，队列里按顺序排列着函数(方法) 绑定多个事件1234567btn.onclick = myFn1;btn.onclick = myFn2;//myFn2的结果会覆盖myFn1btn.addEventListener("click", myFn1);btn.addEventListener("click", myFn2);//事件监听可以实现同一个对象绑定多个同样的事件执行不同的函数 addEventListener()里面是个队列，只有当事件发生时才会执行里面的函数**123456789101112131415161718function a()&#123; console.log('a');&#125;function b()&#123; console.log('b');&#125;function c()&#123; console.log('c');&#125;btn.addEventListener("click", a);btn.addEventListener("click", b);btn.removeEventListener("click", a);btn.addEventListener("click", c);btn.removeEventListener("click", c);//最终在这个队列里只剩下函数b因此，点击按钮后只打印出 'b' jquery的.one()方法原理123456function fn()&#123; console.log(1); btn.removeEventListener('click', fn);&#125;btn.addEventListener('click', fn); 冒泡 vs 捕获http://www.runoob.com/js/js-htmldom-eventlistener.html 先捕获，后冒泡，默认队列里的函数全部放在冒泡阶段执行 冒泡：点击最内层元素后，最内层元素的事件先触发，接着触发中层元素的事件，最后触发最外层的事件。捕获：点击最内层元素后，最外层元素的事件先触发，接着触发中层元素的事件，最后触发内层的事件。1234567891011结构a&gt;b&gt;cx.addEventListener('click', a);y.addEventListener('click', b);z.addEventListener('click', c);//点击c，默认打印出c,b,ax.addEventListener('click', a,true);y.addEventListener('click', b);z.addEventListener('click', c);//点击c,打印出a,c,b 默认冒泡阶段执行队列里的函数 当设置a的捕获为true时，a队列在a的捕获阶段执行于是先执行a队列里的函数，然后执行c，最后执行b 面试题-捕获冒泡顺序原则上，先捕获，后冒泡，函数(方法)队列在冒泡阶段执行但是1234567结构a&gt;b&gt;cz.addEventListener('click', fn冒泡,false);z.addEventListener('click', fn捕获,true);// 先执行fn冒泡，再执行fn捕获同一个元素，既有捕获，又有冒泡时，按照代码书写顺序执行 取消冒泡http://caibaojian.com/javascript-stoppropagation-preventdefault.html1ev.stopPropagation() 阻止默认行为1ev.preventDefault() 事件传播顺序]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>dom</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 ES6基础知识点]]></title>
    <url>%2F2018%2F03%2F16%2FES6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[字符串 =&gt; 模板字符串 字符串模板字符串123let a = world;let str = `hello $&#123;a&#125;`;console.log(str); // "hello world" 模板字符串甚至可以调用函数。1234function fn() &#123; return "World";&#125;`hello $&#123;fn()&#125;`; //"hello world" 将数组变成字符串12var arr = [1,2,3];var str = `$&#123;arr&#125;`; //'1,2,3' 解构赋值对象的解构赋值123let &#123; foo, bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb" 123456var hash=&#123;name:'stage',city:'shanghai'&#125;let &#123;name,city&#125;=hash; //name等于hash里的name，city等于hash里的city等同于var name = hash['name'];var city = hash['city']; 12345678910111213var url = response.config.url;var data = response.config.data;等同于let &#123;config:&#123;url,data&#125;&#125; = response;如果function (response)&#123; xxx&#125;则形参可以直接替换成function (&#123;config:&#123;url,data&#125;&#125;)&#123; xxx&#125; 函数形参的解构赋值12345678910111213141516171819202122232425function user(data)&#123; var name = data.name; var age = data.age; console.log(name,age)&#125;user(&#123;name:'stage',age:24&#125;)等同于function user(&#123;name,age&#125;)&#123; console.log(name,age)&#125;user(&#123;name:'stage',age:24&#125;)----------------function (data)&#123; let &#123;id,name,singer,pic&#125; = data; console.log("name:",name);&#125;等同于function (&#123;id, name, singer, pic&#125;)&#123; console.log("name:",name);&#125; 函数参数json的解构赋值ES5中用这种方法：12345678910111213141516171819var data1 = &#123;a:1&#125;var data2=&#123;a:&#123;b:2&#125;&#125;var data3 = &#123;a:&#123;b:&#123;c:'得到c啦'&#125;&#125;&#125;function test(data)&#123; if(data.a &amp;&amp; data.a.b &amp;&amp; data.a.b.c)&#123; return data.a.b.c; &#125;else &#123; return '默认值' &#125;&#125;等同于function test(data)&#123; return data.a &amp;&amp; data.a.b &amp;&amp; data.a.b.c || '默认值'&#125;test(data1)test(data2)test(data3) Es6中可以这样写1234567let data=&#123;x:&#123;a:1,b:2,c:&#123;d:3,e:4,f:5&#125;&#125;&#125;function test(&#123; x: &#123;c&#125; &#125;)&#123; //获取data里的、x里的cconsole.log(c)&#125;test(data); // &#123;d: 3, e: 4, f: 5&#125; ES6学习——新的语法：对象解构（Object Destructuring） 对象的操作Object.assign()的用法（合并）不建议使用该方法，因为这会导致原始数据被修改1234567891011121314let obj = &#123;&#125;,obj.a = 1;obj.b = 2;obj.c = 3;等同于//将哈希合并进obj内，此时obj改变了Object.assign(obj,&#123; a:1, b:2, c:3 &#125;)//obj=&#123;a:1,b:2,c:3&#125; 解决低版本浏览器不支持的问题pollyfill：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Browser_compatibility 12345let a = &#123;x:1,y:2&#125;let b = &#123;x:3,z:4&#125;Object.assign(b,a)//将a合并进b，此时a改变，b没有变//&#123;x: 1, z: 4, y: 2&#125; key与value同名可省略value12345678910111213ES5var obj = &#123; name:name, age:age, city:city&#125;ES6let obj = &#123; name, age, city&#125; …运算符（拷贝对象）12345678910111213141516var a = &#123;e:1,f:2&#125;var b = &#123;g:3,h:4,i:&#123;j:5,k:6&#125;&#125;var c = &#123; e:a.e, f:a.f, g:b.g, h:b.h, i:b.i&#125;等同于let c = &#123;...a, ...b&#125;//将a和b里所有的键值对拷贝过来//c=&#123;e: 1, f: 2, g: 3, h: 4, i: &#123;j:5,k:6&#125;&#125; module只导出1个对象12345678//创建a.jsexport default &#123; a:1&#125;//创建b.jsimport obj from './a,js';console.log(obj) 导出多个对象12345678910111213//创建a.jsexport function fn1()&#123; alert(1);&#125;export function fn2()&#123; alert(2);&#125;//创建b.jsimport &#123; fn1,fn2 &#125; from './b,js';fn1();fn2();]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery版的轮播图]]></title>
    <url>%2F2018%2F03%2F15%2Fjquery%E7%89%88%E7%9A%84%E8%BD%AE%E6%92%AD%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[用jquery实现一个轮播图，效果：自动轮播，点击切换，鼠标移入暂停用jquery实现无缝轮播 轮播图12345678910111213141516171819202122var n = 0;$('button').click(function() &#123; $('button').removeClass(); // removeClass不传入参数，则默认移除该元素所有class $(this).addClass('red'); n = $(this).index(); //通过.index()方法可以获取伪数组的index $('.imgs').css('transform', 'translateX(' + (-100 * n) + 'px)');&#125;);function setTimer() &#123; n++; $('button').eq(n % 5).trigger('click');&#125;var timer = null;timer = setInterval(setTimer, 3000);$('.box').hover(function() &#123; clearInterval(timer);&#125;, function() &#123; setTimer(); //鼠标移出后立即先执行一遍 timer = setInterval(setTimer, 3000);//然后再每隔3s执行&#125;); 无缝轮播图通过这个demo，了解了transitionend这个方法 为了防止切换页面，重新回来时，定时器出现错乱，建议加入以下代码：123456789var timer = null;$(document).on("visibilitychange", function() &#123; if (document.hidden === true) &#123; clearInterval(timer); &#125; else &#123; timer = setInterval(slide, 2000); &#125;&#125;);]]></content>
      <categories>
        <category>jq</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 前端面试题]]></title>
    <url>%2F2018%2F03%2F15%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%8A%BC%E9%A2%98%2F</url>
    <content type="text"><![CDATA[总结了一些前端的相关面试题http://ovenzeze.coding.me/菜鸟教程前端面试题2018春招-头条，腾讯，小米，百度面经https://www.cnblogs.com/itlkNote/p/6831115.htmlhttps://wenku.baidu.com/view/cbded359326c1eb91a37f111f18583d049640f99.htmlhttps://github.com/h5bp/Front-end-Developer-Interview-Questions/blob/master/Translations/Chinese/README.md 解题套路 抽象的问题，通过举例子来说明 遇到不会的，转移话题到会的内容，比如：不了解async/await，就和面试官说，我平时处理异步用的是Promise，然后把话题转到Promise的知识 侃侃而谈，讲述这项技术的历史发展 HTML考题DOCTYPE的作用&lt;!DOCTYPE&gt;用于告知浏览器的解析器用什么文档标准来解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 HTML5的写法&lt;!DOCTYPE HTML&gt; 如何理解 HTML 语义化目的： 对人友好：标签语义化就是给某块内容用上最恰当合适的标签，使其通俗易懂； 对搜索引擎友好：网页良好的结构和语义自然容易被搜索引擎捕捉 方法1 举例子：头部用 header，章节用 section，段落用 p，边栏用 aside，主要内容用 main 标签方法2 讲发展历史： 最开始是 PHP 后端写 HTML，不会 CSS，于是就用 table 来布局。table 使用展示表格的。严重违反了 HTML 语义化。后来有了专门的写 CSS 的前端，他们会使用 DIV + CSS 布局，主要是用 float 和绝对定位布局。稍微符合了 HTML 语义化。再后来，前端专业化，知道 HTML 的各个标签的用法，于是会使用恰当的标签来展示内容，而不是傻傻的全用 div，会尽量使用 h1、ul、p、main、header 等标签语义化的好处是易读、有利于SEO等。 知乎专栏详细答案 meta viewport 是做什么用的，怎么写？方法1 举例子：123快捷方式 meta:vp + tab键&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt;控制页面在移动端不要缩小显示。 方法2 侃侃而谈： 一开始，所有页面都是给PC准备的，乔布斯推出 iPhone 3GS，页面是不适应手机屏幕的，所以乔布斯的工程师想了一个办法，默认把手机模拟成 980px，页面缩小。后来，智能手机普及，这个功能在部分网站不需要了，所以我们就用 meta:vp 让手机不要缩小我的网页。 canvas 元素是干什么的？把画板项目丢给他看 MDN 的 canvas 入门手册 替换元素和非替换元素img,input等自闭和标签都是替换元素，这些元素没有实际的内容，即是个空元素&lt;div&gt;内容&lt;/div&gt;这种内部可以有内容的都是非替换元素，他们将内容直接告诉浏览器，将其显示出来 css考题选择器的权重和优先级第一等：内联样式，如: style=””，权值为1000。第二等：ID选择器，如：#content，权值为100。第三等：属性选择器和伪类，如.content，:hover，[attribute]权值为10。第四等：元素选择器和伪元素选择器，如div p，权值为1。 同样优先级，写在后面的覆盖前面的。特殊的！important优先级最高 说说css盒模型盒模型包括content、padding、border、margin但width和height不包括margin 标准盒模型(https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model) 设置 box-sizing： content-box: width/height == 内容区宽度/高度 【标准盒模型】 border-box: width/height == 内容区宽度/高度 + padding 宽度/高度 + border 宽度/高度 【IE盒模型】 js如何获取盒模型的宽和高 el.style.width/height 【只能取到行间样式,结果带单位】 getComputedStyle(el).width/height 【获取最终计算后得到的样式，结果带单位】 12var x = getComputedStyle(box).width;console.log(x); //100px el.getBoundingRect().width/height 【结果不带单位，且包含border】 12var x = box.getBoundingClientRect().width;console.log(x) //102 【width + 左右border】 css reset 和 normalize.css 有什么区别？ reset 重置，之前的样式我都不要了，抛弃默认样式 normalize 使标准化， 让所有浏览器的标签都跟标准规定的默认样式一致，各浏览器上的标签默认样式基本统一。 如何居中尽量能写多少就写多少，让面试官看到你不仅熟悉css布局，而且很有探讨精神，竟然会多种布局方式 绝对定位50% + 负的margin【必须知道子元素的宽高，不然没法设置负的margin】【点击查看代码】 绝对定位全为0，margin:auto【必须知道子元素的宽高】【点击查看代码】 绝对定位 + calc【必须知道子元素的宽高】【点击查看代码】 绝对定位50% + transform:translate(-50%,-50%)【不需要知道子元素宽高】【点击查看代码】 水平X居中 inline元素：爸爸身上写 text-align:center; 块元素【必须设置width】：margin:0 auto; 【点击查看代码】 垂直Y居中https://jscode.me/t/topic/1936 line-height === height 【点击查看代码】 多行文本垂直居中父元素设置display:table，子元素设置display:table-cell;vertical-align:middle 【点击查看代码】 BFC 是什么？块级格式化上下文(Block Formatting Contexts)举例子： 给爸爸overflow:hidden 清除浮动。（但我平常总是用 .clearfix 清除浮动) 外边距合并，给爸爸添加overflow:hidden 取消父子 margin 合并(给儿子设置margin-top时，爸爸也会被顶下去) BFC的原理 在同一个BFC内的两个相邻Box的margin会发生重叠 BFC的区域不会与float box重叠 BFC在页面上是一个独立的容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 哪些元素会生成BFC 根元素 float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible【overflow:auto/hideen生成BFC】 line-height=150%和1.5的区别150%是根据父元素的字体大小计算出行高，并且子元素依然沿用这个计算后的行高。而1.5则是根据子元素自己字体的大小去乘以1.5来计算行高。另，1.5em等也是按照150%的情况来算的。1234567891011121314151617181920212223242526272829&lt;!--当父元素的行高line-height:150%时，会根据父元素的字体大小计算出行高值然后再让子元素继承。所以子元素的行高等于16px * 150% = 24px：--&gt;&lt;div style="line-height:150%;font-size:16px;"&gt; 父元素内容 &lt;div style="font-size:30px;"&gt; Web前端开发&lt;br/&gt; line-height行高问题 &lt;/div&gt;&lt;/div&gt;&lt;!--当父元素行高line-height:1.5em时，和150%一样。所以，子元素行高等于16px * 1.5em = 45px：--&gt;&lt;div style="line-height: 1.5em;;font-size:16px;"&gt; 父元素内容 &lt;div style="font-size:30px;"&gt; Web前端开发&lt;br/&gt; line-height行高问题 &lt;/div&gt;&lt;/div&gt;&lt;hr&gt;&lt;!--当父元素行高line-height:1.5时，会根据子元素的字体大小动态计算出行高值让子元素继承。所以，子元素行高等于30px * 1.5 = 45px：--&gt;&lt;div style="line-height: 1.5;;font-size:16px;"&gt; 父元素内容 &lt;div style="font-size:30px;"&gt; Web前端开发&lt;br/&gt; line-height行高问题 &lt;/div&gt;&lt;/div&gt; float布局的缺点浮动布局，浮动元素脱离文档流，需要做清除浮动，这个处理不好的话，会带来很多问题，比如高度塌陷等。 如何清除浮动？看笔记 方法1: overflow:hidden 方法2 给父级加上class=”clearfix” 12345678.clearfix:after&#123; content:''; display:block; clear:both;&#125;.clearfix&#123; zoom:1; /*兼容低版本IE*/&#125; position定位 static：默认值，即没有定位 relative：相对于其原来的位置【导致自身位置发生相对变化，而不影响其他元素的位置】; absolute：相对于最近的已定位父元素(不为static的父元素)，如果元素没有已定位的父元素，那么它的位置相对于&lt;html&gt;;absolute会脱离文档流；absolute具有“包裹性”，块元素的宽度由内容决定 fixed：与absolute相同，除了fixed是相对于浏览器窗口或frame进行定位。 sticky：粘性定位，该定位基于用户滚动的位置。 rem和em的区别任意浏览器的默认字体高都是16px，最小12px。所有未经调整的浏览器都符合: 1em=16px。em是相对于自身font-size进行计算的，自身没有设置font-size的话则继承自父元素的字体大小1234567p&#123; font-size:20px;&#125;span &#123; font-size:40px; margin: 1em; //margin:40px&#125; remroot em，根em），是根据HTML根元素字体大小进行计算的 css3animation的api：123456789101112@keyframes changecolor&#123; 0% &#123;background: red;&#125; 25% &#123;background: yellow;&#125; 50% &#123;background: blue;&#125; 75% &#123;background: green;&#125; 100% &#123;background: red;&#125;&#125;div&#123; animation:changecolor 5s infinite;&#125; 语法：animation: name duration timing-function delay iteration-count direction fill-mode play-state;https://www.runoob.com/cssref/css3-pr-animation.html 如何用transform开启手机加速？我们平常会使用left和top属性来修改节点的位置，但left和top会触发重reflow，代价相当大。取而代之的更好方法是使用translate，这个不会触发reflow translateZ(0)或者translate3d(0,0,0) 开启GPU加速 transition 和 animation 的区别transition是过渡，表示一个状态过渡到另一个状态animation是动画，可以设置关键帧，一个动画可以由多个关键帧多个过渡组成，另外，animation可以设置infinite，暂停等 reflow重排/回流回流是布局或者几何属性需要改变就称为回流。回流必然导致重绘，重绘不一定会引发回流。 当你增加、删除、修改DOM节点时当你移动DOM的位置当你修改css尺寸（比如宽、高、display）当你修改网页默认字体时 repaint重绘重绘是当节点需要更改外观而不会影响布局的，比如改变 color，改变背景色 就称为重绘 当你需要往页面中插入10个&lt;li&gt;时，你可以：通过文档碎片，或者拼接完成字符串后，再一次性塞入innerHTML，这样可以降低Repaint（因为它不是每次都触发Repaint，而是一次性打包Repaint） requestAnimationFrame浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。 requestAnimationFrame的方式的优势如下： 经过浏览器优化，动画更流畅 窗口没激活时，动画将停止，省计算资源 更省电，尤其是对移动终端 requestAnimationFrame的用法与settimeout很相似，只是不需要设置时间间隔而已。123456var timer;var n = 0;timer = setInterval(function()&#123; console.log(n); n++;&#125;,16); 1234567var timer;var n = 0;timer = setTimeout(function loop()&#123; console.log(n); n++; timer = setTimeout(loop,16);&#125;,16); 1234567var timer;var n = 0;timer = requestAnimationFrame(function loop()&#123; console.log(n); n++; timer = requestAnimationFrame(loop);&#125;); cancelAnimationFrame(timer)可以取消动画 移动端布局 mata:viewport @media媒体查询 js动态设置html字体大小 + dom元素使用rem单位 = 动态rem 100vh == 视口高度，100vw == 视口宽度 js考题7种数据类型[6种值类型 + 引用类型object]原始类型/值类型：number，string，boolean，symbol，null，undefined 引用类型：object typeof的结果 typeof console.log(1) //打印出1，然后类型为’undefined’，因为console返回undefined typeof console.log // function typeof 数组 //object typeof null //object，【！！null是7种数据类型之一，它不是object，这是js遗留的历史bug】 typeof 函数//function 【！！function在7种数据类型中，属于object】 typeof NaN //number 【NaN表示非数字的数字类型】 1234567var str1=new String('str1');var str2='str2';typeof str1;//objecttypeof str2;//stringstr1 instanceof String;//truestr2 instanceof String;//false 判断是否是数组类型1234567var arr = [1,2,3]arr instanceof Array//或者Array.isArray(arr)//或者Object.prototype.toString.call(arr) === '[object Array]' instanceof可以判断实例对象的构造函数1234function Foo()&#123;&#125;;var foo = new Foo();foo instanceof Foo //true typeof的两个bug typeof 函数 //function typeof null //object 判断是否是空对象{}用 JSON.stringify(obj)12var obj = &#123;&#125;;JSON.stringify(obj) === '&#123;&#125;' //true function的length函数的length值就是它的参数数量12function fn(a,b,c,d,e)&#123;&#125;fn.length //5 js中的内置函数(可以通过new的函数) Number String Boolean Object Array Function Date RegExp Error ==与===123456789101112undefined == null //trueundefined === null //falsefalse == 'false' //falseundefined == false //falsenull == false //false 【undefined和null与其他任何类型==都是false!' ' == ' '//空格为true,取反后为false//布尔值与其他类型进行比较时，转成数字//因此 0 == ' ' ,而空格和空字符串转成数字都是0，即// '' == 0, ' ' == 0 必须用===，那么什么时候用==1234if(obj.a == null)&#123; //这里相当于obj.a === null || obj.a === undefined 的简写 //这是jQuery源码中的写法&#125; js的垃圾回收机制js运行机制js是单线程的，同一时间只能做一件事。 同步和异步的区别举例：点外卖由于js是单线程运行的，如果同步会阻塞代码执行，异步则不会阻塞代码执行 一个ajax请求，由于网络慢，需要5s钟，如果是同步的，这5s页面就卡死在这了。异步的话，5s等待就等待，其他事情不耽误做 12345678var a = true;setTimeout(function()&#123; a=false;&#125;,5000);while(a)&#123; console.log(1);&#125;//很多人以为5s后，a变成false，while就中止了，实际上，由于一开始a=true，所以已经直接进入死循环了 哪些语句会放入异步任务队列中？定时器Promise事件监听(比如click事件只有在被点击时才会触发)观察者模式 Event loop事件循环JavaScript只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 所有任务都在主线程上执行，形成一个执行栈。 主线程之外，还存在一个”任务队列”（task queue）。遇到异步代码就加入到任务队列中。 一旦”执行栈”中的所有同步任务执行完毕，系统就会从”任务队列”中取出需要执行的代码并放入执行栈中执行 主线程不断重复上面的第三步【执行栈中执行完成 -&gt; 从任务队列中取 -&gt; 执行栈中执行完成了 循环】。123456789101112131415// 执行顺序问题console.log(0);setTimeout(function () &#123; console.log(1);&#125;,0);new Promise(function(resolve,reject)&#123; console.log(2) resolve(3)&#125;).then(function(val)&#123; console.log(val);&#125;)console.log(4);//答案0,2,4,3,1//同步执行完 &gt; then &gt; 定时器 Promise的知识点3个状态 pending等待态: 初始状态，既不是成功，也不是失败状态。 fulfilled完成态: 异步操作成功。 rejected拒绝态: 异步操作失败。 2个过程 异步操作成功，pending -&gt; fullfilled (执行resolve) 异步操作失败，pending -&gt; rejected (执行reject) Promise链式调用12$.ajax().then(成功1,失败1).then(成功2,失败2)//只要前面一个then不报错，能够执行里面的任意一个函数，就能继续执行后面then里面的函数 手写实现Promise版的ajax12345678function xxx()&#123; return new Promise(function(resolve,reject)&#123; //异步操作，成功执行resolve() //失败执行reject() &#125;);&#125;xxx().then(成功,失败) async/await作用：把异步代码写成同步代码的形式 12345678910111213141516171819 function returnPromise()&#123; return new Promise( function(resolve, reject)&#123; setTimeout(()=&gt;&#123; resolve('fuck') &#125;,3000) &#125;) &#125; returnPromise().then((result)=&gt;&#123; alert(result); alert(1); &#125;) //3s后弹出fuck，接着弹出1 /* 改写成async/await */ let result = await returnPromise(); alert(result); alert(1);//等到result获取成功后，才继续执行下面的函数 ajax知识点除了ajax，还能通过fetch进行通信 手写ajax1234567891011var xhr = new XMLHttpRequest(); //开机xhr.open('GET','/api',true); //打开浏览器xhr.onreadystatechange = function()&#123; var data; if(xhr.readyState===4 &amp;&amp; xhr.status===200)&#123; //返回的数据是字符串，需要转成对象的形式 data = JSON.parse(xhr.responseText); console.log(data) &#125;&#125;xhr.send(); 【点击查看代码】 POST请求需要设置xhr.setRequestHeader(&#39;Content-type&#39;, &#39;application/x-www-form-urlencoded&#39;) 5种readyState(请求状态) 0：未初始化。尚未调用open()方法 1：启动。已经调用open()方法，尚未调用send()方法 2：发送。已经调用send()方法，尚未接收到响应 3：接收。已经接收部分响应数据。 4：完成。已经接收到全部响应数据，可以在客户端使用了。 xhr.status状态码 2xx:请求成功 3xx：需要重定向，浏览器会自动跳转 4xx：客户端请求错误（用户发过来的地址不正确） 5xx：服务端错误 200：正常。301：永久重定向302：临时重定向304：该资源在上次请求之后没有任何修改（可以直接使用浏览器缓存）。400：bad request，请求存在语法错误，服务器无法识别401：unauthorized，请求需要认证403：forbidden，请求的资源禁止被访问。404：需要访问的资源不存在。405：需要访问的资源被禁止。500：internal sever error，服务器内部错误。503：service unavailable，服务器正忙，可能服务器临时过载或停机维护。 get和post的区别 GET 的参数放在 url 的查询参数里，POST 的参数（数据）放在请求体里。 POST比GET安全【因为GET的参数直接暴露在url中 GET 传送的参数有长度限制。POST 的参数（数据）没有长度限制（因为参数放在请求体里） GET 用来获取数据，POST 用来写数据，POST 不幂等（注册 10 个和 11 个帐号是不幂等的;对文章进行更改 10 次和 11 次是幂等的。幂等指服务器上的资源总数不变） 除了get和post，还有哪些请求方式？GET：获取资源POST：提交或者创建DELETE：删除资源PATCH：部分修改数据PUT：整体替换资源HEAD：获得报文首部OPTIONS：查询相应URI支持的HTTP方法。 怎么跨域？JSONP 是什么？CORS 是什么？ajax无法跨域可以通过 表单，iframe,JSONP，CORS，document.domain，postMessage，WebSocket实现跨域 同源策略 协议：http或https要一模一样 域名：网址要一模一样 端口：端口要一模一样【http默认端口80，https默认端口443】 jsonpajax不能跨域，但是script标签可以跨域~ JSONP = JSON + Padding(包裹) 原理是：动态创建script标签，并传递一个callback名(callback=abc)给服务端，然后服务端返回数据时会将这个callback名作为函数名来包裹住JSON数据，前端只需要定义好与callback名同名的全局函数abc，在函数内部处理参数即可 1234567function flightHandler(data) &#123; alert('你查询的航班结果是：票价 ' + data.price + '元，余票' + data.tickets + '张。');&#125;;var url = 'http://flightQuery.com/flightResult.aspx?callback=flightHandler';var script = document.createElement('script');script.setAttribute('src', url);document.getElementsByTagName('head')[0].appendChild(script); 浏览器传一个callback名过去告诉服务器，本地调用的函数叫做flightHandler于是服务端将数据包裹在这个callback名内12345flightHandler(&#123; "code": "CA1998", "price": 1780, "tickets": 5&#125;); 浏览器收到后，json数据直接以入参的方式, 放置到function中，自动执行该函数。 因为jsonp是通过动态创建&lt;script&gt;标签实现的，而script只能发送GET请求，不能POST，因此又有了cors跨域 cors服务端设置http header实现跨域后端程序员添加response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); 当你使用 ajax 发送请求时，浏览器发现该请求不符合同源策略，会给该请求加一个请求头：Origin，后台进行一系列处理，如果确定接受请求则在返回结果中加入一个响应头：Access-Control-Allow-Origin; 浏览器判断该相应头中是否包含 Origin 的值，如果有则浏览器会处理响应，我们就可以拿到响应数据，如果不包含浏览器直接驳回，这时我们无法拿到响应数据。所以 CORS 的表象是让你觉得它与同源的 ajax 请求没啥区别，代码完全一样。 postMessage这种方式通常用于获取嵌入页面中的第三方iframe。一个页面发送消息，另一个页面判断来源并接收消息12345678910// A窗口发送消息端window.postMessage('data', 'http://B.com');// B窗口接收消息端window.addEventListener('message', (event) =&gt; &#123; console.log(event.origin) if (event.origin === 'http://B.com') &#123; console.log('验证通过'); console.log(event.data) &#125;&#125;); 闭包知识点【返回一个函数】闭包的概念：待补充【https://zhuanlan.zhihu.com/p/22486908】闭包常常用来「间接访问一个变量」，换句话说，「隐藏一个变量」。使得变量只能函数内部访问，外部无法直接访问和修改变量，从而达到收敛权限的目的 123456789101112function add()&#123; var n = 1; return function()&#123; return n; &#125;&#125;var plus = add();plus(); //1plus(); //2plus(); //3console.log(n) //报错，因为我们无法直接访问n 闭包的应用123456789101112131415161718192021var divs = document.getElementsByTagName('div');for(var i = 0;i&lt;divs.length;i++)&#123; divs[i].onclick = function()&#123; console.log(i); &#125;&#125;//由于点击事件在for循环完成之后才被执行，而var是全局变量，此时全局的i是10//因此点击时打印出10//修正//利用闭包和立即执行函数var divs = document.getElementsByTagName('div');for (i = 0; i &lt; divs.length; i++) &#123; (function(i) &#123; divs[i].onclick = function() &#123; console.log(i); &#125; &#125;)(i);&#125;//每次for循环，都会生成一个立即执行函数(如果有10个div，则生成10个立即执行函数)//通过闭包，访问的不再是全局的i，而是每次for循环传进来的参数i this的指向this只有在函数被执行时才能确认箭头函数中的this是在定义函数的时候就确定了，而不是在执行函数时确定 fn()的this指向window，在严格模式下为undefined a.b.c.fn()的this指向a.b.c div.onclick = function(){/这里的this指向div/} 构造函数new Fn()的this指向新生成的实例对象 箭头函数的this是继承自父执行上下文中的this【它的上一级的 this】 this指向 call,apply,bind 的第一个参数 【https://zhuanlan.zhihu.com/p/23804247】 箭头函数say，它的父级是obj，而obj在window下【window.obj】，因此这里的this.x实际上表示的是window.x，因此输出的是11。123456789var x=11;var obj=&#123; x:22, say:()=&gt;&#123; console.log(this.x); &#125;&#125;obj.say();//相当于window.obj.say(); call,apply,bind的区别call 和 apply 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。 除了第一个参数外，call 可以接收一个参数列表，apply 接受一个参数数组。 bind 和call一样，接收一个参数列表，只是bind会返回一个函数，且该函数的this绑定死了，无法再次改变。 12345678"use strict"function fn(a,b)&#123; console.log(this)&#125;fn(1, 2) //undefined,严格模式下，this不为window而是undefinedfn.call(undefined, 1, 2) //undefined，非严格模式下为windowfn.apply(undefined, [1, 2]) //undefined，非严格模式下为window 在严格模式下， fn 里的 this 就是 call 的第一个参数，也就是 undefined。在非严格模式下(不加”use strict”)， call 传递的第一个参数如果是 undefined 或者 null， 那 this 会自动替换为 Window 对象 立即执行函数作用：ES5没有块级作用域，所以只能通过 函数作用域 来防止污染全局变量123(function()&#123; var n = 1;&#125;)(); ES6可以使用块级作用域123&#123; let n = 1;&#125; 作用域链 函数在执行的过程中，先从自己内部找变量 如果找不到，再从创建当前函数所在的作用域去找, 以此往上，直到window 1234567891011var a=1; function f1()&#123; var b=2; function f2()&#123; var c=3; console.log(a); &#125; f2();&#125;f1(); //1//当前作用域没有定义a，就去父级作用域f1里找，父级作用域里也没有定义a，就继续往上寻找，直到window对象为止 合并数组123456789var arr1 = [1,2,3];var arr2 = [4,5,6];//es5var newArr = arr1.concat(arr2);//es6arr1.push(...arr2);arr1 //[1,2,3,4,5,6] 浅拷贝Object.assign12var obj = &#123;a:1&#125;var copyObj = Object.assign(&#123;&#125;,obj) 深拷贝JSON.parse(JSON.stringify(obj))12var obj = &#123;a:1&#125;var copyObj = JSON.parse(JSON.stringify(obj)) 缺点：不支持拷贝 函数、undefined、Symbol 递归拷贝1234567891011121314function deepClone(obj)&#123; var result = &#123;&#125;; for(var key in obj)&#123; if(typeof obj[key] === 'object')&#123; result[key] = deepClone(obj[key]); &#125; else&#123; result[key] = obj[key]; &#125; &#125; return result;&#125;var obj = &#123;a:1, b:undefined, c:function()&#123;&#125;&#125;var copyObj = deepClone(obj) 数组去重123let arr = [1,1,1,2,3,4,5,1,3,6,3];let newArr = [...new Set(arr)]; //去重后的数组//原数组不变 正则 用正则实现string.trim()去除首尾空格 123function trim(str)&#123; return str.replace(/^\s+|\s+$/g, '');&#125; 正则判断url 原型 这种抽象的题目，通过举例子回答。https://zhuanlan.zhihu.com/p/23090041 var arr = [1,2,3]; 为什么arr可以使用push()方法，这个push()方法从哪得到的？当试图得到对象的某个属性时，如果它本身没有，就会去它的proto中寻找 arr.proto === Array.prototype 【arr是个数组，因此它的proto指向构造函数Array的原型(公共属性和方法)】 在Array的公共方法中，有push()这个方法 arr就是顺着原型链调用的push()方法 123456function People()&#123; this.name = 'name';&#125;var p = new People();People.prototype // &#123;constructor: ƒ People(), __proto__: Object.prototype&#125;People.__proto__ // Function.prototype;函数的__proto__指向Function的原型 编写原型/面向对象的例子js中没有类的概念，因此面向对象是依靠原型来实现的1234567891011121314151617181920212223242526function El(id)&#123; this.el = document.querySelector(id);&#125;El.prototype.html = function(val)&#123; if(val)&#123;//如果传入参数，说明是修改innerHTML this.el.innerHTML = val; return this;//返回这个对象，用于链式操作 &#125;else&#123;//如果没传参数，说明是获取 return this.el.innerHTML; &#125;&#125;El.prototype.on = function(type,fn)&#123; this.el.addEventListener(type,fn); return this; //用于链式调用&#125;var div1 = new El('#app');//获取console.log(div1.html());//链式调用div1.html('&lt;h1&gt;hello&lt;h1&gt;').on('click',function()&#123; console.log(1);&#125;); JS Bin【查看在线代码】 改写成ES6写法12345678910111213141516171819202122232425262728class El&#123; constructor(id) &#123; //私有属性 this.el = document.querySelector(id); &#125;; //公共方法prototype html(val) &#123; if (val) &#123; //如果传入参数，说明是修改innerHTML this.el.innerHTML = val; return this; //返回这个对象，用于链式操作 &#125; else &#123; //如果没传参数，说明是获取 return this.el.innerHTML; &#125; &#125;; on(type, fn) &#123; this.el.addEventListener(type, fn); return this; //用于链式调用 &#125;&#125;var div1 = new El('#app');//获取console.log(div1.html());//链式调用div1.html('&lt;h1&gt;hello&lt;h1&gt;').on('click', function() &#123; console.log(1);&#125;); JS Bin【查看在线代码】】 原型链当一个对象想要获取某个属性或调用某个方法，而它本身没有时，就会顺着它的prototy === 它的构造函数.prototype 里找。1234567891011121314151617181920212223242526272829303132333435function User(name)&#123; this.name = name; //自身属性&#125;User.prototype.sayName = function()&#123; //公共属性 console.log('我叫' + this.name);&#125;var whh = new User('王花花');whh.sayAge = function()&#123; console.log('今年22岁');&#125;//whh的自身属性和方法：&#123;name:'王花花', sayAge:f()&#125;whh.sayName(); //whh本身没有sayName这个方法，于是去它的 构造函数.prototype 里找whh.toString(); //whh里没有该方法,于是顺着whh.__proto__ === User.prototype,这里也没有toString方法,于是继续顺着User.prototype__proto__ === Object.prototype,在对象的公共方法里找到了``` 整个原型链：whh由User构造而来，于是whh.__proto__ === User.prototype, User.prototype.__proto__ === Object.prototype, Object.prototype.__proto__ === null---**改写成ES6语法**```javascriptclass User&#123; constructor(name)&#123; //私有属性 this.name = name; &#125;; //公有属性 sayName()&#123; console.log("我叫" + this.name); &#125;;&#125;let whh = new User('王花花'); // &#123;name:'王花花'&#125;whh.sayName(); //我叫王花花 用instanceof判断构造函数12345whh instanceof User //true,说明whh由User构造而来User.prototype instanceof Object // true//最好用constructorwhh.__proto__.constructor === User //true 如何判断这个属性是否是对象本身拥有的属性？遍历自身属性和方法123456789101112for(let prop in whh)&#123; console.log(prop)&#125;//会将公共方法sayName也给打印出来//正确的方法如下for(prop in whh)&#123; if(whh.hasOwnProperty(prop))&#123; console.log(prop);//将自有属性和方法打印出来 &#125;&#125;//此时，公共属性和方法不会打印出来 哪些方法可以创建一个对象1234567891011var obj1 = &#123;a:1,b:2&#125;var obj2 = new Object(&#123;a:1,b:2&#125;)function Fn(a,b)&#123; this.a=a; this.b=b;&#125;var obj3 = new Fn(1,2)var obj4 = Object.create(&#123;a:1,b:2&#125;) new做了什么？ 创建一个空对象 this指向这个空对象 这个空对象的prototy指向构造函数的prototype 开始执行代码（即对this赋值） return 这个对象 如果构造函数中没有手动写return,则默认return这个对象；如果手动return的话，基础类型自动忽略，比如return 123,最终还是return这个对象；如果手动return引用类型，则返回手动写的这个引用类型123456function Fn(name)&#123; this.name = name; return 1 //无效 return [1,2,3] //则返回这个引用类型&#125;const fn = new Fn('Peter') 如何实现继承ES5通过原型链12345678910111213141516171819202122232425//父类function Human(name)&#123; this.name=name;&#125;Human.prototype.say=function()&#123; console.log('我叫'+this.name);&#125;//子类function Male(name,age)&#123; Human.call(this,name);//将父类的私有属性name传过来 this.gender = "男性"; this.age = age;&#125;//将父类的公有属性传过来function Fn()&#123;&#125; //声明一个空的构造函数Fn.prototype = Human.prototype;Male.prototype = new Fn();Male.prototype.hobby = function()&#123; console.log("男生喜欢玩电动");&#125;var stage = new Male('stage',22); ES6通过extends12345678910111213141516171819202122232425//定义父类class Human&#123; constructor(name)&#123; //私有属性 this.name = name; &#125;; //公有属性 say()&#123; console.log("我叫"+this.name); &#125;;&#125;//子类class Male extends Human&#123;//将子类的prototype.__proto__链接到Human的公有属性 constructor(name,age)&#123; super(name); //将父类的私有属性name传进来 this.gender = '男'; this.age = age; &#125;; hobby()&#123; console.log('男生喜欢玩电动'); &#125;;&#125;let stage = new Male('stage',22); ES6新增的数据类型有哪些？ Set：类似于数组，但Set中不允许出现重复的元素 Map：类似于对象，但Map的key可以是任何数据类型 DOM押题DOM事件机制/事件模型是什么？一个事件的触发过程主要有三个阶段:捕获阶段,目标阶段,冒泡阶段可以通过addEventerListener设置冒泡和捕获【默认false冒泡】 描述DOM事件捕获的具体流程window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素 补充：通过document.body获取body标签通过document.documentElement获取html标签 event对象 event.preventDefault(); event.stopPropagation(); event.currentTarget 【绑定了该事件的这个对象】 event.target 【当前被点击的元素】 移动端的触摸事件了解吗？touchstart touchmove touchend touchcancel 模拟 swipe 事件记录两次 touchmove 的位置差，如果后一次在前一次的右边，说明向右滑了。 事件委托/事件代理是什么？有什么好处？优点：使代码简洁；减少浏览器的内存占用 假设父元素有4个儿子，我不设置4个监听器监听4个儿子，而是只设置1个监听器监听父元素，看触发事件的元素是哪个儿子，这就是事件委托。好处：省监听器。【一个爸爸有4个儿子，他们在同一个班上上课，班主任可以分别检查4个儿子的作业完成情况，也可以委托他们的爸爸检查作业，然后将结果告诉班主任】 可以监听还没有出生的儿子（动态生成的元素）。【如果又生了一个儿子，爸爸会连同新儿子的作业一起检查】 编写通用的事件代理代码123456789101112131415161718192021222324252627282930function bindEvent(el, type, selector, fn) &#123; if (!fn) &#123; //如果只传入3个参数，第四个参数没传入 fn = selector; selector = null; &#125; el.addEventListener(type, function(ev) &#123; if (selector) &#123;//如果传入子选择器 var target = ev.target; if (target.matches(selector)) &#123; //如果点击的target与传入的子选择器匹配 fn.call(target, ev); //this指向所点击的目标target &#125; &#125; else &#123; fn(ev); &#125; &#125;);&#125;////////////////////////////使用代理bindEvent(app, 'click', 'p', function(ev) &#123; console.log(this.innerHTML); //this指向所点击的目标&#125;)//不使用代理var p = document.getElementsByTagName('p')[0];bindEvent(p, 'click', function(ev) &#123; console.log(p.innerHTML)&#125;) 【点击查看代码】 HTTP押题http报文的组成部分请求报文： 请求行 请求头 空行/换行 请求体 响应报文: 状态行 响应头 空行/换行 响应体 https与http的区别HTTP:超文本传输协议HTTPS = HTTP + SSL/TLS，在HTTP和TCP之间添加一个安全协议层（SSL或TSL） 默认HTTP的端口号为80，HTTPS的端口号为443 HTTP的缺点： HTTP在传输的过程中使用的是未加密的明文，内容可能被窃听 不验证通信方身份，可能遭到伪装 无法验证报文完整性，可能被篡改 HTTPS就是HTTP加上SSL加密+身份认证+完整性保护 https的加密过程客户端浏览器在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。 客户端发送一个随机值1、需要的协议以及加密方式 服务器确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数2。 客户端收到数字证书并验证是否有效，验证通过会再生成一个随机值3，并根据数字证书的公钥去加密这个随机值3并发送给服务端 服务器使用自己的私钥，将客户端发来的随机数3个解密出来 两端根据约定的加密方式，使用前面的三个随机数，生成”对话密钥”，用来加密接下来的整个对话过程。 通过以上步骤可知，在 SSL/TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密速度慢，损耗性能大，所以在正式传输数据时，两端使用对称加密的方式通信。 对称加密与非对称加密的区别对称加密：两边拥有相同的秘钥，两边都知道如何将密文加密解密。优点是速度很快非对称加密：有公钥私钥之分，公钥所有人都可以知道，公钥用于数据的加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。特点是速度慢，CPU 开销大 http 2.0采用二进制传输，引入多路复用，对Header 压缩，服务端push TCP和UDP的区别从输入 URL 到页面展现中间发生了什么？301和302的区别 301 永久重定向，浏览器会记住 302 临时重定向 HTTP缓存怎么做？添加Cache-Control: max-age=300通过修改查询参数来取消缓存12http://cdn.com/1.js?v=1http://cdn.com/1.js?v=2 Cache-Control 和 Etag 的区别是什么？Cookie 是什么？Session 是什么？ cookie是存储在浏览器上的一小段「数据」，用来记录某些当页面关闭或者刷新后仍然需要记录的信息。 session是一种让服务器能识别某个用户的「机制」。session 在实现的过程中需要使用cookie Cookie 服务器响应浏览器的请求时，会种下Cookie(服务端通过在Response headers中设置set-cookie来让浏览器种下cookie) 浏览器每次访问指定域名时会自动带上Cookie Cookie 一般用来记录不敏感信息，如用户名 cookie的相关操作？12345678//获取cookiedocument.cookie //"a=1; b=2; c=3" 以 分号+空格 的形式分割//设置cookie，将d=4的过期时间设置为↓document.cookie="d=4; expires=Thu, 18 Dec 2013 12:00:00 GMT";//删除 cookie 非常简单。您只需要设置过期时间 expires 为以前的时间即可document.cookie = "expires=Thu, 01 Jan 1970 00:00:00 GMT"; Session当一个用户打开淘宝登录后，刷新浏览器仍然展示登录状态。服务器如何分辨这次发起请求的用户是刚才登录过的用户呢？这里就使用了session保存状态。用户在输入用户名密码提交给服务端，服务端验证通过后会在后端创建一个session用于记录用户的相关信息的对象。创建session后，会把关联的session_id 通过set-Cookie 添加到响应头中浏览器在加载页面时发现响应头中有 set-cookie字段，就把这个cookie 种到浏览器。当下次刷新页面时，发送请求会自动带上这条cookie， 服务端在接收到后根据这个session_id来识别用户。 session的使用方式：session_id存在客户端的cookie里，服务端session存用户数据；当客户端访问服务端时，自动带上cookie，根据cookie里的session_id找用户数据 Session 数据放在服务器上 Session 需要通过在 Cookie 里记录 SessionID 实现 SessionID 一般是随机数 LocalStorage 和 Cookie 的区别是什么？ Cookie 会随请求被发到服务器上【每次请求都会带上，影响获取资源的效率】，而 LocalStorage 不会 Cookie 存储量为4kb【因为每次发送请求，都会自动带上cookie，所以cookie不能太大】，LocalStorage 一般5Mb 左右 cookie的api用起来很麻烦，不是key:value的对象形式，而是字符串”a=1; b=2”这种形式，操作起来不方便;LocalStorage是key:value的对象形式，它的api用起来方便 localStorage：永久存储，除非手动删除； sessionStorage：数据在当前浏览器窗口关闭后自动删除。 cookie：数据在设置的过期时间之前一直有效（如果没有设置过期时间，则在浏览器关闭时删除） LocalStorage 和 SessionStorage的区别完全一样，除了【LocalStorage永久存储；SessionStorage在会话结束后清空】 Load 和 DOMContentLoaded 的区别？页面中的 DOM，CSS，JS，图片已经全部加载完毕后才会触发Load事件。DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载完成。 Vue押题Vue与React的区别/为什么选择Vue而不用React 我发现贵公司的主页用的是Vue，所以我也用Vue JSX糟糕透了,因为JSX的可读性太差,它硬是把HTML和JS混合在一起 React的生命周期函数太长~~~了 Vue可以用v-model进行双向数据绑定，在React中，如果有10个input，那你就要绑定10个事件；而在Vue中，只需要v-model就可以了 已经熟悉Vue了，没有必要再学一个定位相似的东西，React能实现的我用Vue也能做到 Vue由尤雨溪个人维护，React由Facebook维护 Vue的生命周期钩子函数Vue的组件通信 父子通信（使用 Prop 传递数据、使用 v-on 绑定自定义事件） 爷孙通信（通过两次父子通信，爷爷先传给爸爸，爸爸再传给儿子） 兄弟通信（new Vue() 作为 eventBus） Vue-router利用hash做前端路由的 Vuex 的作用是什么？用于状态管理，相当于本地数据库，响应式地处理数据https://vuex.vuejs.org/zh-cn/intro.html Vuex的实现原理Vue 的双向绑定是如何实现的？有什么缺点？看深入响应式原理 当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。对于Object.defineProperty，主要是靠将普通属性变成访问器属性。访问器属性内部拥有两个方法，getter方法与setter方法。当用户读取对象的属性时，就调用其getter方法，当用户为此属性赋值时，就会调用setter方法。我们只要劫持这两个方法，通发布/订阅模式，在属性被访问和修改时通知变化，就能偷偷操作视图。 https://github.com/huangchucai/MVVM- Computed 计算属性的用法？跟 Methods 的区别。https://zhuanlan.zhihu.com/p/33778594 数据结构与算法押题排序算法二分查找法 先将数组从大到小排序 从有序数组的中间开始查找，如果正好是要找的值，就return，否则 如果大了，就去左半边查找；如果小了，就去右半边查找； 重复第1步 安全押题XSS跨站请求攻击向页面注入js脚本：输入框里的value不是文本，而是一段js代码，此时这段恶意js代码被执行了，就是XSS攻击 1&lt;img src="xxx.png" onload="alert(1)"&gt; hacker写了一篇博客，同时偷偷插入一段&lt;script&gt; 攻击代码可以获取cookie，并发送到hacker的服务器中 别人看hacker的博客，就会把查看者的cookie发送到hacker的服务器 预防： 方法0：将cookie设置为httpOnly，让js无法操作cookie 方法1：不要使用innerHTML，使用textContent 方法2：如果一定要用innerHTML，需要进行字符过滤http://www.cnblogs.com/xianshenglu/p/8324573.html1234567function html2Text(str) &#123; let div = document.createElement('div'); div.textContent = str; return div.innerHTML;&#125;html2Text('&lt;p&gt;123&lt;/p&gt;') // &amp;lt;p&amp;gt;123&amp;lt;/p&amp;gt; 或者12345678910function escape(str) &#123; str = str.replace(/&amp;/g, "&amp;amp;"); str = str.replace(/&lt;/g, "&amp;lt;"); str = str.replace(/&gt;/g, "&amp;gt;"); str = str.replace(/"/g, "&amp;quto;"); str = str.replace(/'/g, "&amp;##39;"); str = str.replace(/`/g, "&amp;##96;"); str = str.replace(/\//g, "&amp;##x2F;"); return str&#125; CSRF跨站请求伪造Cross Site Request Forgery 用户已经登录某网站后，攻击者构造某网站后台某个功能接口的请求地址，诱导用户去点击或者用特殊方法让该请求地址自动加载(比如在img中插入该接口的请求&lt;img src=&quot;weibo.com/add_friend&quot;&gt;)。简单点说，CSRF 就是利用用户已经登录的状态发起恶意请求。 过程 用户登录新浪微博 weibo.com 用户切换到 hacker.com（恶意网站） hacker.com 发送一个 weibo.com/add_friend 请求，让当前用户关注陌生账号 。 用户在不知不觉中关注了很多营销号。 用户没有想发这个请求，但是 hacker 伪造了用户发请求的假象。 避免 验证 Referer：通过验证 Referer 来判断该请求是否为第三方网站发起的，weibo.com 可以拒绝来自 hacker.com 的请求 验证 Token ：服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。 增加密码、短信验证码的验证 模块化押题AMD规范AMD是RequieJS的模块定义规范,它通过Require.js实现 AMD会异步加载(按需加载)js,依赖了什么模块就加载这个模块 CMDCMD是SeaJS定义的模块化规范 CommonJS规范CommonJs是nodejs的模块化规范 CommonJs不会异步加载JS，而是一次性加载出来CommonJs可以配合npm使用webpack基于CommonJs规范 ES6 module在没有标准的时代，弄一些非标准的标准作为过渡如今，已经有了标准的规范，从即刻起开始用 ES6 module webpack押题作用： 处理模块化（因为浏览器不支持module） 编译语法（将Less转成Css，将ES6转成ES5） 代码压缩 webpack与grunt、gulp的区别转译出的文件过大怎么办？在vue单页应用中，若不做任何处理，所有vue文件会打包为一个js文件，这个js文件非常的大，造成网页在首次进入时比较缓慢。做了code split(代码分割)后，会将代码分离到不同的js中，然后进行按需加载这些js文件，能够提高页面首次进入的速度，网站性能也能够得到提升。1234import page1 from '@/page/page1.vue'//上述代码改成const page1 = () =&gt; import('@/page/page1.vue') 转译速度慢什么办？写过 webpack loader 吗？http://www.alloyteam.com/2016/01/webpack-loader-1/ 技术选型 流行：目前流行的技术有哪些，能否用到我的项目中 团队：团队对某种技术的熟悉程度，学习成本 业务需求：能否套用现在的成熟解决方案/库来快速解决业务需求 维护成本 对前端前景的展望，前端未来会怎么发展前端社区掘金，segmentfault，github，官方文档，v2ex，知乎(尤雨溪也在上面) 谈谈内容，样式，行为的分离html负责内容css负责样式js负责行为为什么这三者要分离？（反过来回答：如果不分离会导致……）如果用html负责样式12345&lt;div bgcolor=green&gt; &lt;center&gt; &lt;font color=red size=20&gt;文字居中&lt;/font&gt; &lt;/center&gt;&lt;/div&gt; 这样会使得html的标签有些是用来表示内容的，有些是用来表示样式的，导致html结构很复杂，很难区分这些标签的逻辑结构 如果用css负责内容123456789div:after&#123; content:'我是内容';&#125;``` 这样会导致用户无法选中内容；js也无法取到 如果用js负责样式```javascript$('#div1').show(); // 这会导致原本的display修改为block 建议设置css,然后通过addClass和removeClass来切换样式 关于性能优化性能优化及技巧分享 如果在图片下载下来之前就知道img的宽高，那么就把宽高写进img标签内；否则浏览器会先用一个小宽度的占位符，等到大图下载下来后，由于宽高撑大了原本的占位符，于是之后的元素的位置要往后退，这会导致重排(re-layout)，重排非常的浪费性能。 异步与回调异步异步：不等结果，直接进行下一步同步 vs 异步：同步：定时器的结果出来后，才进行下一步异步：不等定时器的结果，马上进行下一步123456789101112console.log(1);/* 这是个异步任务↓ setTimeout(function()&#123; console.log(2);&#125;,2000);*/console.log(3);先打印出1，再打印出3,两秒后打印出2 回调可以通过callback回调拿到异步结果1234567891011121314console.log(1);(function xxx()&#123; setTimeout(function()&#123; console.log(2); callback(); &#125;,2000);&#125;)();function callback()&#123; console.log('endFn');&#125;console.log(3); thisthis的指向1234567891011window.n = 'window name'let obj = &#123; n: 'obj name', sayN()&#123; console.log(this.n) &#125;&#125;let fn = obj.sayNfn() //window name,因为是window.fn(),fn这个方法属于window，所以this指向windowobj.sayN() // obj name，因为sayN这个方法属于obj，所以this指向obj 当前方法属于谁，this就是谁 箭头函数的this12345678910window.n = 'window name'let obj = &#123; n: 'obj name', sayN: () =&gt; &#123; console.log(this.n) &#125;&#125;obj.sayN()//window name 箭头函数是和父级上下文绑定在一起的！！比如这里的箭头函数中的this.n，箭头函数本身与sayN平级，sayN在对象obj中，而obj的父级上下文就是window，因此这里箭头函数的this指向window new一个实例对象,this指向这个实例对象用new命令时，默认给构造函数的起始位置加上var this = {}，this指向这个空对象12345function x()&#123; console.log(this);&#125;x(); //windownew x(); //对象&#123;&#125; 12345678910var a=11function test1()&#123; this.a=22; let b=function()&#123; console.log(this.a); &#125;; b();&#125;test1(); //22var x = new test1(); //11 分析：test1()等同于window.test1()，这个方法属于window,因此调用时，this指向window123456789var a=11function test1()&#123; this.a=22; //这里的this指向window，所以window.a从11变成了22 let b=function()&#123; console.log(this.a); // window.a此时是22 &#125;; b(); //最终输出22&#125; new test1()会在构造函数内部生成var this = {}123456789101112var a=11function test1()&#123; //var this = &#123;&#125; this.a=22; let b=function()&#123; console.log(this.a); &#125;; b();&#125;var x = new test1(); //最终结果11//此时实例对象x=&#123;a: 22&#125;,方法b不在这个实例对象里，所以this无法指向x，只能指向window 要想最终结果是22，则改写成1234567891011var a=11function test1()&#123; this.a=22; this.b=function()&#123; console.log(this.a); &#125;; this.b();&#125;var x = new test1();//此时x=&#123;a:22,b:方法&#125;因此this指向x,this.a的结果是22 定时器123456789function getSomething()&#123; setTimeout(function()&#123; return 'hello' &#125;)&#125;let something = getSomething()console.log(something)//undefined 由于定时器是异步的，所以优先执行同步代码，因此something是undefined]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>面试题</tag>
        <tag>css</tag>
        <tag>js</tag>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿照jquery]]></title>
    <url>%2F2018%2F03%2F13%2F%E4%BB%BF%E7%85%A7jquery%2F</url>
    <content type="text"><![CDATA[如何封装一个js库把封装的js库添加到自定义的接口(自定义对象)上jquery的原理 封装函数封装函数获取兄弟节点(ele)1234567891011121314151617function 获取兄弟节点(ele)&#123; var parent = ele.parentElement; var allChildren = parent.children; var length = 0; var 伪数组=&#123;length:length&#125;; for(i=0;i&lt;allChildren.length;i++)&#123; if(allChildren[i] !== ele)&#123; 伪数组[length] = allChildren[i]; length++; 伪数组.length = length; &#125; &#125; return 伪数组;&#125;console.log( 获取兄弟节点(li4) ); 封装函数添加或删除多个class(ele,classes)12345678910111213141516var classes = &#123;'a':true, 'b':false,//false表示删除 'c':true &#125;;function 添加或删除多个class(ele,classes)&#123; for(var key in classes)&#123; if(classes[key])&#123; ele.classList.add(key); &#125;else &#123; ele.classList.remove(key); &#125; &#125;&#125;添加或删除多个class(li5,classes); 代码优化上面的代码可以优化为：12345678910原始代码：if(classes[key])&#123; ele.classList.add(key);&#125;else &#123; ele.classList.remove(key);&#125;优化：var method = classes[key] ? 'add' : 'remove';ele.classList[method](key); 打开console控制台查看结果JS Bin 命名空间12345678var stage = &#123;&#125;; // 或者 window.stage = &#123;&#125;stage.获取兄弟节点 = 匿名函数; //添加到对象内stage.添加或删除多个class = 匿名函数; //添加到对象内var x = stage.获取兄弟节点(li4);console.log(x);stage.添加或删除多个class(li6,&#123;'a':true,'b':false,'c':true&#125;); JS Bin 这种方法每次都要使用stage.xxx(ele,其他参数)太麻烦了 把ele放在前面的方法上面的方法每次使用都要在前面加上命名空间,比如stage.xxx(ele,其他参数)，这样太麻烦了 如何达到以下效果，不使用命名空间：12ele.获取兄弟节点()ele.添加或删除多个class(&#123;'a':true,'b':false,'c':true&#125;); 直接加到Node.prototype上将封装的函数直接加到Node的公用属性(原型)Node.prototype上。并且把传入的第一个参数去掉，函数体内改成this1234567891011121314151617Node.prototype.获取兄弟节点 = function &#123; var parent = this.parentElement; var allChildren = parent.children; var length = 0; var 伪数组=&#123;length:length&#125;; for(var i=0;i&lt;allChildren.length;i++)&#123; if(allChildren[i] !== this)&#123; 伪数组[length] = allChildren[i]; length++; 伪数组.length = length; &#125; &#125; return 伪数组;&#125;;console.log( li7.获取兄弟节点() );// 此处this就是li7 【点击查看源码】 但是这种方法可能会污染Node的公用属性，因此不建议直接加到Node.prototype上 把封装的js库添加到自定义的接口上1234567891011121314151617181920212223242526272829var stage = function(node) &#123; return &#123; 获取兄弟节点: function() &#123; var parent = node.parentElement; var allChildren = parent.children; var length = 0; var 伪数组 = &#123; length: length &#125;; for (var i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== node) &#123; 伪数组[length] = allChildren[i]; length++; 伪数组.length = length; &#125; &#125; return 伪数组; &#125;, 添加或删除多个class: function(classes) &#123; for (var key in classes) &#123; var method = classes[key] ? 'add' : 'remove'; node.classList[method](key); &#125; &#125; &#125;&#125;;/////////////////console.log( stage(li3).获取兄弟节点() );stage(li3).添加或删除多个class(&#123; 'a': true, 'd': true &#125;); JS Bin 完善封装的js库123456789101112131415161718192021222324252627282930313233 function stage(node) &#123; if(typeof node === 'string')&#123;//如果传入的是个字符串 node = document.querySelector(node); &#125; return &#123; getSibings: function() &#123; var parent = node.parentElement; var allChildren = parent.children; var length = 0; var 伪数组 = &#123; length: length &#125;; for (var i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== node) &#123; 伪数组[length] = allChildren[i]; length++; 伪数组.length = length; &#125; &#125; return 伪数组; &#125;, add_remove_classes: function(classes) &#123; for (var key in classes) &#123; var method = classes[key] ? 'add' : 'remove'; node.classList[method](key); &#125; &#125; &#125;;&#125;;/////////////////console.log( stage('#li3').getSibings() );stage(li4).add_remove_classes(&#123; 'red': true&#125;);stage('ul&gt;li:nth-of-type(2)').add_remove_classes(&#123;'red':true&#125;); JS Bin 用$缩写(alias)1window.$ = stage; 12345678910111213141516171819202122232425262728var stage = function (node) &#123; var eles = &#123;length: 0&#125;; if (typeof node === 'string') &#123; //如果传入的是个字符串 var temps = document.querySelectorAll(node);//临时变量是个伪数组 for(var i=0;i&lt;temps.length;i++)&#123; //把临时变量存到伪数组eles内 eles[i] = temps[i]; eles.length = temps.length; &#125; &#125; //在eles里添加添加方法 eles.add_remove_classes = function(classes) &#123; for (var key in classes) &#123; var method = classes[key] ? 'add' : 'remove'; for (var j=0;j&lt;eles.length;j++)&#123; eles[j].classList[method](key); &#125; &#125; &#125;; //console.log(eles); return eles;//!!!一定要return，不然stage()调用完的返回值是undefined&#125;;window.$ = stage;/////////////////stage('li')..add_remove_classes(&#123;'blue': true&#125;);等同于：$('li').add_remove_classes(&#123;'blue': true&#125;); JS Bin 通过arguments.length区分获取or设置123456789.css('width') //获取宽度.css('width', '100px') //设置宽度jquery的源码通过arguments.lenth判断是获取or设置if(arguments.length == 1)&#123;//如果只传1个参数 // 获取&#125; else &#123; // 设置&#125; 作业题jQuery的原型（共用属性）是:jQuery.fn123$.fn === jQuery.fn === jQuery.prototype$().__proto__ === $.prototype === jQuery.prototype 12345678910111213141516171819202122232425262728293031$('div').addClass('red') // 可将所有 div 的 class 添加一个 red$('div').setText('hi') // 可将所有 div 的 textContent 变为 hiwindow.jQuery = function(node) &#123; var nodes = &#123; length: 0 &#125;; if (typeof node === 'string') &#123; var temp = document.querySelectorAll(node); for (var i = 0; i &lt; temp.length; i++) &#123; nodes[i] = temp[i]; nodes.length = temp.length; &#125; &#125; nodes.addClass = function(classs) &#123; for (var i = 0; i &lt; nodes.length; i++) &#123; nodes[i].classList.add(classs); &#125; &#125;; nodes.setText = function(text)&#123; for (var i = 0; i &lt; nodes.length; i++) &#123; nodes[i].textContent = text; &#125; &#125;; return nodes;&#125;;window.$ = jQuery;$('div').addClass('red');$('div').setText('hi'); JS Bin]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>笔记</tag>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM基础知识]]></title>
    <url>%2F2018%2F03%2F12%2FDOM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[DOM相关apitextContent与innerText与innerHTML的区别nodeType的值对应什么节点documentFragment性能优化 DOMDocument Object Model,文档对象模型即：把html当做对象来操作 Node节点(元素)相关api获取 元素.childNodes 获取该元素的所有子节点，包括换行形成的text节点。返回一个伪数组 元素.childNodes[0] 元素.children 获取该元素的所有子标签，不包括换行。返回一个伪数组 元素.children[0] 元素.parentNode 与 元素.parentElement 元素.firstChild 与 元素.firstElementChild 元素.lastChild 与 元素.lastElementChild 元素.previousSibling 与 元素.previousElementSibling 元素.nextSibling 与 元素.nextElementSibling 元素.parentNode 与 元素.parentElement 元素.nodeName 与 元素.tagName 返回的是大写的字符串，比如’DIV’,在做if判断时要配合toLowerCase使用 元素.innerHTML 与 元素.innerTEXT 与 元素.textContent123456789101112131415161718192021&lt;footer id="footer"&gt; &lt;p&gt;hello &lt;script&gt;document.write('2014-' + new Date().getFullYear())&lt;/script&gt; world &lt;/p&gt; &lt;/footer&gt;footer.textContent 与 footer.innerText返回结果一样: 'hello document.write('2014-' + new Date().getFullYear()) world'1.textContent会将style标签里的内容当做文本返回，而innerText会忽略style标签里包含的内容2.innerText不会返回display:none的元素的文本，而textContent会--------------------------------footer.innerHTML的返回结果：' &lt;p&gt;hello &lt;script&gt;document.write('2014-' + new Date().getFullYear())&lt;/script&gt;2014-2018 world &lt;/p&gt;' 面试题textContent与innerText的区别123456&lt;div id="test" class="test"&gt;test&lt;div style="display:none"&gt;&lt;span&gt;test&lt;/span&gt;&lt;/div&gt;&lt;style&gt;hi&lt;/style&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var testDiv = document.getElementById('test'); console.log(testDiv.textContent); console.log(testDiv.innerText);&lt;/script&gt; textContent会获取所有元素的内容，包括 &lt;script&gt; 和 &lt;style&gt; 里包含的内容。而innerText不会 textContent会获取display:none的节点的文本；而innerText不会返回隐藏元素的文本 由于 innerText 受 CSS 样式的影响，它会触发回流（reflow），但textContent 不会。 innerHTML获取时，会将包含的标签还原出来123&lt;div id='x'&gt;&lt;p&gt;hello&lt;/p&gt;&lt;/div&gt;x.innerHTML // &lt;p&gt;hello&lt;/p&gt; 设置时，会将标签转成代码1x.innerHTML='&lt;i&gt;hello&lt;/i&gt;' // i标签自动转成斜体 面试题nodeType nodeType=1 元素节点(标签)，例如, nodeType=2 属性节点 比如class=”right” nodeType=3 文本节点 例如p标签里包含的文字 nodeType=8 注释节点 nodeType=9 document文档节点 nodeType=10 文档类型节点 比如html的文档类型是&lt;!DOCTYPE html&gt; nodeType=11 documentFragment文档片段节点12345document.nodeType === Node.DOCUMENT_NODE// truedocument.nodeType === 9// true 面试题documentFragment性能优化查看相关博客 操作DOM ul.appendChild(li) 把li插入ul的末尾内 div1.cloneNode(deep?)浅拷贝 深拷贝 元素.hasChildNodes() 元素是否含有子节点，有的话返回true，换行算作文本节点 ul.insertBefore(li, ul.children[0]) 把新节点插到ul最前面内 div1.isEqualNode(div2) 检查两个元素是否相等 div1.isSameNode(div2) 检查两个元素所有有相同节点。推荐使用div1===div2来代替此方法 ul.removeChild(ul.lastElementChildren) ul.replaceChild(newLi, oldLi) 元素.normalize() // 常规化 document相关api获取 document.body // &lt;body&gt;...&lt;/body&gt; document.children // 伪数组[html] document.documentElement // &lt;html&gt;...&lt;/html&gt; document.domain // “xiedaimala.com” document.origin // “https://xiedaimala.com“ document.head // &lt;head&gt;...&lt;/head&gt; document.images //获取页面中所有的&lt;img&gt;标签。通过document.images.length可以获取&lt;img&gt;标签数量 document.links //获取页面中所有的&lt;a&gt;标签。通过document.links.length可以获取&lt;a&gt;标签数量 document.location document.referrer //引荐人。从哪里跳转到这个页面的 document.title document.onxxxxx //onclick，onmouseover……. 操作document document.getElementById() document.getElementsByClassName() document.getElementsByTagName() document.querySelector() //只获取满足条件的第一个元素 document.querySelectorAll() //返回一个伪数组 document.createDocumentFragment() document.createElement() document.createTextNode() document.write() //紧接着写 document.writeln() //一行一行(line)写 Element相关apihttps://developer.mozilla.org/zh-CN/docs/Web/API/Element 作业题123456var parent = document.getElementById('parent');parent.childNodes.length // 2parent.appendChild(document.createElement('div'));parent.childNodes.length // 请问现在 length 是多少答案：3 12345678910var allDiv = document.querySelectorAll('div')allDiv.length // 假设是 2document.body.appendChild( document.createElement('div') )allDiv.length // 请问现在 length 的值是多少？？？答案：2将最后一段代码改成allDiv = document.querySelectorAll('div') //在使用querySelector方法时，遇到DOM树增加或删除,需要重新获取allDiv.length // 3 上面两题，为什么一个 length 会动态变化，另一个 length 却不会动态变化？ 1.parent.childNodes是动态集合。所谓动态集合就是一个活的集合，DOM树删除或新增一个相关节点，都会立刻反映在NodeList接口之中。2.document.querySelectorAll方法返回的是一个静态集合。DOM的增删，并不会实时反映在该方法的返回结果之中。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>dom</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数Function基础知识]]></title>
    <url>%2F2018%2F03%2F12%2F%E5%87%BD%E6%95%B0Function%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[函数的声明方法函数的调用callthis作用域和闭包 函数声明方法总结 具名函数 1234function fn(x,y)&#123; return x + y;&#125;fn.name // 'fn' 匿名函数 123function (x,y) &#123; return x+y; &#125; var fn=匿名函数 1234var fn = function(x,y) &#123; return x+y;&#125;fn.name // 'fn' var fn=具名函数 1234567891011var fn = function f2(x,y)&#123; return x+y &#125;; fn.name // 'f2' console.log(f2) // f2 is not defined等同于 var fn; fn= function f2(x,y)&#123; return x+y &#125; var fn=new Function() 12345678910111213参数和函数体都以字符串的形式 var fn = new Function('x','y','return x+y') fn.name // "anonymous"面试题：var n = 3;var fn = new Function('x','y','return x+'+n+'+y');问：fn(2,4)的结果是A：9B：2n4C：234答案：9 ES6箭头函数 1234567891011121314151617181920 var fn = (x,y) =&gt; &#123; return x+y &#125;; fn(2,3); // 5如果函数体只有一句话，可以去掉花括号和return： var sum = (x,y) =&gt; x+y; sum(4,5); // 9如果只有1个参数，可以简写为： var fn2 = n =&gt; n*n; fn2(4); // 16箭头函数的复杂写法：var fn = (x,y) =&gt; &#123; const a=x*2; const b=y*3; return a+b;&#125;fn(3,5) // 21 evaleval方法可以将字符串当做代码执行。1eval('alert(1)') // 弹出1 eval方法一般很少会使用到。 函数的调用1234fn(参数1,参数2);等同于fn.call(undefined,参数1,参数2)； this和伪数组argumentsthis就是call的第一个参数fn(参数1,参数2)等同于fn.call(undefined,参数1,参数2)，因此fn(参数1,参数2)的this是undefined12345678910111213'use strict';function fn()&#123; console.log(this); console.log(arguments);&#125;fn.call(1,2,3);// this为1//arguments为伪数组[2,3]fn(1,2,3);//等同于fn.call(undefined,1,2,3)// this为undefined//arguments为伪数组[1,2,3] this相关面试题 this总是代表它的直接调用者(js的this是执行上下文), 例如 obj.fn ,那么fn中的this就是obj 在默认情况(非严格模式下,未使用 ‘use strict’),没找到直接调用者,则this指的是 window (约定俗成) 在严格模式下’use strict’,没有直接调用者的函数中的this是 undefined 使用call,apply,bind(ES5新增)绑定的,this指的是 绑定的对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function f()&#123; console.log(this)&#125;f.call(1)// Number对象&#123;1&#125;function f1()&#123; console.log(this) function f2()&#123;&#125;&#125;var obj = &#123;name: 'obj'&#125;f1.call( obj )//&#123;name: 'obj'&#125;----------function f()&#123; 'use strict' console.log(this)&#125;f.call(1)// 1-------------function f()&#123; console.log(this) //console.log(this === window)&#125;f.call()// window function f1()&#123; function f2()&#123; console.log(this) &#125; f2.call()&#125;var obj = &#123;name: 'obj'&#125;f1.call( obj )//window----------function f()&#123; 'use strict' console.log(this)&#125;f.call()//undefinedfunction f1()&#123; 'use strict'; function f2()&#123; console.log(this) &#125; f2.call()&#125;var obj = &#123;name: 'obj'&#125;f1.call( obj )//undefined call stack普通调用嵌套调用递归调用 作用域面试题最重要的一步：变量提升！！！！！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var a = 1;function f1()&#123; alert(a) // 是多少 var a = 2;// 由于函数内部有变量a了，所以不会访问外部作用域里的a&#125;f1(); //undefined-------------------var a = 1;function f1()&#123; alert(a) // 是多少&#125;f1();// 1f1内部没有变量a，因此会访问全局作用域里的a----------------------------var a = 1;function f1()&#123; var a = 2; //f1的局部a=2 f2();&#125;function f2()&#123; console.log(a) // 是多少&#125;f1(); // 1 由于f2内部没有变量a,因此会访问全局作用域里的a-----------------------------var a = 1;function f1()&#123; a = 2; //由于f1内部没有声明变量a，因此它赋值给的是全局作用域的a，此时全局a=2 f2();&#125;function f2()&#123; console.log(a) // 是多少&#125;f1(); // 2----------------------6个livar lis = document.getElementsByTagName('li');for(var i = 0; i&lt;lis.length; i++)&#123; lis[i].onclick = function()&#123; console.log(i) // 点击第3个 li 时，打印 2 还是打印 6？ &#125;&#125;//最终结果：6打印出来的是for循环结束完之后的i--------------------var改成letfor(let i = 0; i&lt;lis.length; i++)&#123; lis[i].onclick = function()&#123; console.log(i) // 点击第3个 li 时，打印 2 还是打印 6？ &#125;&#125;//最终结果：0,1,2,3,4,5 ES6中的let12345let a = 1;&#123; let a = 2; //这里的a困在花括号内，无法逃到全局作用域里&#125;consolelog(a); // 1 闭包面试题如果一个函数，使用了它外部作用域的变量，那么(这个函数+被使用的变量)就叫做闭包。12345var a = 1;function f1() &#123; console.log(a); //访问了外部的全局作用域的变量a&#125;f1(); // 1 闭包相关面试题 作业题123456789101112var a = console.log(1);a的值是多少？答案:undefined因为console.log的源码是将内容打印出来后，return undefinedalert的源码结尾也是return undefined----------------------function f()&#123; return 1;&#125;var a = f();//a的值是1 逗号表达式逗号表达式的一般形式是：表达式1，表达式2，表达式3……表达式n逗号表达式的求解过程是：先计算表达式1的值，再计算表达式2的值，……一直计算到表达式n的值。最后整个逗号表达式的值是表达式n的值。看下面几个例子：1234567891011var a = (1,2);a的值为2-----------var a = (1, console.log(2));a的值是undefined，因为console.log的返回值是undefinedx=8*2,x*4 /*整个表达式的值为64，x的值为16*/ (x=8*2,x*4),x*2 /*整个表达式的值为128，x的值为16*/ x=(z=5,5*2) /*整个表达式为赋值表达式，它的值为10，z的值为5*/ x=z=5,5*2 /*整个表达式为逗号表达式，它的值为10，x和z的值都为5*/ 12345678910111213141516171819202122232425262728function f()&#123; return function f2()&#123;&#125;&#125;var a = f();//a的值是函数f2---------------function f()&#123; return function f2()&#123;&#125;&#125;var a = f();var b = a();等同于 var b = f.call().call()又等同于 var b = f()(); //前一个括号调用后返回一个函数；后一个括号执行返回的这个函数//a的值是函数f2//b的值是undefined,f2没有写ruturn，则默认return undefinedf2();//f2 is not defined，因为f2无法单独执行，必须要通过f()才能执行f2function f()&#123; return function f2()&#123; return 'hello' &#125;&#125;var b = f.call().call();等同于 var b = f()(); //前一个括号调用后返回一个函数；后一个括号执行返回的这个函数//b的值为'hello' 1234567891011121314function f1()&#123; console.log(this) // 第一个 this function f2()&#123; console.log(this) // 第二个 this &#125; f2.call()&#125;var obj = &#123;name: 'obj'&#125;f1.call( obj )//第一个this为&#123;name: 'obj'&#125;//第二个this为window，在'use strict'模式下为undefined第一个this对应的call是f1.call(obj)第二个this对应的call是f2.call();]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组Array基础知识]]></title>
    <url>%2F2018%2F03%2F09%2F%E6%95%B0%E7%BB%84Array%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[数据类型new与不new的区别伪数组数组api查看Array对象公共属性 基本数据类型new不new的区别new String(x)和String(x)的区别 123456String(1) //"1" 变成字符串String(false) // 'false'String(null) // 'null'new String(1) // String &#123;"1"&#125; 变成String对象new String('sss') // String &#123;"sss"&#125; new Number(x)和Number(x)的区别 12345678910Number('3') //3 变成数字Number('sss') //NaN NaN也是数字类型Number(true) //1Number(false) //0Number(null) //0Number(undefined) //NaNnew Number('123') //Number &#123;123&#125; 变成Number对象new Number(111) //Number &#123;111&#125; 复杂数据类型new不new的区别new OBject(x)和Object(x)的区别【没区别】1234567891011Object(1) // Number &#123;1&#125; 传入数字则变成Number对象new Object(1) // Number &#123;1&#125; 与上面没区别Object('sss') // String &#123;"sss"&#125; 传入字符串则变成String对象new Object('sss') // String &#123;"sss"&#125;Object() //&#123;&#125; 什么都不传就是空对象new Object() //&#123;&#125;Object(false) // Boolean &#123;false&#125; 传入布尔值则变成Boolean对象new Object(false) // Boolean &#123;false&#125; 数组Array12345678910111213var arr = Array(3) // [undefined,undefined,undefined] 【生成length为3，每个值都是undefined的数组】arr[0] //undefinedarr[1] //undefinedarr[2] //undefined'0' in arr //false 从内存图可以看出，在地址99的数据里只有length和__proto__'length' in arr //true'__proto__' in arr //truearr.__proto__ == Array.prototype //arr是由Array构造的，所以它的__proto__指向Array的公用属性 //true 生成的数组的__proto__指向Array的公用属性(原型prototype)//这个公用属性中有push方法、shift方法等 1234567var arr = Array(3) // [undefined,undefined,undefined] 1个参数时表示生成长度为length、每一项的值为undefined的数组var arr = Array(3,3) // [3,3] 多于1个参数时，表示每一项的值var arr = new Array(3) 跟不加 new 一样的效果var arr = new Array(3,3) 跟不加 new 一样的效果 函数Function1234567891011var fn1 = function (a,b) &#123; return a+b;&#125;;fn1(5,9);// 14--------var fn2 = Function('a','b','return a-b');//参数和方法体都写成字符串的形式等同于var fn2 = new Function('a','b','return a-b');//加不加new都一样fn2(10,3) //7 总结 new不new的区别 基本数据类型不加new 则返回基本类型 1String(1) // '1' 基本数据类型加new 则返回一个对象 1new Number('123') //Number &#123;123&#125; 变成Number对象 复杂数据类型加不加new都一样 12Object('sss') // String &#123;"sss"&#125; 传入字符串则变成String对象new Object('sss') // String &#123;"sss"&#125; 伪数组 arguments 对象是伪数组 document.querySelectAll(‘div’) 返回的对象是伪数组上面两个有以下这些特征: 1.有 0:xx,1:xx,2:xx,3:xx…n:xx,length:xx 这些 key 的对象2.他们的proto不链接到数组的公用属性Array.prototype，即他们的原型链中没有Array.prototype 这样的对象就是伪数组12345678function fn() &#123; console.log(arguments)&#125;fn(1,3,5,7);//arguments有0,1,2...,length这些key,但是它的__proto__没有指向Array的公用属性Array.prototype，而是指向Object.prototypefn.push(9) // 报错，伪数组没有数组的api instanceof判断是不是数组instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。换句话说，instanceof用来测试一个对象的proto是否指向构造函数(Array,Function,Object等)的共有属性(prototype)1234567var arr = [1,2,3];arr instanceof Array; //truearr instanceof Function; //false//伪数组的原型链中没有Array的prototype属性var lis = document.querySelectorAll('li');lis instanceof Array;//false 数组的操作(api) 数组就是数据的有序集合 数组就是原型链中有 Array.prototype 的对象 遍历数组获取value和index用forEacharr.forEach(function (value,index) {执行函数体/return 返回值});forEach只用来操作数据,没有return返回值map可以有返回值 forEach的用法与map方法一致,接受三个参数：value、index、整个数组。123456789101112131415161718var colors = ['red', 'green', 'blue'];colors.forEach(function (value,index) &#123; console.log(value);&#125;);//箭头函数写法：colors.forEach((value,index) =&gt; console.log(value));// red// green// blue-------var colors = ['red', 'green', 'blue'];colors.forEach(function (value,index) &#123; console.log(index + ':'+ value);&#125;);//0:red//1:green//2:blue forEach的原理： 排序sort sort用的快速排序 默认的sort会将数字先转成字符串，再按照字典顺序进行从小到大排序，所以会有bug 1234567891011['d', 'c', 'b', 'a'].sort()// ['a', 'b', 'c', 'd'][4, 3, 2, 1].sort()// [1, 2, 3, 4][11, 101].sort()// [101, 11] 先比较最前面的数，都是1，再比较第二位数，js误以为101小于11[10111, 1101, 111].sort()// [10111, 1101, 111] 先比较最前面的数，都是1；再依次比较后几位数，有bug 如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。 123456789101112从小到大排序a-b[10111, 1101, 111].sort(function (a, b) &#123; return a - b;&#125;)// [111, 1101, 10111]--------从大到小排序b-a[10111, 1101, 111].sort(function (a, b) &#123; return b - a;&#125;)[10111, 1101, 111] 根据给定的依据进行排序 1234567891011var students = ['小明','小红','小花']; var scores = &#123; 小明: 59, 小红: 99, 小花: 80 &#125;;students.sort(function(a,b) &#123; return scores[a]-scores[b]; //按照scores从小到大排序&#125;);//["小明", "小花", "小红"] students.sort(function(a,b) &#123; return scores[b]-scores[a];//按照scores从大到小排序&#125;);//["小红", "小花", "小明"] 123456789101112[ &#123; name: "张三", age: 30 &#125;, &#123; name: "李四", age: 24 &#125;, &#123; name: "王五", age: 28 &#125;].sort(function (o1, o2) &#123; return o1.age - o2.age;&#125;)// [// &#123; name: "李四", age: 24 &#125;,// &#123; name: "王五", age: 28 &#125;,// &#123; name: "张三", age: 30 &#125;// ] join 数组变字符串join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。12345var a = [1, 2, 3, 4];a.join(' ') // '1 2 3 4'a.join('xx') // "1xx2xx3xx4"a.join() // "1,2,3,4" 数组变字符串更简单的办法：1234var a = [1, 2, 3, 4];a+''; // "1,2,3,4"a+'3'; // "1,2,3,43" cancat连接多个数组concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。1234567891011['hello'].concat(['world'])// ["hello", "world"]['hello'].concat(['world'], ['!'])// ["hello", "world", "!"][].concat(&#123;a: 1&#125;, &#123;b: 2&#125;)// [&#123; a: 1 &#125;, &#123; b: 2 &#125;][2].concat(&#123;a: 1&#125;)// [2, &#123;a: 1&#125;] concot用来复制一个数组，由于concat返回的是一个新数组，因此虽然复制原数组，但两者不相等123var a = [1,2,3];var b = a.concat([]); // b = [1,2,3]a == b; // false 数组相加数组的相加，先将每个数组转变成字符串，然后连接起来1[1,2,3]+[4,5,6] // "1,2,34,5,6" mapmap方法将数组的所有value依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。原数组不变forEach没有返回值，map有返回值1234567891011121314151617181920var numbers = [1, 2, 3];var newNum = numbers.map(function (value) &#123; return value + 1;&#125;);newNum; // [2,3,4]numbers; // [1, 2, 3] 原数组不改变上面代码中，numbers数组的所有成员依次执行参数函数，运行结果组成一个新数组返回，原数组没有变化。------------也可以像forEach一样依次for循环执行numbers.map(function (value) &#123; console.log(value + 3);&#125;);// 4// 5// 6 map有三个参数：value、index和数组本身。1234[1, 2, 3].map(function(value, index, arr) &#123; return value * index;&#125;);// [0, 2, 6] 用箭头函数=&gt;可以简写为：12var arr = [2,3,4];arr.map(value =&gt; value+3); // [5, 6, 7] map方法还可以返回包含对象的数组12345678var arr = [2,3,4];arr.map(function(value,index)&#123; return &#123; '下标':index,'值':value &#125;&#125;);// [ &#123;下标: 0, 值: 2&#125;, &#123;下标: 1, 值: 3&#125;, &#123;下标: 2, 值: 3&#125; ] filter筛选出filter方法对数组中的每一项进行筛选出，满足条件的value组成一个新数组返回。 它的参数是一个函数，所有数组value依次执行该函数，返回结果为true的value组成一个新数组返回。 该方法不会改变原数组。 1234[1, 2, 3, 4, 5].filter(value =&gt; &#123; return (value &gt; 3); //结果为true的value组成一个新数组返回&#125;)// [4, 5] filter方法可以接受三个参数：value，index和整个数组。1234[1, 2, 3, 4, 5].filter((value, index, arr) =&gt; &#123; return index % 2 == 0;&#125;);// [1, 3, 5] 过滤falsy值123var arr = [1,2,'',4,0,undefined];var newArr = arr.filter(v=&gt;v)//newArr===[1, 2, 4] 先filter过滤再用map操作12345678var a = [1,2,3,4,5,6,7,8,9];a.filter(nfunctio(value)&#123; return value &gt; 5;&#125;).map(function(value)&#123; return value*2;&#125;)// [12, 14, 16, 18] 压缩累计reduce,reduceRightreduce方法和reduceRight方法依次处理数组的每个value，最终压缩累计为一个值。它们的差别是，reduce是从左到右处理（从第一个value到最后一个value），reduceRight则是从右到左（从最后一个value到第一个value），其他完全一样。 用reduce方法可以可以简化用for循环来累计的运算(比如求数组之和)12345678910var arr = [1, 2, 3, 4, 5];arr.reduce(function (sum, value) &#123; console.log(sum, value); return sum + value;&#125;, 0) //默认初始值为0,可以省略不写// 1 2// 3 3// 6 4// 10 5//最后结果：15 用箭头函数=&gt;简化：12arr.reduce((sum,value) =&gt; sum+value,0);//初始值为0//最后结果：15 reduce可以设置初始值1234[1, 2, 3, 4, 5].reduce(function (a, b) &#123; return a + b;&#125;, 10); // 从10开始累加// 最后结果：25 计算所有奇数之和：123456var a = [1,2,3,4,5,6,7,8,9];a.reduce( function(sum,value) &#123; value = value%2 == 0 ? 0 : value; return sum + value;&#125;,0) reduce替代map设置初始值为空数组[]12345678var arr = [2,3,4];将数组里的每一项乘以2，然后返回一个新数组arr.reduce(function(sum, value) &#123; sum.push(value*2); //push到初始值内 return sum;&#125;,[]) //初始值是个空数组// [4, 6, 8] reduce替代filter设置初始值为空数组[]12345678910var arr = [1,2,3,4,5,6,7,8,9];用reduce过滤出所有的偶数，然后返回新数组arr.reduce(function(sum,value)&#123; if(value%2==0)&#123; sum.push(value); &#125; return sum&#125;,[])// [2, 4, 6, 8] 数组中是否含有某个值顺带一提，字符串用str.indexOf(value)来判断是否含有某个字符123'abcde'.indexOf('c') // 2'abcde'.indexOf('f') // -1'abcde'.indexOf('bcd') // 1 arr.includes()语法：arr.includes(value [,startIndex])123[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, NaN].includes(NaN); // true Jquery的$.inArray()方法语法:$.inArray( value, array [, startIndex ] )123var arr = [1,2,'hi',3,'world'];console.log( $.inArray( 'hi', arr) ) // 2 说明'hi'在arr的第2位console.log( $.inArray( 5, arr) ) // -1 说明arr中没有数字5 every()arr.every((item,index) =&gt; {}) 方法用于检测数组所有元素是否都符合指定条件,所有符合则返回true，只要有一个不符合就返回false 123456let ages = [32, 33, 16, 40];ages.every(age =&gt; age&gt;18);//false//对象中的数组let obj = &#123;a: [&#123;b:1&#125;, &#123;b:2&#125;] &#125;；obj.a.every(item =&gt; item.b &gt; 0);//true some()some() 方法用于检测数组中的元素其中1个是否有满足指定条件，只要有一个元素满足条件，则表达式返回true 12let ages = [3, 10, 18, 20];ages.some(age =&gt; age&gt;18);//true find()返回数组中符合条件的第一个元素的值,如果没有符合条件的元素则返回 undefined12345678let arr = [12,1,5,99,6];arr.find( item =&gt; item&gt;13 );//99const x = arr.find( item =&gt; item&gt;13 );//如果数组中没有元素大于13，则返回undefinedif(x)&#123; //doSomething;&#125; findIndex()返回数组中符合条件的第一个元素的位置，如果没有则返回-11234567891011let arr = [12,1,5,99,6];arr.findIndex( item =&gt; item&gt;13 );//3arr.findIndex( item =&gt; item == 1 );//1类似于arr.forEach((item,index) =&gt; &#123; if(item &gt; 10) &#123; console.log(index); &#125;&#125;)//0,3 删除具体某个值123456789var arr = ["George", "John", "James", "Adrew", "Martin"];//替换arr.splice( arr.indexOf( 'James' ), 1, 'Tom' );arr;//["George", "John", "Tom", "Adrew", "Martin"]//删除arr.splice( arr.indexOf( 'Adrew' ), 1);arr;//["George", "John", "Tom", "Martin"]]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 jquery知识点补充]]></title>
    <url>%2F2018%2F03%2F07%2Fjquery%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[jquery相关知识点补充 production，development版本的区别production生产版，代码经过混淆压缩，用在生产环境(放在服务器上给客户用)development开发版，原始未混淆压缩的代码，给自己用 jQuery的原型jQuery的原型（公共属性）是:$.fn1$.fn = jQuery.fn = jQuery.prototype 点击导航缓动到相应位置12345678910111213141516 &lt;nav style="position: fixed;top: 0;"&gt; &lt;a href="#a"&gt;a&lt;/a&gt; &lt;a href="#b"&gt;b&lt;/a&gt; &lt;a href="#c"&gt;c&lt;/a&gt;&lt;/nav&gt; &lt;div id="a" style="width: 100px;height: 100px;background: green;margin-top: 500px;"&gt;aaaa&lt;/div&gt; &lt;div id="b" style="width: 100px;height: 100px;background: green;margin-top: 500px;"&gt;bbb&lt;/div&gt; &lt;div id="c" style="width: 100px;height: 100px;background: green;margin-top: 500px;margin-bottom: 500px;"&gt;ccc&lt;/div&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; $('a').click(function(event) &#123; event.preventDefault(); var eleId = $(this).attr('href'); $('html,body').animate(&#123;scrollTop: $(eleId).offset().top&#125;, 800); &#125;);&lt;/script&gt; addClass(function(index){})根据条件，将数组中的class按需添加1234var colors = ['red', 'yellow', 'blue', 'green'];$('li').addClass(function(i)&#123; return colors[i];&#125;); JS Bin 面试题123&lt;div id=x&gt;&lt;/div&gt;var div = document.getElementById('x')var $div = $('#x') 请说出 div 和 $div 的联系和区别。12345678910div 和 $div 的联系是：把 div 变成 $div ： $(div)把 $div 变成 div : 由于$div是一个伪数组，所以要取得他，需要用get()从数组中取出来$(div).get(0) 或者简写为$(div)[0]div 和 $div 的区别是：$div是JQuery对象，可以使用jq的api。而div是DOM对象，可以使用DOM的api两者可以调用的属性和方法不一样 removeClass()移除元素的所有classremoveClass()没有参数则移除所有class12$('div').removeClass();//如果不传入参数，则默认将div的所有class移除 或者使用removeAttr(&#39;class&#39;)12$('div').removeAttr('class');//移除div的class属性 触发器trigger123$('btn1').click(function()&#123; $('#div1').trigger('click'); // 触发#div1的click事件&#125;) transitionend过渡完成后执行某个函数transitionend事件该事件在 CSS 完成过渡后触发。12var $div1 = $("#div1");$div1.on('transitionend', fn); animationend动画结束后执行某个函数animationend事件该事件在 CSS 动画结束播放时触发1$div1.on("animationend", fn); animationiteration 该事件在 CSS 动画重复播放时触发animationstart 该事件在 CSS 动画开始播放时触发 return false取消冒泡和默认行为http://www.berlinix.com/js/jquery-return-false.php http://caibaojian.com/javascript-stoppropagation-preventdefault.html return false实际完成了3件事：1.event.preventDefault() //阻止默认行为 event.stopPropagation() //阻止冒泡 停止回调函数执行并立即返回。 点击页面其他地方关闭弹出层1234567891011121314$('#btn').click(function() &#123; $('#popover').show(); $(document).one('click', function() &#123; //在click事件里，给父级加上了另一个事件，这个事件会被立刻执行，因此需要给wrapper阻断冒泡，让它在被点击时才执行 console.log(1); //只有弹出层show出来后，才会触发document的click事件，且只触发一次 $('#popover').hide(); &#125;);&#125;);//document的click事件加在了btn函数内部，它会在冒泡阶段直接执行，即使不点击document也会直接执行因此需要阻断冒泡$('#wrapper').click(function(ev) &#123; ev.stopPropagation();&#125;); .on()向动态创建的子元素添加事件处理程序$(&#39;&#39;).on(&#39;click&#39;,未来的子元素,function)向未来的子元素添加事件处理函数1234567$("ul").click(function()&#123; $("&lt;li&gt;创建li&lt;/li&gt;").insertAfter("ul");&#125;);$("ul").on("click","li",function()&#123; $(this).hide(); //给动态创建的li绑定事件处理函数&#125;); http://www.runoob.com/try/try.php?filename=tryjquery_event_on_newel]]></content>
      <categories>
        <category>jq</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数、原型和原型链]]></title>
    <url>%2F2018%2F03%2F05%2F%E5%AF%B9%E8%B1%A1%2C%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%2C%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[var n=1; 与 var n=new Numer(1)的区别全局函数(构造函数)原型(prototype)和原型链对象.proto === 构造了它的全局函数.prototype (新创建的对象由对应的全局函数构造得来)全局函数.proto === Function.prototype（全局函数都是由Function构造出来的）全局函数.prototype.proto === Object.prototype （全局函数的共有属性从Object的共有属性中引用）Object.prototype.proto === null （Object的共有属性引用至null）原型 === 共有属性 === prototype原型链：顺着proto组成的链子一直往下走，直到proto 为 null 全局函数(构造函数)全局函数都是由Function构造的，因此全局函数.proto === Function.prototypeFunction.proto === Function.prototype1.Number12var n = new Number(1) 创建一个 Number 对象var n = 1 与 var n = new Number(1) 的区别是什么？看内存图 2.String12var s = new String('hello') 创建一个 String 对象'hello' 与 new String('hello') 的区别是什么？看内存图 3.Boolean12345678var b = new Boolean(true) 创建一个 Boolean 对象true 与 new Boolean(true) 的区别是什么？看内存图var a = false;var b = new Boolean(false);if(a)&#123;console.log(1)&#125;if(b)&#123;console.log(2)&#125; 结果是2，因为b是个对象 4.Object1234var o1 = &#123;&#125;var o2 = new Object()o1 和 o2 的数据没区别但是o1不等于o2，因为他们两个在Stack区的地址不同 原型和原型链原型 === 共有属性 === prototype原型链：顺着proto组成的链子一直往下走，直到proto 为 null12345678910111213创建一个对象后的原型链var arr = [1,2,3];arr.__proto__ === Array.prototype //新创建的对象由对应的全局函数构造arr.__proto__.__proto__ === Object.prototypearr.__proto__.__proto__.__proto__ === null所以它的原型链是：arr --&gt; Array.prototype --&gt; Object.prototype --&gt; null全局函数的原型链Array.__proto__ === Function.prototype //全局函数由Function构造Array.__proto__.__proto__ === Object.prototypeArray.__proto__.__proto__.__proto__ === null所以它的原型链是：Array.prototype --&gt; Function.prototype --&gt; Object.prototype --&gt; null 隐藏的公用属性(prototype)所有对象都有 toString 和 valueOf 属性，那么我们是否有必要给每个对象一个 toString 和 valueOf 呢？ 明显不需要。 JS 的做法是把 toString 和 valueOf 放在一个对象里（Object.prototype） 然后让每一个对象有1个隐藏的 proto 存储这个「公用属性组成的对象」的地址。 Object的proto指向Function.prototype12345var obj =&#123; name: 'stage', age: 24&#125;;console.log(obj);//&#123;name: "stage", age: 24&#125; 以及隐藏的__proto__指向Function.prototype 重点公式123456789101112131415161718192021222324252627282930313233var 对象 = new 全局函数() //全局函数包括Number(123)、String('123')/Function()等对象.__proto__ === (构造了它的)全局函数.prototype //.__proto__用来存原型(prototype)的地址，从而引用prototype的数据//__proto__是对象的属性//prototype是函数的属性//对象的__proto__指向函数的prototype比如：var num = new Number(1);num.__proto__ === Number.prototype; //num由Number构造生成//创建的num，它的隐藏的__proto__指向【Number】的公用属性Number.prototypenum.__proto__.__proto__ === Object.prototype; //创建的num，它隐藏的__proto__指向Number.prototype,Number.prototype.的隐藏__proto__继续指向Object的公用属性Object.prototype----------obj.toString === Object.prototype.toString //对象的toString方法，实际上是调用了Object的公用属性(prototype)的toString方法-----------var fn = new Function() fn.__proto__ === Function.prototype //fn由Function构造生成 由于Function的是由Function构造的，所以Function.__proto__ === Function.prototype 也就是说，Function.__proto__指向它本身的prototype-------------Object的_proto_指向Function.prototypeObject.__ptoto__ === Function.prototype，因为 Function 是 Object 的构造函数。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js类型转换，内存图，数据的引用，垃圾回收，深拷贝vs浅拷贝]]></title>
    <url>%2F2018%2F03%2F05%2Fjs%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[js类型转换的方法6个falsy值内存图数据的引用垃圾回收深拷贝vs浅拷贝 转成字符串String(x)String(x)是一个window的全局方法 x.toString()null和undefined没有.toString()方法 12345671.toString() //报错解析器不知道第一个点应该理解成小数点，还是应该理解成调用方法，因此报错1..toString() // '1' 第一个点表示小数点，第二个点表示调用方法1.0.toString() // '1'1 .toString() // '1'(1).toString() // '1' x + ‘’ 与空字符串相加这种方法比较简便，推荐用这种方法转成字符串 转成布尔值Boolean(x)注意!空对象是true !!x 转成数字Number(x)123456Number('3') //3 变成数字Number('sss') //NaN NaN也是数字类型Number(true) //1Number(false) //0Number(null) //0Number(undefined) //NaN parseInt(x)parseInt(&#39;123&#39;) 面试题1234567var a = 011; // a=9 js看到0开头默认转成8进制parseInt('011') // 11 【默认转成10进制】parseInt('011',8) // 9parseInt('s') // NaNparseInt('1s') // 1 parseFloat(x)parseFloat(3.14) x - 0 推荐这种12'123'-0 // 123'3.14'-0 // 3.14 +x 取正12+ '-1' // -1+ '3.14' // 3.14 6个falsy值0、NaN、空字符串、false、null、undefined 所有对象的falsy值都是true12345var a = false;var b = new Boolean(false);if(a)&#123;console.log(1)&#125;if(b)&#123;console.log(2)&#125; 结果是2，因为b是个对象 !注意:{}是true值，因为{}是空对象，所有对象都是true！！ 内存图 JS 引擎将内存分为代码区和数据区 我们只研究数据区 数据区又分为 Stack区（栈内存） 和 Heap区（堆内存） 简单类型的数据直接存在 Stack栈内存 里 复杂类型(object)把地址存到 Stack栈内存 区，把地址对应的数据存到 Heap堆内存 区 o2 = o;并不是修改了o2在Heap的数据，而是将o2的地址修改成o的地址，因此2访问o对应的数据 面试题-对象的引用12345678默认已经变量提升var a = &#123;name: 'a'&#125; //先在Heap区生成数据，然后在Stack区生成a的Address指向对应的数据var b = a // 将a的地址赋给b，而不是将a的数据赋值给bb = &#123;name: 'b'&#125; //在Heap区生成新的数据，然后生成b的地址指向对应的数据请问现在 a.name 是多少？ // 'a' a的地址没变，仍旧指向a的数据b = &#123;name:'b'&#125;并不会修改Heap区的数据，而是声明一个新的数据，然后Stack区的地址修改为新声明的数据对应的地址 12345默认已经变量提升var a = &#123;name: 'a'&#125; // 先在Heap区生成数据，然后在Stack区生成a的Address指向对应的数据var b = a // 将a的地址赋给b,此时b指向a的地址对应的数据b.name = 'b' // 修改a的地址对应的数据请问现在 a.name 是多少？ // 'b' 1234var a = &#123;name: 'a'&#125;var b = ab = null // null是简单类型，所以直接将b的STack区修改为null请问现在 a 是什么？ // &#123;name: 'a'&#125; 1234567var a = &#123;n:1&#125;; // heap区生成数据34，a生成地址34指向数据34var b = a; // b的地址也是34a.x = a = &#123;n:2&#125;; //此时最前面a.x是地址34的x// a.x等于地址a，即 34里的x = 新地址54【因为后面a在heap区生成了数据54&#123;n:2&#125;】alert(a.x);// --&gt; undefined 这里的a已经变成地址54了，54里的x是undefinedalert(b.x);// --&gt; [object Object] 由于b指向34,而34里的x = 新地址54 面试题-垃圾回收如果一个对象没有被引用(就是说没有地址指向它)，它就是垃圾，将会被回收 12345678910111213141516var fn = function ()&#123;&#125;;document.body.onclick = fn;fn = null;请问fn是垃圾吗？不是。一开始fn的Stack区是地址110,110指向数据fndocument是个复杂类型，所以Stack区存的地址222数据222里的body也是个复杂类型，所以body存的是地址333333里的onclick指向一开始声明的fnfn=null，null是简单类型，因此fn的Stack区更改为null虽然fn=null，但是fn被onclick引用，而onclick被body引用，body被document引用因此fn不是垃圾document.body.onclick = fn;此时fn是垃圾,因为没有东西引用它 浅拷贝vs深拷贝1234567891011121314151617181920212223var a = 1;var b = a;b = 2;//这个时候改变bconsole.log(a);// 1 【a 完全不受 b 的影响】把a赋值给b，当b改变时，a依然不变，这就是深拷贝对于简单类型的数据来说，赋值就是深拷贝。对于复杂类型的数据（对象）来说，才要区分浅拷贝和深拷贝。----------对象的浅拷贝：var a = &#123;name:'stage'&#125;; //复杂类型var b = a; // b的地址就是a的地址，因此指向a的数据b.name = 'xxx'; //修改a的地址对应的数据console.log(a.name) // 'xxx' 把a赋值给b(复杂类型的赋值只是将Stack区的地址进行了拷贝)，当b改变时，a也改变，这就是浅拷贝对象的深拷贝：var a = &#123;name: 'frank'&#125;var b = deepClone(a) // deepClone 还不知道怎么实现b.name = 'b'a.name === 'a' // true对象的深拷贝就是对 Heap 区进行完全的拷贝。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js里的数据类型]]></title>
    <url>%2F2018%2F03%2F03%2Fjs%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数字number字符串string布尔值booleanundefined未定义null符号symbol对象object js里的7种数据类型 number 数字 string 字符串 boolean 布尔值 symbol 符号 undefined null object 对象(数组array和函数function都是对象) typeof返回的都是字符串类型xxx 的类型stringnumberbooleansymbolundefinednullobjectfunctiontypeof xxx‘string’‘number’‘boolean’‘symbol’‘undefined’‘object’‘object’‘function’ number数字 整数和小数：1 1.1 .1 科学记数法：1.23e2 //123【表示1.23乘以10的2次方】 二进制：0b11 //3 【以0b开头的，js默认为二进制】 八进制：011（后来 ES5 添加了 0o11 语法）//3 【以0开头的默认为8进制】 十六进制：0x11 //17 【以0x开头的默认为16进制】 string字符串 空字符串：&#39;&#39; //空字符串的length=0 字符串换行： 12var s = `1234567890`; // 含换行符号,所以s.length=11 符号转义 1234567var s = '\''; // 'var s = '\n' // 回车var s = '\t' // tabvar s = '\\' // \ 用转义符转义斜杠 boolean布尔值 a &amp;&amp; b 与运算 a || b 或运算 null空对象,undefined非对象空值 如果想声明一个对象，但暂且不赋值，用null表示空对象var obj = null 非对象声明，但暂且不赋值，用undefined(但是实际上你直接 var xxx 一下就行了)1234var notObj = undefined;简写为var notObj; object对象基本对象123456789101112var 王花花 = &#123; age: 18, gender: 'female', height: 168, weight: 57, married: true&#125;;王花花.age // 18等同于 王花花['age']王花花.gender // fenale等同于 王花花['gender'] 复杂对象12345678910111213141516var x = &#123; a: 1, b: 2, c: &#123; c1: 3, c2: 4, c3: &#123; d1: 5, d2: 6 &#125; &#125;&#125;;x.c // &#123;c1: 3, c2: 4&#125;x.c.c1 // 3x.c.c3.d2 // 6 对象的格式1234567891011121314151617var obj = &#123; 9a: 'hello' //报错，key不加引号，则命名需要按照变量名的命名规则，不能以数字开头&#125;; var obj = &#123; '9a': 'hello' //9a加上单引号就不报错了&#125;;-----------------var obj = &#123; '': 'hello' //空字符串可以作为key&#125;obj[''] // hellovar obj = &#123; 名字: '王花花' //可以用中文作为key名，因为在变量名的命名规则中，中文命名是合法的&#125; 操作对象12345678910111213141516171819var obj = &#123; a: 1, b: 2, c: 3&#125;;删除 delete obj.a;等同于delete obj['a'];某1个key是否存在'a' in obj;//true遍历对象for (var key in obj) &#123; console.log(key); // a,b,c console.log(obj[key]); //1,2,3&#125; 对象的相等情况1234567var a = [1,2,3];var b = [1,2,3];a===b // false,因为a和b指向不同的Addressvar a = [1,2,3];var b = a;a===b //true,因为上一步a将自己的Address赋给了b typeof与instanceofinstanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。123var arr = [1,2,3];arr instanceof Array; //truearr instanceof Number; //false]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js和npm]]></title>
    <url>%2F2018%2F03%2F02%2FNode-js%E5%92%8Cnpm%2F</url>
    <content type="text"><![CDATA[node.js的常用命令npm的配置及使用 Node.js从官网下载node.jsshift + 鼠标右键，选择在此处打开命令窗口 Node.js相关命令 where node ：查看node.exe的安装路径 where npm ：查看npm安装路径 node -v：查看版本号 npm -v exit：退出 npm list -g --depth=0 查看所有全局安装 npm cache clean --force清除本地缓存 npmnpm常用命令及使用步骤：https://www.cnblogs.com/wdlhao/p/5900360.htmlnpm 常用命令详解：https://www.cnblogs.com/itlkNote/p/6830682.html 升级npm:npm i npm -g 配置npm123456789101112131415npm get registry //查看当前镜像，官方https://registry.npmjs.org/npm config set registry https://registry.npm.taobao.org/npm config set loglevel http //显示所有http请求npm config delete loglevel //删除这个配置npm config set progress falsenpm config set strict-ssl false---------------npm config，可以看到config可以简写为c所以上面的4句话可以简写为npm c set registry https://registry.npm.taobao.org/npm c set loglevel httpnpm c set progress falsenpm c set strict-ssl false npm 的配置被存储在 ~/.npmrc，你可以随时通过npm c edit查看修改。 安装模块在使用node的时候，用npm安装了很多软件，过一段时间没有使用就会忘记，怎么查看自己全局安装过的包，用命令npm list -g --depth 0 http-server安装：npm i http-server -g(默认安装在C:\Users\Administrator\AppData\Roaming\npm\node_modules) 然后就可以使用 http-server 或者 hs 来启动http-server了ctrl + C退出http-server 卸载：npm uninstall http-server -g，简写npm un http-server -g http-server的使用: 输入 hs 文件路径 参数 启用，默认localhost:8080如果直接 hs -c-1 就是在当前目录启用,禁止缓存,自动打开浏览器如果hhs D:\饥人谷\resume -c-1 -o 就是在指定的路径启用,禁止缓存,自动打开浏览器 如果想改变端口和地址采用这个方式：http-server &lt;文件路径&gt; -a hostip -p 端口号。参数-a是监听地址，而参数-p是修改监听端口。 -o 启动服务器后打开浏览器窗口-c 设置缓存控制max-age头的缓存时间（以秒为单位），例如-c10 10秒（默认为’3600’）。要禁用缓存，请使用-c-1，因为有时候修改代码后重启服务页面不一定立刻生效，所以禁用缓存-p 要使用的端口（默认为8080）-a 要使用的地址（默认为0.0.0.0）-d 显示目录列表（默认为“True”）-s或--silent从输出中抑制日志消息:这个意思就是你输入之后，日志消息不会显示 hs -h查看帮助 less安装:npm i less -g lessc -h:查看帮助 lessc -v:查看版本号 lessc /xxx/a.less &gt; /yyy/b.css 使用nrm切换镜像仓库github:nrm 安装nrmnpm i -g nrm 使用nrm nrm ls:查看有哪些镜像仓库 nrm test：测试速度 nrm use taobao：使用taobao镜像]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js获取数组中的最大值的方法]]></title>
    <url>%2F2018%2F02%2F28%2Fjs%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[var arr = [5,1,3,8,3,4];var max = Math.max(…arr); 12345678910111213max = Math.max(1,32,45,31,3442,4);max = Math.max.apply(null,arr); max = Math.max(...arr);//最简单的方法max = Math.max.call(null,7,2,0,-3,5); max = arr.sort().reverse()[0]; max = arr.sort(function(a,b)&#123; return b-a;&#125;)[0]; 1.Math.max()法12var max = Math.max(1,32,45,31,3442,4);console.log(max) apply()法1234在ES5中，使用Math.max函数的apply方法获取数组最大值使用null作为参数var arr = [7,2,0,-3,5];var max = Math.max.apply(null,arr);console.log(max) Math.max(…arr);1234在ES6中, 我们使用展开运算符...作为函数的参数var arr = [7,2,0,-3,5];var max = Math.max(...arr);console.log(max); 2.call()法12var max = Math.max.call(null,7,2,0,-3,5)console.log(max) 3.sort()+reverse()后，获取第0个1234var arr = [7,2,0,-3,5];//sort()排序默认为从小到大，reverse()将数组反转var max = arr.sort().reverse()[0];console.log(max); 4.sort()b-a后获取第0个123456var arr = [7,2,0,-3,5];//b-a从大到小，a-b从小到大var max = arr.sort(function(a,b)&#123; return b-a;&#125;)[0];console.log(max)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习canvas]]></title>
    <url>%2F2018%2F02%2F28%2Fcanvas%2F</url>
    <content type="text"><![CDATA[基本语法12345678910111213&lt;canvas width="300" height="300" id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; var canvas = document.getElementById('canvas'); var ctx = canvas.getContext('2d');//获取canvas的2d上下文 //必须先给颜色，再画图，顺序不能错！！！ ctx.fillStyle = 'red';//填充色 ctx.fillRect(10, 10, 100, 100);//在(10,10)处画一个100x100的填充矩形(fillRect) ctx.strokeStyle = 'red';//描边色 ctx.strokeRect(50, 50, 100, 100);//描边矩形&lt;/script&gt; 【点击查看代码】 设置画布高度canvas设置宽高时，由于它是inline元素，所以先要设置display:block或者vertical-align: top;然后修改它的属性宽高，而不是css的宽高12345#canvas&#123; display: block; 或者 vertical-align:&#125; 12345var canvas = document.getElementById('canvas');var cw = document.documentElement.clientWidth;var ch = document.documentElement.clientHeight;canvas.width = cw;canvas.height = ch; 画个矩形12345ctx.fillStyle = 'red';//填充色ctx.fillRect(10, 10, 100, 100);//在(10,10)处画一个100x100的填充矩形(fillRect)ctx.strokeStyle = 'yellow';//描边色ctx.strokeRect(10, 10, 100, 100);//描边矩形 画个三角形123456//画个三角 ctx.beginPath();//老子要开始画图啦！ ctx.moveTo(300,240);//先在(300,240)这取个点 ctx.lineTo(300,300);//连接到(300,300) ctx.lineTo(240,270);//连接到(240,270) ctx.fill();//填充颜色(默认填充最近的ctx.fillStyle的颜色) 画个圆Math.PI表示π,弧度=(Math.PI/180)*角度12345ctx.arc(x, y, 半径, 起始弧度, 结束弧度, 默认顺时针画/设置true逆时针画); ctx.beginPath();//老子要开始画图啦！ ctx.arc(160, 140, 10,0,2*Math.PI);//在(160,140)的位置，画1个半径为10,起始弧度0，终止弧度为2π的圆，默认顺时针画 ctx.fill();//填充颜色 画个圆弧边123ctx.beginPath();//老子要开始画图啦！ctx.arc(190, 170, 50,0,Math.PI/2);//在(160,140)的位置，画1个半径为10,起始弧度0，终止弧度为2π的圆，默认顺时针画ctx.stroke();//描边 画条线(绘制路径)1234567function drawLine(x1,y1,x2,y2) &#123; ctx.beginPath(); ctx.lineWidth = 5; ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); &#125; 橡皮擦123456擦除部分内容ctx.clearRect(50,50,10,10);//在(50,50)这点擦去10x10的矩形【橡皮擦】清屏var paper = document.getElementById('canvas');ctx.clearRect(0,0,paper.width,paper.height);//挖去一个和画布大小一样的矩形【橡皮擦】 保存为图片12345678 var paper = document.getElementById('canvas'); a.onclick = function () &#123; var imgUrl = paper.toDataURL("image/png"); a.href = imgUrl; a.download = '图片.png';//设置保存时的默认名字 &#125;`]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>笔记</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 JavaScript知识点补充]]></title>
    <url>%2F2018%2F02%2F27%2FJavaScript%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[javascript查漏补缺，一些零碎的知识点的补充 sublime正则替换的用法store.js的使用记得判断是否存在容器12website = store.get('容器1') || website;//从容器1中取出website,如果存在就覆盖原始的website，如果不存在就使用原始的website 获取head和body12document.headdocument.body prompt的使用弹出一个确认框。如果点击取消，则promote返回null，所以要做判断是否点击确定还是取消 键盘事件要加在document身上键盘事件要加在document身上1document.onkeypress = fn1; ev123xxx.onclick= function (ev) &#123; console.log(ev); //可以看到许多和ev有关的内容 &#125; ev.targetev.key和ev.keyCodeev.key直接获取按下哪个键ev.keyCode获取键值 oImg.onerror123oImg.onerror = function (ev) &#123; ev.target.src = &apos;//i.loli.net/2017/11/10/5a051fbc5e183.png&apos;;//如果网络图标下载出错就改用默认图标&#125; open和location.href123456open('//www.qq.com'); //默认新窗口打开open('//www.qq.com', '_blank');//同上open('//www.qq.com', '_self');//在当前窗口打开location.href = '//www.baidu.com'//同上语法糖:location = '//www.baidu.com location 是一个hash对象，location.href 是它的一个属性。在获取时，用location.href在赋值时，可以用location=”//www.xxx” ，也可以用 location.href=”//www.xxx”，两者效果相同 函数封装123456function tag(tagName, attr)&#123; //tag('div', &#123;id:'div1', className:'test'&#125;) var ele = document.creatElement(tagName); for (var key in attr) &#123; //遍历attr里的所有键值对 ele[key] = attr[key]; //div.id=div1, div.className=test &#125; return ele; return多个时要用json123456789101112131415161718function init() &#123; var keys = [ ['q','w','e','r','t','y','u','i','o','p'], ['a','s','d','f','g','h','j','k','l'] ]; var website = &#123; 'q': 'qq.com', 'w': 'weibo.com' &#125;; return &#123; 'keys': keys, 'website': website &#125;&#125;var keys = init().keys; //或写成init()['keys']var website = init().website; //或写成init()['website'] 三元运算123var n = 7;var msg = '数字' + n + '是' + (n % 2 === 0 ? '偶数' : '奇数');console.log(msg); 变量提升所有的变量的声明语句var，都会被提升到代码的头部，这就叫做变量提升12345678console.log(a);//undefinedvar a = 1;等同于var a; //var提升到头部，此时a = undefinedconsole.log(a);a = 1; js命名规范js对大小写敏感，所以var a和var A是不同的。要求：第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。中文是合法的标识符，可以用作变量名。1var 临时变量 = 1; sitch语句。多个if…else连在一起使用的时候，可以转为使用更方便的switch结构。12345678910111213141516171819202122232425262728switch (fruit) &#123; case "banana": // ... break; case "apple": // ... break; default: // ...&#125;每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块var x = 1;switch (x) &#123; case 1: console.log('x 等于1'); case 2: console.log('x 等于2'); default: console.log('x 等于其他值');&#125;// x等于1// x等于2// x等于其他值上面代码中，case代码块之中没有break语句，导致一直执行下去 switch语句采用的是严格相等运算符（===），而不是相等运算符（==） do…while 循环 while循环句末没有分号，而do…while 循环 句末必须要有分号 不管条件是否为真，do…while都会执行一次语句1234567891011do &#123; 语句&#125; while (条件);-----------------var x = 3;var i = 0;do &#123; console.log(i); i++;&#125; while(i &lt; x); break 语句和 continue 语句 break语句用于直接跳出代码块或循环、直接停止。 123456789for (var i = 0; i &lt; 5; i++) &#123; console.log(i); if (i === 3) break; //i==3时跳出去，停止该循环&#125;// 0// 1// 2// 3 continue语句立即终止本次循环，并直接开始下一轮循环。 1234567var i = 0;while (i &lt; 100)&#123; i++; if (i % 2 === 0) continue; console.log('i 当前为：' + i);&#125; 上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环。 如果存在多重for循环，不带label的break语句和continue语句都只针对最内层循环。 跳转标签（label）123456789101112131415161718192021222324252627282930313233343536373839404142标签名: 语句 --------------- top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) break top; console.log('i=' + i + ', j=' + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0上面代码为一个双重for循环，break命令后面加上了top标签，满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。----------------------continue语句也可以与标签配合使用。here: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) continue here; console.log('i=' + i + ', j=' + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// i=2, j=0// i=2, j=1// i=2, j=2上面代码中，continue命令后面有一个标签名here，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环。 null和undefined123456789Number(null) // 05 + null // 5null是一个表示“空”的对象，null转为数字时，自动变成0。---------------Number(undefined) // NaN5 + undefined // NaNundefined是一个表示”此处无定义”的原始值，转为数值时为NaN 空数组（[]）和空对象（{}）对应的布尔值，都是true123456789if ([]) &#123; console.log('true');&#125;// trueif (&#123;&#125;) &#123; console.log('true');&#125;// true js中的科学计数法1234567123e3 // 123000123e-3 // 0.123-3.1e+12 //-3100000000000.1e-23 //1e-24小数点后紧跟5个以上的零，就自动转为科学计数法0.0000003 // 3e-7 js会自动进制转换默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。1234567891011120xff // 2550o377 // 2550b11 // 3----------有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。0888 // 8880777 // 511 判断浏览器是否支持标签的某个属性123判断浏览器是否支持a标签的download属性"download" in document.createElement('a');//true or false 获取移动端坐标123var ev = ev.touches[0];//获取第一个触摸点var x = ev.clientX;由于触摸屏支持多点触控，有好几个touches,所以不能通过ev.clientX获取坐标 移动端必须在ontouchstart时，ev.preventDefault();阻止屏幕的滚动btoa将字符串转成base64123456789101112btoa('stage'); // c3RhZ2U=atob将base64转回字符串atob('c3RhZ2U='); // stage不支持中文，要把中文转成base64，必须加入encodeURI()转码环节btoa('你好') //报错btoa(encodeURI('你好')) // JUU0JUJEJUEwJUU1JUE1JUJEbase64还原成中文需要decodeURI()解码decodeURI(atob('JUU0JUJEJUEwJUU1JUE1JUJE')) //你好注意，encode在中间环节，decode在最终环节 ev.target 和 ev.currentTarget12345678&lt;a href="#" id="a"&gt; &lt;span&gt;111&lt;/span&gt;&lt;/a&gt;a.onclick = function(ev)&#123; console.log(ev.target) // &lt;a href="#" id="a"&gt;&lt;span&gt;111&lt;/span&gt;&lt;/a&gt; console.log(ev.currentTarget) // &lt;span&gt;111&lt;/span&gt;&#125; a.href 和 a.getAttribute(‘href’)1234a.onclick = function () &#123; console.log(a.href);//自动添加http协议 console.log(a.getAttribute('href'));// #about&#125; ele.offsetTop() 和 window.scrollTo(x,y)12var posY = ele.offsetTop;window.scrollTo(0,posY); 缓动效果 建议使用ev.currentTarget替代ev.target过渡完成后执行某个函数transitionend事件该事件在 CSS 完成过渡后触发。1div1.addEventListener('transitionend', fn); 动画结束后执行某个函数animationend事件该事件在 CSS 动画结束播放时触发1div1.addEventListener("animationend", fn); animationiteration 该事件在 CSS 动画重复播放时触发animationstart 该事件在 CSS 动画开始播放时触发 切换到另一个页面时，定时器错乱的解决办法页面失去焦点的意思时，当我们由当前页面切换（此处‘切换’不是指的链接跳转）到另一个页面时，当前页面就失去了焦点，如果我很久才回到当前页面，若该页面中有定时器时（如我们用定时器做的图片轮播），图片就会出现空白，出现该原因是，当当前页面失去焦点时，浏览器会减慢失去焦点页面的资源加载和运行，为获得焦点的页面提供更多的资源。但是我们失去焦点时的页面的定时器还在按程序的规定运行，而浏览器的运行又跟不上，所以就出现空白或卡顿现象。 一旦切换到别的页面，然后重新切换回来时，由于浏览器切换页面js定时器会变缓慢，当重新切换到当前窗口之前变慢的定时器堆积在一起便开始疯狂执行，会出现定时器错乱。 这是因为浏览器本着节省内存的性质，当切换到其他页面时，常用系统页面的定时器不运动，但是动画依然排列，当切换回来的时候，动画加速运动，出现错误，在轮播图之类的页面经常会发生这样的情况。 解决方法：通过浏览器的焦点事件去执行该js（我也是才知道window窗口也是有焦点事件的）12345678var timer=null;window.onfocus=function()&#123; timer=setInterval(autoRun,1000);&#125;window.onblur=function()&#123; clearInterval(timer);&#125; 更好的方法是监听visibilitychange12345678document.addEventListener("visibilitychange", function() &#123; if (document.hidden === true) &#123; clearInterval(timer); &#125; else &#123; timer = setInterval(slide, 2000); &#125; &#125;); 如果您使用的是jQuery，在animate前加上 $(obj).stop(true,true); 可以解决123setInterval(function()&#123; $("div").stop(true,true).animate(&#123;"top":"-20px"&#125;)&#125;,1000); 查看是否支持某个方法或属性12345'onclick' in document // true'onmouseover' in document // true'hidden' in document // true 多重三目运算1234var hidden = 'hidden' in document ? 'hidden' : 'webkitHidden' in document ? 'webkitHidden' : 'mozHidden' in document ? 'mozHidden' : null; 点击页面其他地方关闭弹出层 需要给document添加click事件，而不是body身上，因为body的区域并不是整个页面的宽高，而是与内部文档流的尺寸总和有关 为了防止点击按钮的同时触发document事件，因此需要阻断冒泡 document的点击事件需要改写成节省内存的写法12345678910111213141516171819202122232425262728btn.onclick = function (ev) &#123; popover.style.display = 'block'; &#125; document.onclick = function () &#123;//添加到document上 console.log(1); //浪费内存 popover.style.display = 'none'; &#125; wrapper.onclick = function (ev) &#123; ev.stopPropagation();//阻止冒泡 &#125;上面这种写法浪费内存，因为只要点击document就会触发它的click事件$('#btn').click(function() &#123; $('#popover').show(); $(document).one('click', function() &#123; //在click事件里，给父级加上了另一个事件，这个事件会被立刻执行，因此需要给wrapper阻断冒泡，让它在被点击时才执行 console.log(1); //只有弹出层show出来后，才会触发document的click事件，且只触发一次 $('#popover').hide(); &#125;);&#125;);//document的click事件加在了btn函数内部，它会在冒泡阶段直接执行，即使不点击document也会直接执行因此需要阻断冒泡$('#wrapper').click(function(ev) &#123; ev.stopPropagation();&#125;); 图片加载成功或失败图片加载成功时： onload图片加载失败时：onerror123456&lt;img src="image.gif" onerror="alert('图片加载出错')"&gt;&lt;img src="logo.png" onload="success()"&gt;function success()&#123; alert("图片加载完成");&#125; 用console.time获取代码运行时长123console.time();//标记代码开始时间// 代码console.timeEnd();//标记代码结束时间 form的提交监听的是form将submit事件加在整个form上，而不是提交按钮上这样用户按回车也能提交表单1form.onsubmit = fn; Date对象的日期格式化toLocaleString() 中国时间12var d=new Date();var n=d.toLocaleString(); //2018/3/29 上午10:42:13 1234567891011121314151617Date() //中国时间Date.now() //时间戳 1523521282634var d = new Date();d.toLocaleString() //中国时间console.log(d); // 输出：Mon Nov 04 2013 21:50:33 GMT+0800 (中国标准时间)console.log(d.toDateString()); // 日期字符串，输出：Mon Nov 04 2013console.log(d.toGMTString()); // 国外时间，GMT格式，输出：Mon, 04 Nov 2013 14:03:05 GMTconsole.log(d.toISOString()); // 国外时间，ISO格式，输出：2013-11-04T14:03:05.420Zconsole.log(d.toJSON()); // 输出：2013-11-04T14:03:05.420Zconsole.log(d.toLocaleDateString()); // 转换为本地日期格式，视环境而定，输出：2013年11月4日console.log(d.toLocaleString()); // 转换为本地日期和时间格式，视环境而定，输出：2013年11月4日 下午10:03:05console.log(d.toLocaleTimeString()); // 转换为本地时间格式，视环境而定，输出：下午10:03:05console.log(d.toString()); // 转换为字符串，输出：Mon Nov 04 2013 22:03:05 GMT+0800 (中国标准时间)console.log(d.toTimeString()); // 转换为时间字符串，输出：22:03:05 GMT+0800 (中国标准时间)console.log(d.toUTCString()); // 转换为世界时间，输出：Mon, 04 Nov 2013 14:03:05 GMT+0800 console.log(1)的值是什么?答案：打印出1，但是return的值是undefined12var result = console.log(1);result //undefined document.write()1document.write("&lt;h1&gt;Hello World!&lt;/h1&gt;&lt;p&gt;Have a nice day!&lt;/p&gt;") write() 与 writeln() 的区别：点击查看 打字机效果方法一： 方法二： 前面2中的document.write方法不会覆盖前面的内容，而innerHTML会覆盖之前的内容,，此时需要用+=：innerHTML += result[n-1]方法： innerHTML += .slice(n-1,n)方法： 滚动条始终拉到最底下1window.scrollTo(0,document.body.scrollHeight); 移动端触摸touch事件123当按下手指时，触发ontouchstart；当移动手指时，触发ontouchmove；当抬起手指时，触发ontouchend。 用setTimeout+延时递归实现setInterval因为循环定时器的speed一旦设定就无法改变，如果想要实时改变定时器的速度，就要用setTimeout+延时递归实现setInterval 1234567var n = 0;setTimeout(function xxx()&#123; n++; if(n&gt;=10) return; document.body.innerHTML = n; setTimeout(xxx,duration);&#125;,duration); 占位符的用法12var name = 'stage';h1.innerHTML = h1.innerHTML.replace(/&#123;&#123;name&#125;&#125;/ig,name); 利用:empty实现Skeleton Screen(加载占位图/骨架屏) 输入框的value不能一开始赋值123456789&lt;input type=text id=x&gt;var v = x.value;//不能这样！！因为一开始输入框里是空的////////////var x = document.getElementById('x');btn.onclick=function()&#123; console.log(x.value); //value必须在输入了内核后才能取到&#125; 输入框内填入json格式(必须双引号!!)1234&lt;input type="text" id="x"&gt;&lt;button id="y"&gt;点我&lt;/button&gt;在输入框内填入: &#123;"a":1,"b":2&#125; //json中必须双引号 1234y.onclick=function ()&#123; var data = x.value console.log(JSON.parse(data))&#125; 翻转字符串1'12345'.split('').reverse().join('') // 54321 btoa()转成base-64编码12let encodedData = window.btoa("Hello, world"); // 编码【不支持中文】let decodedData = window.atob(encodedData); // 解码 多态生成的元素绑定事件将事件绑定到父元素，通过冒泡触发当前元素用ev.target获取123456父级.onclick=function(ev)&#123; var x = ev.target.innerHTML; console.log(x);&#125;父级.appendChild('&lt;div&gt;hello&lt;/div&gt;'); 获取checkbox1document.querySelectorAll("input[type='checkbox']") 删除数据后，筛选出新数据1234var datas = [&#123;id:1,b:2&#125;,&#123;id:2,b:2&#125;,&#123;id:3,b:2&#125;];//假设将id为2的那一项删除var newDatas = datas.filter(data =&gt; data.a !== 2); i++与i+=112345678let a = 1;function add(n)&#123; return n++;&#125;let result = add(a);result //1//i++先返回原始值后，再自增；建议使用i+=1解决这个bug]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2018%2F02%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[本文主要介绍了哈希、队列、栈(stack)、链表、数(tree) 哈希（Hash）满足键值对(‘key’:’value’)的就是哈希。数组就是哈希 计数排序中的桶（复杂度 O(n+max)，比快排还快12345678910111213141516171819202122计数排序：数组[第0个是4，第1个是1，第二个是8......]将数组['0':4,'1':1,'2':8,'3':2,'4':9,'5':8,'length':6 //length等于最大下标index+1]里的值放入桶内hash=[]hash['1':1 //1有1个'2':1'4':1'8':2 //8有2个'9':1] //hash的length=10，因为最大下标index是9然后再从桶里把数值取出来newArr=[]newArr[1,2,4,8,8,9] 123456789101112131415161718192021222324252627282930313233//计数排序的js代码var a = [0,2,1,56,4,67,3,2];//存入hashvar hash = &#123;&#125;;for (i=0;i&lt;a.length;i++) &#123; var num = a[i]; if(!hash[num])&#123;//如果还没有对应的hash hash[num] = 1; &#125; else &#123; hash[num]++; &#125;&#125;/* console.log(hash); 结果hash = &#123;0: 1, 1: 1, 2: 2, 3: 1, 4: 1, 56: 1, 67: 1&#125;，表示数字0有1个，数字1有1个，数字2有2个，数字3有1个...... *///从hash中取出var max = Math.max.apply(null,a);//获取hash里的最大值//最大值是max,那么hash的长度length就是max+1;var length = max+1;var result = [];for (i=0;i&lt;length;i++)&#123; var 个数 = hash[i]; if (个数) &#123;//如果不是0个 for (j=0;j&lt;个数;j++) &#123; result.push(i); &#125; &#125; &#125;console.log(result); (桶排序)[http://bubkoo.com/2014/01/15/sort-algorithm/bucket-sort/] 与计数排序的区别 123456789桶排序hash['1':[5,2,8] //第1个桶表示10以内的数有5,2,8，然后将这个桶内的数字二次排序'2':[]'3':[27]'4':[33,37,31] //40以内的数有33,37,31,将这几个数字二次排序]与计数排序的区别：假设数组中最大的数是1000，那么计数排序需要1000个桶，而桶排序(如果每个桶的区间是100一分割),那么只需要10个桶，但是桶内的数们需要二次排序 (基数排序)[http://bubkoo.com/2014/01/15/sort-algorithm/radix-sort/] 与计数排序的区别 1基数排序始终只有10个桶，按照个位、十位、百位、千位.....的数值进行比较,每个桶里的数们组成队列，先进先出 队列（Queue） 先进先出 可以用数组实现 举例：排队1var out = arr.shift() 栈（Stack） 先进后出 可以用数组实现 举例：坐电梯1var out = arr.pop() 链表（Linked List） 数组无法直接删除中间的一项，链表可以 用哈希（JS里面用对象表示哈希）实现链表(一个哈希指向另一个哈希) 123456789101112131415161718192021[0,2,1]var a = &#123;value:0, next:&#123; value:2, next:&#123; value:1, next:undefined &#125; &#125;&#125;a.value //0a.next.value //2a.next.next.value //1删除中间的2:a.next = a.next.next //将a.next指向a.next.nexta.value //仍旧是0a.next.value //变成了1a.next.next.value //undefined head、node 概念 12head：链表的表头node：节点，表头属于第一个节点 树（tree）https://segmentfault.com/a/1190000000740261 举例：有层级结构的需要用到tree，比如DOM树 概念：层数(第0层、第1层、第2层…)、深度(总共有几层)、节点个数(没有下一个节点的叫做叶子节点) 二叉树 满二叉树 完全二叉树 完全二叉树和满二叉树可以用数组实现 123456789arr=[1,2,3,4,5,6,7,8,9,10,11,12,13,15,15]如何取第3层的第1个数字？arr[Math.pow(2,3-1)-1] //4 【2的3减1次方后减1】如何取第3层的第2个数字？arr[Math.pow(2,3-1)-1+1]如何取第3层的第3个数字？arr[Math.pow(2,3-1)-1+2] 其他树可以用哈希（对象）实现 操作：增删改查 堆排序用到了 tree 1.将数组里的数表示成完全二叉树2.然后进行最大堆调整【每个父节点的数值都大于等于其两个孩子结点的数值】：从最后一层的最右边开始到最左边，然后上一层的最右边到最左边，每发生一次交换时，踢下来的数都需要与子节点再次比较3.最终，最上面的那个数就是最大的数，把他与最后一个数交换(即放到数组的最后一位)，且这个最大数不再参与排序4.由于顶上的数发生了交换，所以继续进行顶上的数与两个子节点比较(也就是说，一开始是从右往左，从下往上比较；当第一次最大堆调整完后，将顶点的数与最后一个数进行交换；接下来就是从上到下进行比较了) 12345671.将数组里的数表现成完全二叉树的形式2.进行最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点3.创建最大堆：将堆所有数据重新排序，使其成为最大堆此时最顶端(根节点)的数就是最大的数4.将根节点的数和最后一个数交换位置，并将最大数挪出，不参与下一轮的排序5.由于第4步根节点发生了变化，所以剩余的堆需要继续调整为最大堆6.重复2~5的过程，直到剩余数只有一个时结束。 其他：B树、红黑树、AVL树 堆排序可视化https://www.cs.usfca.edu/~galles/visualization/HeapSort.html 堆排序JS代码完整讲解（看到最后）：http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法初级]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%AE%97%E6%B3%95%E5%88%9D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[排序算法列表https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#排序算法列表 冒泡排序 http://bubkoo.com/2014/01/12/sort-algorithm/bubble-sort/ 插入排序 http://bubkoo.com/2014/01/14/sort-algorithm/insertion-sort/ 桶排序 http://bubkoo.com/2014/01/15/sort-algorithm/bucket-sort/ 常见排序算法归档：http://bubkoo.com/tags/algorithm/ 算法的5个特征 输入：一个算法必须有零个或以上输入量。 输出：一个算法应有一个或以上输出量，输出量是算法计算的结果。 明确性：算法的描述必须无歧义，以保证算法的实际执行结果是精确地匹配要求或期望，通常要求实际运行结果是确定的。 有限性：算法必须在有限个步骤内完成任务。 有效性：又称可行性，能够实现，比如：通过代码让电脑生个孩子出来是不可行的。 数据结构就是数据的结构。 一般来说是这样的： 我们要解决一个跟数据相关的问题 分析这个问题，想出对应的数据结构 分析数据结构，想出算法 先分析数据的结构，再想出对应的算法数据结构和算法是互相依存、不可分开的 你学习完排序算法，就能了解常见的数据结构 5种排序算法 身高两两对比法（冒泡排序,按顺序两两对比交换位置） 12345678910111213141516171819202122232425以数组 arr = [5, 1, 4, 2, 8] 为例说明，加粗的数字表示每次循环要比较的两个数字：第一次外循环( **5 1** 4 2 8 ) → ( **1 5** 4 2 8 )， 5 &gt; 1 交换位置( 1 **5 4** 2 8 ) → ( 1 **4 5** 2 8 )， 5 &gt; 4 交换位置( 1 4 **5 2** 8 ) → ( 1 4 **2 5** 8 )， 5 &gt; 2 交换位置( 1 4 2 **5 8** ) → ( 1 4 2 **5 8** )， 5 &lt; 8 位置不变第二次外循环（除开最后一个元素8不动，对剩余的序列）( **1 4** 2 5 8 ) → ( **1 4** 2 5 8 )， 1 &lt; 4 位置不变( 1 **4 2** 5 8 ) → ( 1 **2 4** 5 8 )， 4 &gt; 2 交换位置( 1 2 **4 5** 8 ) → ( 1 2 **4 5** 8 )， 4 &lt; 5 位置不变8固定在最后第三次外循环（除开已经排序好的最后两个元素，可以注意到上面的数组其实已经排序完成，但是程序本身并不知道，所以还要进行后续的循环，直到剩余的序列为 1）5,8固定不变( **1 2** 4 5 8 ) → ( **1 2** 4 5 8 )( 1 **2 4** 5 8 ) → ( 1 **2 4** 5 8 )4,5,8固定不变第四次外循环（最后一次）( *1 2* 4 5 8 ) → ( *1 2* 4 5 8 ) 体育老师一指禅法（选择排序,每次从一堆中选出最小的那个数排到最前面，然后后面剩余的数重复这个步骤） 整理扑克牌法（插入排序） 桌上散落的扑克牌整理法（桶排序、基数排序） 快排(每次选择第一个数作为基准，比它小的放左边，比它大的放右边) 随机快排(每次快排随机选择一个数站定分割左右) 归并排序 堆排序 排序算法js代码https://www.cnblogs.com/Unknw/p/6346681.html 排序可视化排序可视化：https://visualgo.net/zh/sorting]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 css知识点补充]]></title>
    <url>%2F2018%2F02%2F23%2Fcss%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[css知识点查漏补缺，知识点补充，比较零碎 文档流文档流：文档内 元素流动的方向。inline元素从左往右流动→，如果宽度不够另挤一行block元素独占一行，从上往下流动↓ 块级元素块级元素的高度由其 内部文档流元素 的 高度总和 决定 块级元素居中margin:0 auto; footer始终在底部方法112345678910111213141516171819html,body &#123; height: 100%;/*必须*/&#125;#app &#123; position: relative; min-height: 100%; /*重点！！！*/&#125;header &#123; background: #f90;&#125;#main &#123; padding-bottom: 30px;/*等于footer的高度*/&#125;footer &#123; height: 30px; background: #f90; position: absolute; bottom: 0px;width: 100%;/*修复绝对定位导致宽度失效*/&#125; 【查看在线实例】 方法2 flex布局12345678910111213html,body,#app&#123; height:100%;&#125;#app&#123; display:flex; flex-direction:column;&#125;header,footer&#123; background: orange;&#125;#main&#123; flex-grow:1;&#125; 【查看在线实例】 内联元素的高度多个内联元素以baseline对齐内联元素如果同处一个块元素内，那么按照基线对齐(可以通过vertical-align来设置内联元素对齐方式)可以看到，x不是在div的正中间，而是与hug的基线对齐 渐变gradient 在线渐变生成器:http://www.colorzilla.com/gradient-editor/ 设置dib后，一定要加上vat12display: inline-block;vertical-align: top; text-transform: uppercase将字母变成大写 利用box-shadow实现多层边框(立体感)12box-shadow: 向左 向下 模糊程度 一个不模糊的边框 内阴影inset;box-shadow: 0 0 0 1px #1a1b1c, 0 0 0 2px #1f2020, 0 3px 0 1px #080808; 100vh使元素的高度占满可视区高度12div&#123;height: 100vh&#125;再利用flex就可以使元素内的item相对于可视区居中 icon图标123将favicon.ico放在根目录下如果要获取其他网站的icon，可以通过 //该网站根目录/favicon.ico比如 //www.qq.com/favicon.ico 就可以获得qq的icon overflow:hidden别给老子出现滚动条！当元素设置了 absolute 后，默认就不是100%的宽度了，而是内容多宽就是多宽当元素设置了 absolute 后，默认就不是100%的宽度了，而是内容多宽就是多宽如果希望absolute 以后的元素依然和父容器一样是的100% 宽度有两个方法： 给子级设置 width:100% 给子级设置left:0px;right:0px; min-width和max-widthmin-width:无论如何，都不会小于这个宽度max-width:无论如何，都不会比这个宽度大 多色border123456.box&#123; border:50px solid red; width:0; height:0; border-color:red yellow green blue&#125; 多色三角形变形1234567.box&#123; border:50px solid red; width:0; height:0; border-color:red yellow green blue; border-width:10px 30px 50px 80px&#125; 扇形1234567.box&#123; border:50px solid black; width:0; height:0; border-color:red yellow green blue; border-radius: 50%;&#125; 渐变动画加载图 利用background-size: 200% auto将背景在x轴扩大，然后改变background-position的位置达到渐变动画的效果 文字显示两行，超出两行部分显示省略号123456p &#123; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;&#125; 改变文字被选中后的颜色1234::selection &#123; background: #00b38a; color: #fff;&#125; visibility的注意事项visibility使用之前，必须先给元素设置display12display: block; //先设置displayvisibility: hidden; //再使用visibility rotate(360deg)可以写成rotate(1turn)::placeholder给输入框的占位符添加样式123::placeholder&#123; color:red;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>css</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 前端学习记录]]></title>
    <url>%2F2018%2F02%2F23%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[- 9.HTML 续http-server的安装视频iframe和a这一节有介绍 10.入门css知识点 如何做横向布局（float + clearfix） 继承样式inherit 四种引入 CSS 的方式：行间样式、内部样式、外部样式、@import 作业完成简历的logo和top-navbar 11.CSS 布局与定位知识点 尽量不要设置width和height，通过调节padding来自适应. 用max-width代替width，这样当屏幕小于这个width时会自适应缩放 高度是由什么决定的 什么是文档流【文档内元素流动的方向】 内联元素 与 块级元素 line-box 是啥 box 是啥（盒模型） 宽度是有什么决定的 position 的 5 个取值 脱离文档流 background-size:cover z-index 作业 大背景图 大名片card 12.CSS 布局与定位续知识点 太极图12线性渐变background: linear-gradient(to bottom, white 0%,white 50%,black 50%,black 100%);:before,:after伪元素 作业 制作下载按钮 技能百分比条 非线性布局1234设置dib后，一定要加上vatdisplay: inline-block;vertical-align: top; 13.命令行 HTTP Node.js HTML CSS 小结命令行复习123456789101112131415161718192021222324252627pwd progress working dircd change dirmkdir make dirtouch echo &quot;hi&quot; &gt; 1.txtecho &quot;hi&quot; &gt;&gt; 1.txtecho &quot;hi&quot; &gt;! 1.txtcp -rrm -rfmvtree git initgit addgit commit -m &quot;hi&quot;git pullgit pushgit clonecurl -L http://baidu.comcurl -s -v -- http://baidu.comping qq.comhexo inithexo ghexo serverhexo deploy HTTP请求与响应复习 请求包括 GET(获取) POST(上传) PUT(整体更新) PATCH(局部更新) DELETE(删除) HEAD OPTIONS等 能够手写http请求，能够手写http响应 Content-Type: application/x-www-form-urlencoded : 应用数据/还没有写入规范的格式-万维网-表单-用urlencode形式压缩 知道状态码的含义 TCP/IP协议 Node.jsServer14.算法初级 排序算法列表 https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#排序算法列表 冒泡排序 http://bubkoo.com/2014/01/12/sort-algorithm/bubble-sort/ 插入排序 http://bubkoo.com/2014/01/14/sort-algorithm/insertion-sort/ 桶排序 http://bubkoo.com/2014/01/15/sort-algorithm/bucket-sort/ 其他排序：http://bubkoo.com/tags/algorithm/ 快排、随机快排 排序算法js代码https://www.cnblogs.com/Unknw/p/6346681.html 15.数据结构哈希、队列、栈(stack)、链表、数(tree) 计数排序(有多少个数就有多少个桶)与桶排序(自定义一个范围桶)与基数排序(始终10个桶) 队列：先进先出，arr.shift() 栈：先进后出，arr.pop() 链表，可以用来删除数组中间的某个数 12345678910var a = &#123;value:0, next:&#123; value:2, next:&#123; value:1, next:undefined &#125; &#125;&#125; 树堆排序:https://www.cs.usfca.edu/~galles/visualization/HeapSort.html 16.JavaScript 初体验做一个键盘导航代码和预览：https://github.com/FrankFang/nav-demo text-transform: uppercase将字母变成大写 sublime正则替换的用法for循环创建divstore.js的使用记得判断是否存在容器12website = store.get('容器1') || website;//从容器1中取出website,如果存在就覆盖原始的website，如果不存在就使用原始的website create元素和append元素prompt的使用如果点击取消，则promote返回null，所以要做判断是否点击确定还是取消 键盘事件要加在document身上这个事件加在document身上1document.onkeypress = fn1; ev123xxx.onclick= function (ev) &#123; console.log(ev); //可以看到许多和ev有关的内容 &#125; ev.targetev.key和ev.keyCodeev.key直接获取按下哪个键ev.keyCode获取键值 open和location.href12345open('http://www.qq.com'); //默认新窗口打开open('http://www.qq.com', '_blank');//同上open('http://www.qq.com', '_self');//在当前窗口打开location.href = 'http://www.baidu.com'//同上 17.第一个 JS 作品完善上一节课的键盘导航键盘参考：http://mcdlr.com/key-sheet/代码参考：https://github.com/FrankFang/nav-demo/ 知识点渐变色1background: linear-gradient(to bottom,#292929,#111); 利用box-shadow实现多层边框(立体感)12box-shadow: 向左 向下 模糊程度 一个不模糊的边框 内阴影inset;box-shadow: 0 0 0 1px #1a1b1c, 0 0 0 2px #1f2020, 0 3px 0 1px #080808; 100vh使元素的高度占满可视区高度12body&#123;height: 100vh&#125;再利用flex就可以使元素内的item相对于可视区居中 ico图标123将favicon.ico放在根目录下如果要获取其他网站的icon，可以通过 //该网站根目录/favicon.ico比如 //www.qq.com/favicon.ico 就可以获得qq的icon oImg.onerror123oImg.onerror = function (ev) &#123; ev.target.src = &apos;//i.loli.net/2017/11/10/5a051fbc5e183.png&apos;;//如果网络图标下载出错就改用默认图标&#125; 函数封装123456function tag(tagName, attr)&#123; //tag('div', &#123;id:'div1', className:'test'&#125;) var ele = document.creatElement(tagName); for (var key in attr) &#123; //遍历attr里的所有键值对 ele[key] = attr[key]; //div.id=div1, div.className=test &#125; return ele; return多个时要用一个对象123456789101112131415161718function init() &#123; var keys = [ ['q','w','e','r','t','y','u','i','o','p'], ['a','s','d','f','g','h','j','k','l'] ]; var website = &#123; 'q': 'qq.com', 'w': 'weibo.com' &#125;; return &#123; 'keys': keys, 'website': website &#125;&#125;var keys = init().keys; //或写成init()['keys']var website = init().website; //或写成init()['website'] 18.Canvas画板知识点鼠标事件123document.onmousemove = fn1;document.onmousedown = fn1;document.onmouseup = fn1; canvas canvas设置宽高时，由于它是inline元素，所以先要设置display:block或者vertical-align: top;；然后修改它的属性宽高，而不是css的宽高 19.手机端画板添加viewport方法:meta:vp + tab touch方法 手机端没有鼠标，所以不能用onmouse方法，而应该用ontouch方法 123元素.ontouchstart = fn;元素.ontouchmove = fn;元素.ontouchend = fn; 判断是否支持touch方法(特性检测) 1234567if (document.body.ontouchstart !== undefined) &#123; //是触屏设备&#125; else &#123; //是非触屏设备&#125; 判断浏览器是否支持标签的某个属性123判断浏览器是否支持a标签的download属性"download" in document.createElement('a');//true or false 判断是否是移动设备1234567891011在w3school上看到可以这样来判断平台：function checkStation()&#123; var info = navigator.userAgent; if(info.indexOf("iPod")!=-1 || info.indexOf("iPad")!=-1 || info.indexOf("iPhone")!=-1 || info.indexOf("Android")!=-1)&#123; alert("平板"); return true; &#125;else&#123; alert("电脑"); return false; &#125;&#125; 获取触摸坐标123var ev = ev.touches[0];//获取第一个触摸点var x = ev.clientX;由于触摸屏支持多点触控，有好几个touches,所以不能通过ev.clientX获取坐标 移动端必须在ontouchstart时，ev.preventDefault();阻止屏幕的滚动iconfont的使用 批量去色有些icon有默认色，为了icon颜色统一，建议批量去色选择完icon并添加至项目后，选择批量操作里的批量去色 局域网调试利用http-server进行局域网调试 20.JS里的7种数据 number string boolean symbol undefined null object 21.类型转换btoa将字符串转为base64类型转换5个falsy值内存图面试题-对象的引用面试题-垃圾回收面试题-深拷贝vs浅拷贝22.JS里的对象全局函数1.Numbervar n = new Number(1) 创建一个 Number 对象1 与 new Number(1) 的区别是什么？看内存图2.Stringvar s = new String(‘hello’) 创建一个 String 对象‘hello’ 与 new String(‘hello’) 的区别是什么？看内存图3.Booleanvar b = new Boolean(true) 创建一个 Boolean 对象true 与 new Boolean(true) 的区别是什么？看内存图4.Objectvar o1 = {}var o2 = new Object()o1 和 o2 没区别 原型prototypevar 对象 = new 全局函数() //函数包括Number(123)/String(‘123’)等全局函数对象.proto === 全局函数.prototype 23.给简历加 JS loading 动画 会变的navbar ， sticky navbar 鼠标滚动后导航栏黏着 会动的二级菜单menu 点击导航栏自己滚动到对应那一块 auto scroll smoothy chrome控制动画速度选中动画元素Elements → 点击三个点(更多) → More tools → Animations里控制动画的速度 scrollYvar y = scrollY;//window.scrollY,window可省略 字体颜色inheritev.target 和 ev.currentTargetxxx.tagName.toLowerCase()if (xxx.tagNamea.toLowerCase() == ‘ul’) a.href 和 a.getAttribute(‘href’)1234a.onclick = function () &#123; console.log(a.href);//自动补充完整http协议 console.log(a.getAttribute('href'));// #about&#125; ele.offsetTop() 和 window.scrollTo(x,y)12var posY = ele.offsetTop;window.scrollTo(0,posY); 24.给简历加 JS（续）平滑滚动smooth scroll tween.js滚动监听scrollspy检测元素出现在可视区12345678910111213141516171819&lt;div id="a"&gt;&lt;/div&gt;&lt;div id="b"&gt;&lt;/div&gt;&lt;div id="c"&gt;&lt;/div&gt;&lt;script&gt; var viewport = document.documentElement.clientHeight; var eles = document.querySelectorAll('div'); window.onscroll = function () &#123; for (var i = 0; i &lt; eles.length; i++) &#123; var eleCurrentTop = eles[i].getBoundingClientRect().top;//必须放在for循环里！ if(eleCurrentTop &lt; viewport-100)&#123; //alert('出现在可视区'); eles[i].classList.add('active'); &#125; &#125; &#125;&lt;/script&gt; 技能条加载动画25.JS 数组Array数据类型new不new的区别伪数组数组的操作(api)26.函数Function函数的声明方法eval()函数的调用call、this、arguments面试题call stack调用栈作用域面试题闭包27.DOM API文档对象模型 DOM各种api的操作28.jQuery 不过如此三等号===三等号 NaN永远不等于NaN对象永远不等于对象，因为他们在stack区的Address地址不一样 封装自己的js库jquery原理29.用 jQuery 做个轮播吧DOM作业讲解在使用querySelector方法时，遇到DOM树增加或删除,需要重新获取 jquery作业讲解jquery实现轮播图 index()，eq()的相互结合 取模的运用 trigger()的用法 30.无缝轮播 过渡结束事件transitionend的用法 放慢速度查看动画效果：chrome -&gt; 更多选项(三个点) -&gt; more tools -&gt; animations 切换到另一个页面时，为了防止定时器错乱，需要监听visibilitychange addEventListener() DOM事件，捕获和冒泡 31.期中考试32.DOM事件 点击其他地方关闭浮层 节省内存的写法.one() 可左右切换的无缝轮播图 33.JSONP 是什么鬼 git reset 后悔药id --hard 动态创建scrip标签用来发送请求 script标签创建后自动执行，执行完后ev.currentTarget.remove()将其删除 jsonp 34.AJAX 是什么鬼 背出XMLHttpRequest的写法 console.time();要执行的代码;console.timeEnd(); 可以得到代码执行时长 json里面的字符串必须用双引号 从后端获取的数据是字符串类型，需要通过JSON.parse(字符串)转成JS对象 chrome开发者工具 → Network → Network → 点击preserve log(页面刷新时不清楚日志) 35.自己实现 AJAX ajax设置http请求headers的4部分 ajax获取http响应headers的4部分 浏览器从输入网址回车到呈现页面的过程 封装jQuery.ajax ES6解构赋值的用法 Promise的用法 36.把 MVC 的 VC 加到简历里 简历中引入swiper的使用 模块化 -&gt; 立即执行函数，变量互不影响 立即执行函数,闭包 MVC的VC 37.给简历加个数据库 免费服务器leancloud Date对象的toLocaleString()方法 MVC的M 38.js高级基础知识考试39.来，面向对象编程吧！ 命名空间 理解var app = app || {} Class 类 复习this new一个构造函数时到底做了些什么 41.会动的简历 完整代码：https://github.com/FrankFang/animating-resume预览：https://frankfang.github.io/animating-resume/vue.js 版本：https://jirengu-inc.github.io/animating-resume/public/vue.js 版本源码：https://github.com/jirengu-inc/animating-resume &lt;pre&gt;标签，保留多个空格和回车换行,&lt;pre&gt;显示多行代码，&lt;code&gt;显示一行代码，&lt;pre&gt;可以替代&lt;code&gt; 代码高亮插件(关键词js syntax lib):prism.js或者hightlight.js 初识异步(先写的代码排在后面才执行) 初识回调 promise window.scrollTo(0,document.body.scrollHeight),使得滚动条始终拉到最底下 插件marked.js的用法 42.画一只皮卡丘 手机端的宽度最好控制在320px以内 扇形的制作 npm(yarn)的使用，以及忽略node_modules，防止里面的所有插件都提交到git node_modules里的jquery不忽略的方法 自定义属性data-的用法 因为循环定时器的speed一旦设定就无法改变，所以要用setTimeout+延时递归实现setInterval 用命令行将第三方插件从node_modules拷贝到vendor文件夹下 chrome的disable-cache的使用 43.Cookie与登录注册 复习浏览器请求与响应 做一个登入注册 用curl向后端发请求 cookie的设置和获取 44.Session、LocalStorage、Cache-Control 服务器通过cookie发送给浏览器sessionID(随机数) sessionStorage localStorage web性能优化：HTTP缓存 用curl -L https://cdn.bootcss.com/xxx.js &gt;&gt; main.js将其写入本地的main.js文件 cache-control Expires Etag Last-Modified 45.初识 webpack 前端工程化 sass的使用，用命令行将sass自动转成css 用Bable将es6自动转成es5 命令行CLI 46.从 MVC 到 MVVM axios的使用，请求数据，伪造数据 es6的解构赋值 通过jq的事件委托，使得DOM结构被更改时原来的按钮仍然能被触发 从jquery到mvc再到mvvm 用vue做显示helloworld、轮播、tab切换 47.2018年前端面试押题48.简历 简历的制作及投递，分析HR的心态 LeanCloud获取最新的10条留言 一些amazing的库 49.毕设：网易云音乐 需求分析 LeanCloud的使用 git bash的使用(gitignore忽略) 七牛环境搭建 50.网易云音乐2 flex布局 MVC 发布订阅模式 object.assign()的用法 保存数据到服务器save深拷贝：let newObj = JSON.Parse(JSON.stringify(obj)) 51.网易云音乐3 获取数据find 深拷贝：let newObj = JSON.Parse(JSON.stringify(obj)) 52.网易云音乐4 通过查询参数获取歌曲 arr.filter(v=&gt;v) 将数组中的falsy值过滤 css模糊blur不要直接给元素模糊，不然文字也会模糊，给伪元素模糊，并z-index:-1 jq用each代替for循环 jq的第i个要用$().eq(i)，如果写成$()[i]就会变成dom对象 53.网易云音乐5 歌词滚动的方法 53.网易云音乐6 手机端调试大法 window.onerror=function(msg,file,line){alert(msg)} tencent/vconsole 54.毕设：Vue简历编辑器1 WebStorm的用法 dl&gt;dt&gt;dd的用法，dl标签定义一个描述列表。用于描述，比如姓名:xxx,年龄:xxx;ul标签用于展示项目 监听contenteditable的事件 55.Vue简历编辑器2 组件component的使用 WebStorm的用法 chrome的debugger用法(在获取currentUser那一课) 文档-&gt;深入响应式原理 -&gt; 如何跟踪变化 56.Vue简历编辑器3 用console.dir()查看对象的层级 resume.info[0].name是个字符串，怎样变成数组？用正则替换成resume.info.0.name！正则中的小括号用来提取想要的内容 css要注意权重的问题，比如add按钮前面要添加别的选择器加重权重，不然没有居中 用arr.splice(index,1)删除数组中的某一个值 box-shadow: 0 0 0 10000px rgba(0,0,0,.5)，通过扩展半径，实现半透明遮罩 57.Vue简历编辑器4 打印功能：window.print(); 用正则编辑换肤css 组件化，父子通信 爷孙通信 孙子 -&gt; 父亲 -&gt; 爷爷 反点号里面还有反点号时，里面的反点号用`转译 58.Vue简历编辑器5 自定义标签默认样式与span一样 1234&lt;a href="/js/1.txt" id="x"&gt;&lt;/a&gt;console.log(x.href) // http://js.jirengu.com/js/1.txtconsole.log(x.getAttribute('href')) // /js/1.txt 59.一些重要但前面没讲的内容 继承的ES5、ES6写法 性能优化，chrome的network用法]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[空元素与可替换元素]]></title>
    <url>%2F2018%2F02%2F22%2F%E7%A9%BA%E6%A0%87%E7%AD%BE%E4%B8%8E%E5%8F%AF%E6%9B%BF%E6%8D%A2%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[空元素，不需要闭合的元素;没有伪元素:before和:after可替换元素,它的展现不由CSS来控制 空元素，不需要闭合的元素空元素没有伪元素:before和:after1234567891011121314151617&lt;br&gt;&lt;hr&gt;&lt;link&gt;&lt;meta&gt;&lt;img&gt;&lt;input&gt;&lt;area&gt;&lt;base&gt;&lt;col&gt;&lt;colgroup&gt; when the span is present&lt;command&gt;&lt;embed&gt;&lt;keygen&gt;&lt;param&gt;&lt;source&gt;&lt;track&gt;&lt;wbr&gt; 可替换元素,它的展现不由CSS来控制12&lt;img&gt;、 &lt;object&gt;、 &lt;video&gt; 、&lt;textarea&gt;、 &lt;input&gt;、&lt;audio&gt; 和 &lt;canvas&gt;这类元素一开始就有样式，比如img的宽高由引入的图片大小决定]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>面试题</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 html知识点补充]]></title>
    <url>%2F2018%2F02%2F22%2Fhtml%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[html知识点补充，查漏补缺，比较零碎 iframe 标签嵌套页面12&lt;iframe src="https://www.baidu.com" name="qqqqq" width=100% height=200 &gt;&lt;/iframe&gt;&lt;a href="https://www.qq.com" name="qqqqq"&gt;在name=qqqqq的iframe中打开&lt;/a&gt; a 标签跳转页面（HTTP GET 请求） download属性123456&lt;a href="xxxx" download&gt;下载链接&lt;/a&gt;&lt;a href="http://www.xxx.com/3.png" download="3.png"&gt;下载图片3.png&lt;/a&gt;加上download属性，就会下载下来否则就是用浏览器打开预览文件download="文件名"用js可以操作文件名，比如a.download = imgName + '.png'; target属性12345&lt;a target="_blank|_self|_parent|_top|framename"&gt;_blank 在新窗口中打开_self 在a标签所在的页面中打开_parent 在a标签所在页面的父级窗口中打开_top 如果嵌套iframe,就在最顶层（也就是当前页面）中打开 href属性1234567891011121314151617181920212223242526绝对路径&lt;a href="www.qq.com"&gt;错误！！！！漏了协议&lt;/a&gt;&lt;a href="https://www.qq.com"&gt;正确，https协议&lt;/a&gt;&lt;a href="//www.qq.com"&gt;正确,自定义协议&lt;/a&gt;相对路径&lt;a href="./xxx.html"&gt;&lt;/a&gt;结果打开127.0.0.1:8080/xxx.html&lt;a href="#锚点"&gt;&lt;/a&gt;结果打开127.0.0.1:8080/index.html#锚点，锚点不发起请求&lt;a href="?name=stage"&gt;&lt;/a&gt;结果打开127.0.0.1:8080/index.html?name=stage,自动发起 ?name=stage 的GET请求&lt;a href="javascript:;"&gt;&lt;/a&gt;点击之后什么都不发生&lt;a href="#"&gt;&lt;/a&gt;点击之后不刷新，锚点变成#，滚回到顶部&lt;a href=""&gt;&lt;/a&gt;点击之后刷新当前页面移动端点击拨打电话&lt;a href="tel:10086"&gt;10086&lt;/a&gt; form12345678&lt;form action="index2.php" method="get"&gt; First name: &lt;input type="text" name="fname"&gt;&lt;br&gt; Last name: &lt;input type="text" name="lname"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;将fname=xxx&amp;lname=xxx提交到index2.php中文会转码 method属性 GET时，如果有提交的数据，数据会作为查询参数出现在地址栏127.0.0.1::8080/index.html?fname=xxx&amp;lname=xxx POST时，用Chrome开发者工具可以看到，数据在Form Data里 重点如果一个表单中没有input-submit时 如果有&lt;button&gt;没有写type的按钮&lt;/button&gt;，该button自动升级为type=submit，可以提交表单 如果写了type=button，则无法提交表单 label 标签1234567891011&lt;label for="male"&gt;文字&lt;/label&gt;&lt;input type="checkbox" name="male" id="male"&gt;这样点击文字也能选中复选框，请将label的for与input的id名对应---------------------简便写法：label把input包起来&lt;label&gt;文字&lt;input type="checkbox" name="male"&gt;&lt;/label&gt;这样就不用for和id名了 select 标签1234567&lt;select name=&quot;choose&quot; multiple&gt; &lt;option value=&quot;&quot;&gt; - &lt;/option&gt; &lt;option value=&quot;1&quot; selected&gt;默认&lt;/option&gt; &lt;option value=&quot;2&quot; disabled&gt;禁选&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;4&lt;/option&gt;&lt;/select&gt; multiple属性该属性允许多选对于 windows：按住Ctrl按钮来选择多个选项 table 标签可以用colgroup&gt;col控制表格的样式，第一个col控制第一竖列，第二个col控制第2竖列123456789101112131415161718192021222324252627&lt;table border=&quot;1&quot;&gt;&lt;colgroup&gt; &lt;col width=200&gt; &lt;col bgcolor=red&gt;&lt;/colgroup&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;得分&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt;&lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小红&lt;/td&gt;&lt;td&gt;80&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;所有人&lt;/td&gt; &lt;td&gt;180&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; pre和code 标签&lt;pre&gt;标签，保留多个空格和回车换行,&lt;pre&gt;显示多行代码，&lt;code&gt;显示一行代码，&lt;pre&gt;可以替代&lt;code&gt; details 标签默认是个三角形▼123456&lt;details&gt; &lt;summary&gt;点我&lt;/summary&gt; &lt;p&gt;loremxxxxxxxxxx&lt;/p&gt; &lt;p&gt;loremxxxxxxxxxx&lt;/p&gt; &lt;p&gt;loremxxxxxxxxxx&lt;/p&gt;&lt;/details&gt; hidden 属性123&lt;p hidden&gt;这是一段隐藏的文字&lt;/p&gt;js用getAttribute('hidden')/setAttribute()/removeAttribute()操作 progress标签html5:progress标签 用于进度条、技能条等的显示1&lt;progress value="22" max="100"&gt;&lt;/progress&gt; figure标签 头像1234&lt;figure&gt; &lt;img src="avatar.jpg" width="60" height="60"&gt; &lt;figcaption&gt;昵称&lt;/figcaption&gt;&lt;/figure&gt;]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>面试题</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 与 Node.js服务器]]></title>
    <url>%2F2018%2F02%2F21%2FTCPIP%E4%B8%8ENodejs%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[TCP/IP 是供已连接因特网的计算机进行通信的通信协议。HTTP 协议的底层其实是由 TCP 协议(规定如何传输)和 IP 协议(规定如何连网)（简称 TCP/IP协议）构建的。TCP和UDP的区别三次握手和四次挥手用node.js做服务器，并发出http响应 资料：菜鸟教程 - 学习TCP/IP TCP 传输控制协议（Transmission Control Protocol）TCP面试题问：TCP 和 UDP 的区别是什么简答：TCP 可靠(能够知道发送的请求是否成功)、面向连接、相对 UDP 较慢；UDP 不可靠，不面向连接、相对 TCP 较快。 补充： 什么叫面向连接呢？事先为所发送的数据开辟出连接好的通道，然后再进行数据发送。【像打电话，只能两人打，第三人打就显示占线。】 非面向连接：是指通信双方不需要事先建立一条通信线路，而是把每个带有目的地址的包（报文分组）送到线路上，由系统自主选定路线进行传输。【就像写信，不管对方有多忙，把信放到邮筒，就与自己无关系了。】 问：TCP 的三次握手指的是什么简答：每次建立连接前，客户端和服务端之前都要先进行三次对话，成功后才开始正式传输内容，三次对话大概是这样的： 客户端：我要连接你了，可以吗（浏览器向服务器发送建立连接的请求。） 服务端：嗯，我准备好了，连接我吧（服务器接收到浏览器发送的请求后，向浏览器发送同意连接的信号。） 客户端：那我真的连接你咯。（浏览器接受到服务器发出的同意连接的信号后，再次向服务器发出确认连接的信号。） 三次握手完成，客户端和服务端成功的建立TCP连接，就可以开始传输数据了。(客户端发送http请求的4个部分给服务端，服务端接收请求并处理后，发送http响应的4个部分给客户端。客户端接收响应) 这是因为，TCP要建立连接，必须确认4件事 客户端可以发请求 服务端可以收请求，服务端可以发请求 客户端可以收请求 问：TCP 的四次挥手指的是什么答： 浏览器向服务器发送一个断开连接的请求（你把我断开吧）； 服务器接到请求后发送确认收到请求的信号（知道了）； 服务器向浏览器发送断开通知（那我把你断开咯？）； 浏览器接到断开通知后断开连接并反馈一个确认信号（嗯，你断吧），服务器收到确认信号后断开连接 为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所以服务器先发送确认信号，等所有数据发送完毕后再同意断开。 IP 网络协议（英语：Internet Protocol）IP 分为「内网 IP」 和「外网 IP」 路由器有两个 IP，一个外网 IP（每次重启路由器后会重新分配一个新的外网IP）和一个内网 IP（192.168.1.1） 127.0.0.1 localhost 本地ip,表示设备自己 还有一个特别特殊的 IP：0.0.0.0，它不表示任何设备。 端口(Port)如果一个服务器既提供 HTTP 服务，又提供 FTP 服务，还提供 SMTP 服务（邮件服务），那么只用一个 IP 是无法告诉服务器你想要使用哪种服务。 所以这里有一个重要的原则：一个端口对应一个服务。 要提供 HTTP 服务使用 80 端口 12访问https://www.baidu.com实际上是访问https://www.baidu.com:80浏览器帮你加了默认端口号 80。 要提供 HTTPS 服务使用 443 端口 要提供 FTP 服务使用 21 端口 总结：使用 HTTP 协议访问另一个 IP 时，必须同时提供 IP 和端口号，缺一不可。 用Node.js创建一个服务器接收请求我们的脚本只需要一个文件就可以搞定 新建一个目录cd ~/Desktop; mkdir node-demo; cd node-demo touch server.js 编辑 server.js，内容我已经上传到 GitHub。 或者curl https://raw.githubusercontent.com/FrankFang/nodejs-test/7f1a0ce15c47a6c2c938fe322f042e5d62bc7d01/server.js &gt; ./node-demo/server.js将代码下载到server.js文件内 运行 node server.js，看到报错 根据报错提示调整你的命令 成功之后，这个 server 会保持运行，持续监听，无法退出 如果你想「中断」这个 server，按 Ctrl + C 即可（C 就是 Cancel 的意思） 中断后你才能输入其他命令 我建议你把这个 server 放在那里别动，新开一个 Bash 窗口，完成下面的教程 curl -s -v -- http://qq.com/xxx?name=ff，其中查询参数是?name=ff,查询参数是包含问号的 好了服务器完成。只不过 这个服务器目前只有一个功能，那就是打印出路径和查询字符串 还缺少一个重要的功能，那就是发出 HTTP 响应 目前我们先只做一个功能玩玩。 接下来你要发起一个请求到这个服务器。这听起来有点怪异，「我向自己发起请求」，目前是的，因为你买不起服务器啊。 在新的 Bash 窗口运行 curl http://localhost:你的指定的端口/xxx?name=yyyy 或者 curl http://127.0.0.1:你指定的端口/xxx?name=yyyy。 你会马上发现 server 打印出了路径： 这说明我们的 server 收到了我们用 curl 发出的请求由于 server 迟迟没有发出响应，所以 curl 就一直等在那里，无法退出（用 Ctrl + C 中断这个傻 curl） 发出响应接下来我们让我们 server 发出响应 编辑 server.js 在中间我标注的区域添加两行代码 12345678910console.log(&apos;方方说：得到 HTTP 路径\n&apos; + path)if (path == &apos;/&apos;) &#123; response.write(&apos;Hi\n&apos;) &#125; else if (path == &apos;/index&apos;) &#123; response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;) response.write(&apos;&lt;!DOCTYPE html&gt;\n&lt;head&gt;&lt;body&gt;&lt;h1&gt;你好&lt;/h1&gt;&lt;/body&gt;&lt;/head&gt;&apos;)&#125; else &#123; response.statusCode = 404&#125;response.end() Ctrl+C 中断之前的 server，重新运行 node server.js 8888 curl http://127.0.0.1:8888/xxx，结果如下：1Hi% 这个 % 不是我们的内容，% 表示结尾。 好了，响应添加成功 使用 curl -s -v -- &quot;http://localhost:8888/xxx&quot; 可以查看完整的请求和响应 根据请求返回不同的响应 响应 / 响应 /xxx 响应 404 响应 /xxx.html 响应 /xxx.frank 再次强调，后缀是废话。文件内容是有 HTTP 头中的 Content-Type 保证的 响应 /xxx.css 响应 /xxx.js HTTP 路径不是文件路径！！！/xxx.html 不一定对应 xxx.html 文件 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)var url = require(&apos;url&apos;)var port = process.argv[2]if(!port)&#123; console.log(&apos;请指定端口号好不啦？\nnode server.js 8888 这样不会吗？&apos;) process.exit(1)&#125;var server = http.createServer(function(request, response)&#123; var parsedUrl = url.parse(request.url, true) var path = request.url var query = &apos;&apos; if(path.indexOf(&apos;?&apos;) &gt;= 0)&#123; query = path.substring(path.indexOf(&apos;?&apos;)) &#125; var pathNoQuery = parsedUrl.pathname var queryObject = parsedUrl.query var method = request.method /******** 从这里开始看，上面不要看 ************/ console.log(&apos;HTTP 路径是\n&apos; + path) if (path == &apos;/style.css&apos;) &#123; response.setHeader(&apos;Content-Type&apos;, &apos;text/css; charset=utf-8&apos;) response.write(&apos;body&#123;background-color: #ddd;&#125;h1&#123;color: red;&#125;&apos;) &#125; else if (path == &apos;/main.js&apos;) &#123; response.setHeader(&apos;Content-Type&apos;, &apos;text/javascript; charset=utf-8&apos;) response.write(&apos;alert(&quot;这是js执行的&quot;)&apos;) &#125; else if (path == &apos;/&apos;) &#123; response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;) response.write(&apos;&lt;!DOCTYPE html&gt;\n&lt;html&gt;&apos;+ &apos;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/style.css&quot;&gt;&lt;body&gt;&apos;+ &apos;&lt;h1&gt;你好&lt;/h1&gt;&apos;+&apos;&lt;script src=&quot;/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/head&gt;&lt;/html&gt;&apos;) &#125; else &#123; response.statusCode = 404 &#125; response.end() /******** 代码结束，下面不要看 ************/&#125;)server.listen(port)console.log(&apos;监听 &apos; + port + &apos; 成功\n请用在空中转体720度然后用电饭煲打开 http://localhost:&apos; + port)]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>http</tag>
        <tag>TCP/IP</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP请求与响应]]></title>
    <url>%2F2018%2F02%2F21%2FHTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[状态码请求与响应参考菜鸟教程资料什么是HTTPS Server + Client + HTTP 浏览器负责发起请求 服务器在 80 端口接收请求 服务器负责返回内容（响应） 浏览器负责下载响应内容 HTTP 的作用就是指导浏览器和服务器如何进行沟通。资料：菜鸟教程 - 学习HTTP 重点 面试题 请求包括 GET(获取) POST(上传) PUT(整体更新) PATCH(局部更新) DELETE(删除) HEAD OPTIONS等 能够手写http请求，能够手写http响应 Content-Type: application/x-www-form-urlencoded : 应用数据/还没有写入规范的格式-万维网-表单-用urlencode形式压缩 知道状态码的含义:123456789101112200 OK:GET时返回，表示响应成功201 created:POST时返回，表示创建成功301 Moved Permanently:请求的资源已被永久的移动到新URI302 Found:请求的资源被临时移走了304 未修改Not Modified：所请求的资源未修改，使用缓存的文档404 Not Found ：无法找到这个网页403 Forbidden ：服务器拒绝执行此请求500 Internal Server Error：服务器内部错误，无法完成请求502 Bad Gateway ：充当网关或代理的服务器，从远端服务器接收到了一个无效的请求（比如服务器关了） HTTP请求发起GET请求 命令行执行curl -s -v -- &quot;https://www.baidu.com&quot;请求内容为：1234GET / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.54.0Accept: */* 发起POST请求 命令行执行curl -X POST -s -v -- &quot;https://www.baidu.com&quot;请求内容为：1234POST / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.54.0Accept: */* 发起带data的POST请求 命令行执行curl -X POST -d &quot;1234567890&quot; -s -v -- &quot;https://www.baidu.com&quot;请求内容为: 12345678POST / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.54.0Accept: */*Content-Length: 10Content-Type: application/x-www-form-urlencoded1234567890 请求的格式1234567891 动词 路径 协议/版本2 Key1: value12 Key2: value22 Key3: value32 Content-Type: application/x-www-form-urlencoded2 Host: www.baidu.com2 User-Agent: curl/7.54.03 4 要上传的数据 请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空） 第三部分永远都是一个回车（\n，作为第2部分与第4部分的分界线 动词有 GET POST PUT PATCH DELETE HEAD OPTIONS 等 这里的路径可以包括「查询参数」，但不包括「锚点」比如GET /s?wd=javascript HTTP/1.1 如果你没有写路径，那么路径默认为 / :GET / HTTP/1.1 第 2 部分中的 Content-Type 标注了第 4 部分的格式 用 Chrome 发请求 打开 Network 地址栏输入网址 在 Network 点击，查看Headers里的 Request Headers，点击「view source」就可以看到请求内容 如果是POST请求，要点Preserve log防止刷新页面后丢失，此时就有第四部分，那么在 FormData 或 Payload 里面可以看到 响应上面三个请求示例，前两个请求对应的响应分别为 对GET的响应用GET请求百度首页后的响应：123456789101112131415HTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: Keep-AliveContent-Length: 2443Content-Type: text/htmlDate: Tue, 10 Oct 2017 09:14:05 GMTEtag: &quot;5886041d-98b&quot;Last-Modified: Mon, 23 Jan 2017 13:24:45 GMTPragma: no-cacheServer: bfe/1.0.8.18Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; 后面太长，省略了…… 对POST的响应用POST请求百度首页后的响应：1234567891011HTTP/1.1 302 FoundConnection: Keep-AliveContent-Length: 17931Content-Type: text/htmlDate: Tue, 10 Oct 2017 09:19:47 GMTEtag: &quot;54d9749e-460b&quot;Server: bfe/1.0.8.18&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; 后面太长，省略了…… GET 请求和 POST 请求对应的响应可以一样，也可以不一样 响应的第四部分可以很长很长很长 响应的格式12345671 协议/版本号 状态码 状态解释2 Key1: value12 Key2: value22 Content-Length: 179312 Content-Type: text/html34 要下载的内容 状态码要背，是服务器对浏览器说的话 123451xx 不常用2xx 表示成功3xx 表示重定向4xx 表示你丫错了（客户端错误）5xx 表示好吧，我错了（服务端错误） 状态解释没什么用 第 2 部分中的 Content-Type 标注了第 4 部分的格式 第 2 部分中的 Content-Type 遵循 MIME 规范 用 Chrome 查看响应 打开 Network 输入网址 选择Headers 查看 Response Headers，点击「view source」 你会看到响应的前两部分 查看 Response 或者 Preview，你会看到响应的第 4 部分 总结http请求与响应的格式12345678910111213141516171819202122232425262728293031323334GET 请求 GET / HTTP/1.1 //GET /?w=xxx HTTP/1.1 查询参数为?w=xxxHost: baidu.comAccept: text/html //请求html格式的文件响应HTTP/1.1 200 OKContent-Type: text/html; charset=utf-8 //响应给我html文件Content-Length: 10000&lt;!DOCTYPE&gt; //html格式的文件&lt;html&gt;......&lt;/html&gt;--------------------------POST 请求POST /login?w=xxx HTTP/1.1Host: baidu.comAccept: application/json //请求一个json格式的页面Content-Type: application/x-www-form-urlencodedContent-Length: 10username=fangfang&amp;password=mima响应HTTP/1.1 403 ForbiddenContent-Type: application/json //返回json格式Content-Length: 200&#123;&quot;erroc&quot;:&quot;错误&quot;&#125; //返回json文件 比喻版12345678910111213工资请求GET 11月工资 工资协议/1.1Host: 百度公司Accept: 现金 (or 支付宝转账, or 银行汇款)工资响应工资协议/1.1 200 OK类型: 现金现金张数: 1010000 httpsHTTP缺点：通信不加密内容会被窃听 不验证通信方的身份，遭遇伪装 无法证明报名完整性，可能回被篡改 所以引入HTTPS HTTP+加密+认证+完整性保护=HTTPS]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>http</tag>
        <tag>请求与响应</tag>
        <tag>状态码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脚本的简单运用]]></title>
    <url>%2F2018%2F02%2F20%2F%E8%84%9A%E6%9C%AC%E7%9A%84%E7%AE%80%E5%8D%95%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[写脚本Bash脚本、Node.js脚本node.js中文文档：http://nodejs.cn/api/ 写一个脚本 找个地方（比如local）新建文件.sh123mkdir ~/localcd ~/localtouch demo.sh 打开并往 demo.sh 里添加以下内容： 12345mkdir demo cd demo mkdir css js touch index.html css/style.css js/main.js exit 运行脚本在任意位置执行 sh ~/local/demo.sh 即可运行此脚本 12cd ~/Desktopsh ~/local/demo.sh 然后你会看到当前目录里多出一个 demo 目录，demo 目录里面还有一些文件 依次运行cd demo,然后在cmd模式下运行tree /f 好了，这个 demo.sh 就是你写出的第一个 Bash 脚本了。 path将 ~/local 添加到 PATH 里 cd ~/local; pwd 得到 local 的绝对路径 创建 ~/.bashrc：touch ~/.bashrc 编辑 ~/.bashrc：start ~/.bashrc，在最后一行添加 export PATH=”local的绝对路径:$PATH” 执行source ~/.bashrc 使其生效 之前你要运行 sh ~/local/demo.sh，现在你只需要运行 demo.sh ，不需要添加路径了 demo.txt 的后缀 .txt 很无聊，删掉它mv ~/local/demo.txt ~/local/demo现在你只要运行 demo 就能执行该脚本了。 细节 文件后缀的作用：毫无作用 PATH 的作用你每次在 Bash 里面输入一个命令时（比如 ls、cp、demo），Bash 都会去 PATH 列表里面寻找对应的文件，如果找到了就执行。 使用 type demo 可以看到寻找过程 使用 which demo 可以看到寻找结果 参数demo 脚本只能创建名字为 demo 的目录，太无聊了，我们让目录名是可变的吧。$1是第一个参数、$2是第二个参数、$3、$4……..12345mkdir $1cd $1mkdir css jstouch index.html css/style.css js/main.jsexit 此时在相应的文件夹里运行demo 参数，比如demo hello 就会在这个文件夹内生成一个名为hello的目录，里面有一些文件 完善版判断是否存在和$1同名的文件夹打开并编辑demo文件123456789101112if [ -d $1 ]; then echo &apos;error: dir exists&apos; exit 0else mkdir $1 cd $1 mkdir css js echo -e &quot;&lt;!DOCTYPE&gt;\n&lt;title&gt;Hello&lt;/title&gt;\n&lt;h1&gt;Hi&lt;/h1&gt;\n&quot; &gt; index.html touch css/style.css js/main.js echo &apos;success&apos; exit 1fi echo -e &quot;abc\ndef&quot; 输出：12abcdef -e表示启用解释反斜杠转义 exit 0 表示没有错误 exit 1 表示错误代码为 1 命令1 &amp;&amp; 命令2 ：命令1执行成功后才会执行命令2 命令1 || 命令2 ：命令1执行失败时，执行命令2 命令1 ; 命令2 : 命令1执行完后，执行命令2 Node.js 写脚本我们在 Bash 命令行里输入 Bash 命令，也可以在 Node.js 命令行里输入 JS 命令（Ctrl + D 退出）Bash 脚本能做的事情，JS 脚本也能做。(sh demo.sh 对应 node demo.js） Node.js命令node 进入node模式 切换目录 console.log(process.cwd()) : 显示当前目录路径，等同于bash里的pwd process.chdir(&quot;/Users/frank/Desktop&quot;) 进入相应的目录，等同于bash里的cd ~/Desktop console.log(1) ：等同于bash里的echo 1 创建目录12let fs = require(&quot;fs&quot;)fs.mkdirSync(&quot;目录名&quot;) 创建文件12let fs = require(&apos;fs&apos;)fs.writeFileSync(&quot;./index.html&quot;, &quot;内容&quot;) .表示当前文件夹 用 JS 脚本来重写 demo.sh 在bash模式下，执行cd ~/local进入目录 touch jsdemo : 创建js脚本 打开jsdemo文件，编辑它内容如下 123456789101112131415var fs = require(&apos;fs&apos;) var dirName = process.argv[2] // 你传的参数是从第 2 个开始的 process.chdir(&quot;/Users/stage/desktop/test&quot;) // cd ~/Desktop/tset fs.mkdirSync(&quot;./&quot; + dirName) // mkdir $1 process.chdir(&quot;./&quot; + dirName) // cd $1 fs.mkdirSync(&apos;css&apos;) // mkdir css fs.mkdirSync(&apos;js&apos;) // mkdir js fs.writeFileSync(&quot;index.html&quot;, &quot;&quot;) fs.writeFileSync(&quot;css/style.css&quot;, &quot;&quot;) fs.writeFileSync(&quot;js/main.js&quot;, &quot;&quot;) process.exit(0) 退出node模式 cd ~/Desktop/目录名 进入需要执行node命令的目录 node ~/local/jsdemo 参数 ：比如node ~/local/jsdemo testFile shebang的作用我们每次执行 ~/local/jsdemo 参数 都要在最前面添加 node 来执行，能不能做到不加 node也能执行呢（也就是指定执行环境），可以，在 jsdemo 里第一行加上这一句即可：#!/usr/bin/env node ：指定这个文件用node模式来执行 1234567891011121314151617#!/usr/bin/env nodevar fs = require(&apos;fs&apos;) var dirName = process.argv[2] // 你传的参数是从第 2 个开始的 process.chdir(&quot;/Users/stage/desktop/test&quot;) // cd ~/Desktop/tset fs.mkdirSync(&quot;./&quot; + dirName) // mkdir $1 process.chdir(&quot;./&quot; + dirName) // cd $1 fs.mkdirSync(&apos;css&apos;) // mkdir css fs.mkdirSync(&apos;js&apos;) // mkdir js fs.writeFileSync(&quot;index.html&quot;, &quot;&quot;) fs.writeFileSync(&quot;css/style.css&quot;, &quot;&quot;) fs.writeFileSync(&quot;js/main.js&quot;, &quot;&quot;) process.exit(0) 然后你就可以直接用 ~/local/jsdemo.js 参数 了（省得输入 node 了） 如果你已经把 ~/local 加入了 PATH，那么甚至可以直接输入 jsdemo 参数 来执行]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git到github的完整操作流程]]></title>
    <url>%2F2018%2F02%2F18%2Fgit%E5%88%B0github%E5%AE%8C%E6%95%B4%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[git的使用，包括add、commit、打标签、创建以及合并分支、push到远程仓库菜鸟教程：Git教程 git常用命令git --version查看git Bash版本号git diff查看做了哪些修改 init → 修改文件 → add → commit git的三种状态：modified修改文件 → add到暂存区 → commit造一颗后悔药 git config -l : 查看配置 git --version : 查看版本号 git init初始化词库：在文件夹右键选择Git Bash Here，运行git init git init file2 :创建一个文件夹file2并同时创建仓库 git clone xxxxxxx : 将github上的xxxxx clone到本地，文件夹名为此项目的repository名字 git clone xxxxxx test3 ：将xxxxx clone into 文件夹test3内，文件夹名就是test3 git ll -ah:此时可以看到当前目录下一个.git文件夹 git status -sb : 查看文件状态。红色??表示该文件还没add过。绿色A表示add过但没commit了 git add . : 将所有修改添加至暂存区。然后运行git status -sb查看此时的状态。绿色A表示add过但没commit了 git commit -m &quot;描述&quot; ：造一颗后悔药 建议使用git commit -v来造后悔药git commit -v可进行多行描述，首行为title，次行开始description。比如首行“做了一些更新”，次行“详细更新了xxxx和xxxx以及xxxx” 组合技 git add . &amp;&amp; git commit -m &quot;描述&quot; ：将add和commit组合使用 git log --oneline : 查看后悔药的id（commit后面的代码），按↑ ↓键查看，按 Q 退出 12345commit f0d95058cd32a332b98967f6c0a701c64a00810a Author: xxxxxx &lt;xxxxxxxx@gmail.com&gt; Date: Thu Sep 28 22:30:43 2017 +0800 完成第一章 git log -p : 查看具体增删了哪些内容 git log --oneline : 在一行简要显示历史节点 git log --all --oneline ： 可以看到master和所有分支上的历史记录 git log --all --graph : 图示全部分支历史记录 git checkout 后悔药的id ：吃一颗后悔药~~ git checkout - : 回退到上一个历史节点 TODO:git checkout 后悔药id 与 git reset 后悔药id --hard的区别 回退操作：https://blog.csdn.net/young_emily/article/details/78299398https://www.cnblogs.com/longtengfly/p/8990954.html 廖雪峰：版本回退 打tag git tag -a 标签名 -m &quot;描述&quot; ：打tag(如果项目比较大，有上百个commit时，给几个重要的后悔药打上tag方便查找，省去了拷贝后悔药id代码) git log --oneline: git tag -a 标签名 -m &quot;描述&quot; 后悔药的id ：给某个历史节点打标签 git tag : 列出所有tag git show 标签名 ：git show v1 查看v1的具体详情（记得↑ ↓翻页） git checkout 标签名 ：吃一颗后悔药~ 比如git checkout v1(省去了拷贝后悔药id代码) 分支branch用于多人协作假设在开发V3版时，发些V2版存在一些bug，那么可以在V2版上创建分支用来修复V2的bug，然后与后期的版本合并 git branch 分支名 ：在master主干上创建分支 git checkout 分支名 ：进入分支 组合技 git checkout -b 分支名 ：创建并进入新建的分支 在3 not rich commit造完后悔药后，创建一个rich的分支并进入git branch rich &amp;&amp; git checkout rich 此时就是在rich分支上操作了，修改not rich为rich，然后add → commit git checkout master : 回到master分支 git log --all --oneline ： 可以看到master和所有分支上的历史记录 git log --all --graph : 图示全部分支历史记录 在master分支下，运行 git merge xxx ：将xxx分支与master合并,合并完之后再次add和commit 上传到远程仓库github视频教程 ： 点我 git remote add origin git@github.com:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx/git-demo-1.git ：将本地仓库上传至远程仓库 git pull : 把远程仓库中最新的更改拖下来，然后在此基础上编辑文件，完成后add和commit git push -u origin master ：上传到远程仓库 clear 或者 Ctrl + L :清屏 将分支上传到githubgit checkout 分支名：进入分支git add . &amp;&amp; git commit -m &#39;描述&#39;git push origin 分支名 修改github远程仓库名称(重命名仓库)12345678# 1.在Github页面中，进入要修改的仓库，在页面上方选择“Settings”，即可重命名远程仓库。# 2.本地删除原来的仓库链接地址git remote rm origin # 3.修改为新的仓库地址git remote add origin git@github.com:your_account_name/new_repo_name.git git push -u origin master 同步Coding12345678# origin 远端git remote add origin https://github.com/harry0071/test.git# 添加一个名为 both 的远端git remote add both https://git.coding.net/harry0071/test.gitgit remote set-url --add --push both https://git.coding.net/harry0071/test.gitgit remote set-url --add --push both https://github.com/harry0071/test.git 之后在推送的时候科研用git push both实现二者同步更新 修改github上项目的语言类型在github上，如果未指定语言，它会根据某种语言的代码量来决定是哪种语言的项目手动修改语言类型：123456# 1.首先在根目录创建.gitattributes文件# 2.在该文件中写上*.js linguist-language=vue *.css linguist-language=vue *.html linguist-language=vue 意思是将.js、css、html当作vue语言来统计 展示build目录下的文件在package.json中添加&quot;homepage&quot; : &quot;http://harry0071.github.io/仓库名/build&quot;然后就能打开http://harry0071.github.io/仓库名/build/index.html 总结 git init：初始化本地仓库 git add . &amp;&amp; git commit -m ‘描述内容’ git pull git push 回退方法如下 1234567891011121314151617181920A、B、C、D代表后悔药idA --- B --- C --- D (HEAD)git reset --hard Bgit reset --soft D第一个操作执行后状态如下A --- B (HEAD)第二个操作后状态如下A --- B --- C --- D --- B' (HEAD)接着 git commit，得到如下状态A --- B --- C --- D --- B'然后就可以 git push 了 知乎：警惕 错误的Git版本回退姿势]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令以及偷懒小技巧]]></title>
    <url>%2F2018%2F02%2F17%2Fgit%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%81%B7%E6%87%92%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[本文简单介绍了git与github的配置，以及如何将本地仓库与github连接起来。还介绍了git常用的一些命令，以及如何简化git命令参考资料: 饥人谷菜鸟教程：Git教程 配置 GitHub (SSH Key) 进入 https://github.com/settings/keys 如果页面里已经有一些 key，就点「delete」按钮把这些 key 全删掉。如果没有，就往下看 点击 New SSH key，你需要输入 Title 和 Key，但是你现在没有 key，往下看 打开 Git Bash 按照 https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/ 的教程 运行 ssh-keygen -t rsa -b 4096 -C &quot;你的邮箱&quot;，注意填写你的邮箱！ 按回车三次 运行 ll ~/.ssh,可以看到生成了id_rsa(钥匙)和id_rsa.pub(锁) 运行 cat ~/.ssh/id_rsa.pub，得到一串东西，完整的复制这串东西 回到上面第 3 步的页面，在 Title 输入「win7上的ssh」 在 Key 里粘贴刚刚你你复制的那串东西 点击 Add SSH key 回到 Git Bash 运行 ssh -T git@github.com，用你电脑上的钥匙打开上传到github的锁，你可能会看到这样的提示：输入 yes 回车 然后如果你看到 Permission denied (publickey). 就说明你失败了，请回到第 1 步重来，是的，回到第 1 步重来；如果你看到 Hi FrankFang! You’ve successfully authenticated, but GitHub does not provide shell access. 就说明你成功了！ 一台电脑只需要一个 SSH key 一个 SSH key 可以访问你的所有仓库，即使你有 1000000 个仓库，都没问题 如果你新买了电脑，就在新电脑上重新生成一个 SSH key，把这个 key 也上传到 GitHub，它可以和之前的 key 共存在 GitHub 上 如果你把 key 从电脑上删除了，重新生成一个 key 即可，替换之前的 key Git的配置与使用配置Gitgit --version :查看当前git版本号 123456789git config --global user.name 你的英文名git config --global user.email 你的邮箱git config --global push.default matchinggit config --global core.quotepath falsegit config --global core.editor "vim"git config --global http.postBuffer 524288000git config --global http.proxy http://127.0.0.1:1080 #设置代理git config --global https.proxy http://127.0.0.1:1080git config --global --unset http.proxy #删除代理 五句话，依次运行。不执行的话，电脑可能会爆炸你信不信。 git config -l : 查看配置git config --global -l：查看全局配置 只在本地使用Gitgit --version查看git Bash版本号 步骤 创建目录作为我们的项目目录：mkdir git-demo-1 进入目录 cd git-demo-1 git init，初始化这句命令会在 git-demo-1 里创建一个 .git 目录 ls -la 你就会看到 .git 目录，它就是一个「仓库」，不要进去看，这仓库里面有毒，别进去！ 在 git-demo-1 目录里面添加任意文件，假设我们添加了两个文件，分别是 index.html 和 css/style.css 123touch index.htmlmkdir csstouch css/style.css 运行 git status -sb查看文件状态， 可以看到文件前面有 ?? 号 123## Initial commit on master?? css/?? index.html 这个 ?? 表示 git 一脸懵逼，不知道你要怎么对待这些变动。 使用 git add 将文件添加到「暂存区」你可以一个一个地 add12git add index.htmlgit add css/style.css 你也可以一次性 addgit add . 意思是把当前目录（.表示当前目录）里面的变动都加到「暂存区」 再次运行 git status -sb，可以看到 ?? 变成了 A123## Initial commit on masterA css/style.cssA index.html A 的意思就是添加，也就是说你告诉 git，这些文件我要加到仓库里 使用 git commit -m &quot;信息&quot;将你 add 过的内容「正式提交」到本地仓库（.git就是本地仓库），并添加一些注释信息，方便日后查阅你可以一个一个地 commit12git commit index.html -m &apos;添加index.html&apos;git commit css/style.css -m &quot;添加 css/style.css&quot; 你也可以一次性 commitgit commit . -m &quot;添加了几个文件&quot; 建议使用git commit -v来提交git commit -v可进行多行描述，首行为title，次行开始description。比如首行“做了一些更新”，次行“详细更新了xxxx和xxxx以及xxxx” 再再次运行 git status -sb，发现没有文件变动了，这是因为文件的变动已经记录在仓库里了。 这时你使用 git log 就可以看到历史上文件的变动：12345commit f0d95058cd32a332b98967f6c0a701c64a00810aAuthor: xxxxxx &lt;xxxxxxxx@gmail.com&gt;Date: Thu Sep 28 22:30:43 2017 +0800 添加几个文件 按↑ ↓键查看，按 Q 退出 运行history可以看到历史上输入过的命令 运行start css/style.css 会使用默认的编辑器编辑style.css，保存 运行git status -sb,可以看到style.css前面一个红色的M(Modified)，代表文件有过变动但未add到仓库 12## masterM css/style.css 运行git add style.css,可以看到红色的M变成了绿色的M，表示变动过的文件将添加到「暂存区」 运行git commit -m &quot;改动style.css&quot;这个改动就被提交到 .git 本地仓库了 再再次运行 git status -sb，会发现没有变更了，这说明所有变动都被本地仓库记录在案了。 删除文件rm style.css 运行git add style.css，将删除结果add到仓库 git status -sb，会发现前面有个绿色的D(Delete) 运行git commit -m &quot;删除style.css&quot; 总结 git init，初始化本地仓库 .git git status -sb，显示当前所有文件的状态 git add 文件路径，用来将变动加到暂存区 git commit -m &quot;信息&quot;，用来正式提交变动，提交至 .git 仓库 如果有新的变动，我们只需要依次执行 git add xxx 和 git commit -m &#39;xxx&#39; 两个命令即可。别看本教程废话那么多，其实就这一句有用！先 add 再 commit，行了，你学会 git 了。 git log 查看变更历史 将本地仓库上传到 GitHub如何将我们这个 git-demo-1 上传到 GitHub 呢？ 步骤 在 GitHub 上New一个repository，名称随意，一般跟本地目录名一致按照截图所示，除了仓库名，其他的什么都别改，其他的什么都别改，其他的什么都别改，其他的什么都别改，这样你才能创建一个空仓库 点击创建按钮之后，GitHub 就会把后续的操作全告诉你，如图 看图，点击 SSH 按钮，点击 SSH 按钮，点击 SSH 按钮，我想你现在肯定不会忘了点击 SSH 按钮了吧~~~~如果不点击这个按钮，你就会使用默认的 HTTPS 地址。但是千万不要使用 HTTPS 地址，因为 HTTPS 地址使用起来特别麻烦，每次都要输入密码，而 SSH 不用输入用户名密码。为什么 SSH 不用密码呢，因为你已经上传了 SSH public key。还记得吗？如果不记得，翻到本文第一部分「配置 GitHub」章节。 由于我们上之前创建过本地仓库了，所以看图，图中下面半部分就是你需要的命令，我们一行一行拷贝过来执行 找到图中的「…or push an existing repository from the command line」这一行，你会看到 git remote add origin https://github.com/xxxxxxxxxx/git-demo-1.git， 如果你发现这个地址是 https 开头的，那你就做错了，还记得吗，我们要使用 SSH 地址，GitHub 的 SSH 地址是以 git@github.com 开头的。 再次点击 SSH 按钮，不管我强调多少遍，总会有人忘记点击 SSH 按钮，为什么呢？我也不知道，为了防止你忘了点击 SSH 按钮，我最后再说一遍，「点击 SSH按钮」，点击之后，整个世界就会变得美好起来。 得到新的命令 git remote add origin git@github.com:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx/git-demo-1.git，复制并运行它 复制第二行 git push -u origin master，运行它 刷新当前页面，你的仓库就上传到 GitHub 了！是不是特别简单？只要你按照我说的做，一丝不苟，即可。 直接在 GitHub 创建一个仓库，然后下载到本地步骤 在GitHub 上新建一个仓库 git-demo-2，这次就不创建空仓库了，而是自带 README 和 Lisence 的仓库，创建截图如下：请按图中所示，填写一模一样的内容，然后点击创建按钮。 这样一来，这个仓库就会自动拥有三个文件： 这三个文件的作用请自行了解：.gitignore 的作用、README.md 的作用 以及 LISENCE 的作用 运行git clone 以git@github.com开头的地址运行完了你就会发现，桌面上多出一个 git-demo-2 目录。 cd git-demo-2 进入这个多出来的目录 运行 ls -la 你会看到，远程目录的所有文件都在这里出现了，另外你还看到了 .git 本地仓库。这时你就可以添加文件，git add，然后 git commit 了。 总结 git clone git@github.com:xxxx，下载仓库 git init，初始化本地仓库 .git git status -sb，显示当前所有文件的状态 git add 文件路径，用来将变动加到暂存区 git commit -m “信息”，用来正式提交变动，提交至 .git 仓库 如果有新的变动，我们只需要依次执行 git add xxx 和 git commit -m ‘xxx’ 两个命令即可。别看本教程废话那么多，其实就这一句有用！先 add 再 commit，行了，你学会 git 了。 git log 查看变更历史 如何上传更新你在本地目录有任何变动，只需按照以下顺序就能上传到github：1234git add 文件路径git commit -m &quot;信息&quot;git pull （相信我，你一定会忘记这一个命令）获取远程仓库最新文件git push 下面是例子1234567cd git-demo-1touch index2.htmlgit add index2.htmlgit commit -m &quot;新建 index2.html&quot;git pull退出vim: esc + : + w + qgit push 然后你去 git-demo-1 的 GitHub 页面，就能看到 index2.html 出现在里面了。是不是很……简……单……呢…… 其他Git命令 git remote add origin git@github.com:xxxxxxx.git 将本地仓库与远程仓库关联 git remote set-url origin git@github.com:xxxxx.git 上一步手抖了，可以用这个命令来挽回 git branch 新建分支 git merge 合并分支 git stash 通灵术 git stash pop 反转通灵术 git revert 后悔了 git reset 另一种后悔了 git diff 查看详细变化 git操作偷懒技巧通过~/.bashrc 文件可以简化git操作 自动运行 首先 touch ~/.bashrc 创建一下这个文件 start ~/.bashrc 选用编辑器编辑这个文件，内容为 echo &#39;Hi&#39; 你也可以用命令行编辑文件 echo &quot;echo &#39;hi&#39;&quot; &gt;&gt; ~/.bashrc 关闭退出 Git Bash，然后打开 Git Bash，是不是看到了 Hi，这说明每次进入 Git Bash，就会优先运行 ~/.bashrc 里面的命令 重新编辑 ~/.bashrc，内容改为 cd ~/Desktop，重启 Git Bash，有没有发现默认就进入桌面目录了？ 你可以用 ~/.bashrc 在进入 Git Bash 前执行任何命令，十分方便。 alias(简写) 在 ~/.bashrc 里新增一行 alias f=&quot;echo &#39;frank is awesome&#39;&quot;，等于号两边不能有空格，你最好一个字都不要错。 运行 source ~/.bashrc，作用是执行 ~/.bashrc 运行 f，就会看到 frank is awesome 也就是说，现在 f 就是 echo ‘frank is awesome’ 的缩写了，利用这个技巧，我们可以把很多常见的命令缩写一下，比如1234567alias la=&apos;ls -a&apos;alias ll=&apos;ls -l&apos;alias gst=&apos;git status -sb&apos;alias ga=&apos;git add&apos;alias ga.=&apos;git add .&apos;alias gc=&apos;git commit&apos;alias gc.=&apos;git commit .&apos; 保存退出，然后运行 source ~/.bashrc 这样一来，你的 Git 操作就会简单很多：12345ga 1.txtga .gc 1.txtgc.gst 永久alias上面的方法需要每次运行source ~/.bashrc,改用bash_profile可以配置永久alias touch ~/.bash_profile start ~/.bash_profile 用编辑器打开.bash_profile 填入alias !注意：等于号两边不能有空格1234567alias gi='git init'alias gac='git add . &amp;&amp; git commit -m'alias gst='git status -sb'alias gpp='git pull &amp;&amp; git push --progress'alias gl='git log --oneline'alias gc='git commit -m'alias gdist='git subtree push --prefix=dist origin gh-pages' 环境变量还可以在 ~/.bashrc 里面设置一些环境变量，比如你可以在 ~/.bashrc 里面添加一行 export SASS_BINARY_SITE=&quot;https://npm.taobao.org/mirrors/node-sass&quot;那么以后你安装 node-sass 的时候就不会因为被墙而报错了。以后会用到的，现在先说一下。 设置 PATHexport PATH=&quot;目录的绝对路径:$PATH&quot;可以在 PATH 里添加一个目录，不要运行，等用到的时候再来查。 其他命令1 &amp;&amp; 命令2 ：命令1执行成功后才会执行命令2命令1 || 命令2 ：命令1执行失败时，执行命令2命令1 ; 命令2 : 命令1执行完后，执行命令2]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行(CLI)基础及常用命令]]></title>
    <url>%2F2018%2F02%2F16%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[介绍了cmd，gitBash命令行(CLI)的一些基础知识，以及常用的一些命令 参考资料: 饥人谷 基本概述~ / . .. $ 的意思 ~/desktop : 其中的 ~ 表示电脑的username，所以这句命令等同于stage/desktop . : 当前目录 .. : 上级目录，cd ..表示进入上级目录常见单词英文翻译directory目录、文件夹file文件make新建remove删除move移动copy复制list罗列link链接find查找echo发出回音、重复touch触摸change改变 单词缩写命令全写缩写创建目录make directorymkdir删除removerm移动 / 重命名movemv复制copycp罗列listls改变目录change directorycd， windows下用cd %userprofile%\desktop进入桌面 缩写规则就是：删掉元音字幕（A E I O U），保留前 2 到 3 个辅音字母 基础命令 cd ~/Desktop 进入桌面1.1 cmd直接cd desktop mkdir demo-1 创建目录，这时你可以切到桌面，看到 demo-1 目录 rm -rf demo-1 删除目录【-r表示递归，循环删除直至删光，-f表示强制，不提示yes/no】 touch 1.txt 创建文件4.1 cmd用echo x &gt; xxx.txt mv 1.txt 2.txt 这样我们就把 1.txt 移到 2.txt 了，也就是重命名 cp js/main.js vendor,将js目录下的main.js复制到vendor目录下6.1 cmd用copy，比如copy C:\Users\stage\Desktop\hello\目录1&gt;1.txt C:\Users\stage\Desktop\hello，将目录1里的1.txt复制到hello目录内 Linux常用命令(重点！！！)操作命令进入目录cd显示当前目录的详细路径pwd创建目录mkdir 目录名创建特殊名字的目录(比如带空格的文件名)mkdir “目 录名” : mkdir &quot;file 1&quot;创建多个目录mkdir 目录名1 目录名2 :mkdir file1 file2 file3创建深层次目录mkdir -p 目录路径：举个栗子 mkdir -p file1/file2/file3我是谁,显示用户名whoami清屏clear 或者 Ctrl + L––显示文件夹里的内容ls 文件夹路径 : ls显示当前文件夹里的内容，查看指定路径文件夹里的内容ls file1/file2查看文件夹里的所有内容，包括隐藏的ls -a 文件夹路径显示文件夹详细信息ls -l 文件夹路径 ： drwxr表示directory(d开头表示目录，-开头表示非目录)、read可读、write可写、x可运行显示详细信息，包括隐藏的文件ls -la 文件夹路径––创建文件echo ‘1’ &gt; 文件路径 ：echo &#39;xxx&#39; &gt; 1.txt追加文件内容echo ‘1’ &gt;&gt; 文件路径创建文件touch 文件名改变文件更新时间touch 文件名––复制文件cp 源路径 目标路径 : cp 1.txt 2.txt将1.txt里的内容复制到2.txt，cp js/main.js vendor,将js目录下的main.js复制到vendor目录下复制目录cp -r 源路径 目标路径 ： cp -r file1 file2––重命名文件名mv 原文件名 修改后的文件名 : mv 1.txt 2.txt––删除文件rm 文件路径 : rm 1.txt强制删除文件rm -f 文件路径删除目录rm -r 目录路径强制删除目录rm -rf 目录路径––【windows不支持】查看当前目录结构tree【windows不支持】建立软链接，相当于创建一个双胞胎目录ln -s 真实文件 双胞胎文件 ：ln -s demo demo-copy––下载文件curl -L https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js &gt; jq.js【将jq源码下载下来并保存到jq.js】拷贝网页wget -p -H -e robots=off https://www.baidu.com磁盘占用df -kh当前目录大小du -sh .各文件大小du -h cmd命令行进入目录如果要进入E:\aaa\bbb\ccc首先要输入e:,进入E盘然后在进入目录cd E:\aaa\bbb\ccc,你也可以直接cd 把文件夹拖进来【总之，不能直接cd 路径，必须先进入相对应的磁盘，才能cd】 树形列表： tree 路径：只展示目录 tree /f 路径:深度展示 tree /f 路径&gt; tree.txt：把生成的文件目录树形结构写入到tree.txt文件中 批量合并文件copy /b E:\aaa\bbb\*.ts E:\aaa\bbb\together.ts 批量删除文件del E:\aaa\bbb\000*.ts]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行(CLI)的安装和配置方法]]></title>
    <url>%2F2018%2F02%2F15%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[归纳总结了下 git、git bash、node、npm 的安装和配置方法.nrm 参考资料: 饥人谷 本文参考 饥人谷 的文章后整理归纳了一下，主要包括git、git bash、node、npm的使用和配置方法。 Git Bash的使用第一种使用方式找一个目录，在目录上右键点击，然后选中「Git Bash Here」，即可用 Git Bash 打开这个目录。试试输入 touch 1.txt，回车后可以看到目录里多了一个touch 1.txt文件。 第二种使用方式直接打开 Git Bash，输入 cd ~/Desktop 即可来到桌面所在的目录。试试输入 touch 1.txt，回车后看看桌面上是不是多了一个文件。 Linux常用命令新建文件夹：mkdir my-dir 删除文件夹：rm -rf my-dir 创建文件：echo &quot;hello&quot; &gt; newFile.txt 创建空内容文件: touch file.txt 重命名: mv 1.txt 2.txt ,将1.txt重命名为2.txt 删除文件：rm newFile.txt 进入文件夹: cd my-dir 运行文件: start file.txt 显示文件夹内所有的文件: ls 清屏: clear 中断/退出模式: ctrl + C 关闭git bash: ctrl + D 或者输入 exit 进入node模式: node 进入npm模式: npm 安装Node.js从官网下载node.js然后查看高级系统设置 –&gt; 环境变量 –&gt; 系统变量 –&gt; PATH –&gt; 编辑，可以看到里面有nodejs 使用第一种使用方法 进入 Git Bash 输入 node，回车，就可以进入 node 运行环境，这个时候我们就可以写 JS 了 试试写最简单的 JS 语句，比如 1+2，回车 2 * 8，回车 node的另一种使用方法我们可以先创建一个 JS 文件，然后让 node 运行 来到桌面：cd ~/Desktop 新建一个目录用来玩耍：mkdir hello-node 进入这个目录：cd hello-node 新建一个有内容的 JS 文件：echo &quot;console.log(&#39;Hi, Node.js&#39;)&quot; &gt; main.js，那么 main.js 就新建成功了 输入 node main.js，回车，node 就会执行这个 main.js 文件，你会看到「Hi, Node.js」字样 玩完了，删除 hello-node：cd .. ; rm -rf hello-node npm的配置和使用配置打开 Git Bash，依次输入以下命令，按回车：1234npm config set registry https://registry.npm.taobao.org/npm config set loglevel httpnpm config set progress falsenpm config set strict-ssl false npm 的配置被存储在 ~/.npmrc，你可以随时改。 npm的使用我们可以用 npm 的翻译工具做一个随时可用的小字典，这个小工具的名字叫做 fanyi。 打开Git Bash，运行 npm i -g fanyi 即可安装 fanyi，安装完成之后，输入 fanyi frontend 就可以看到对应的中文释义了！ 是不是很帅呢？！ 使用nrm切换镜像仓库github:nrm 安装nrmnpm install -g nrm 使用nrm nrm ls:查看有哪些镜像仓库 nrm test：测试速度 nrm use taobao：使用taobao镜像 Git的配置和使用配置请在命令行运行这五句话！！！一定要运行这五句话，不然 git 就不能用了12345git config --global user.name xxx #方便产品经理找（怼）你git config --global user.email yyy #方便产品经理找（怼）你git config --global push.default simple # 本来我写的是 matching，不过想了想可能 simple 更好git config --global core.quotepath false #防止文件名变成数字git config --global core.editor &quot;vim&quot; # 使用vim编辑提交信息 git config -l : 查看配置信息 这样就可以愉快地使用git了~ Git的使用使用 在本地新建一个文件夹 test ，在文件夹上右键点击，然后选中「Git Bash Here」 在github上新建一个仓库New repository 在已经打开的Git Bash内输入123456echo &quot;# test&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://github.com/harry0071/test.gitgit push -u origin master 最后一段代码 git push -u origin master 回车后会询问 yes/no ,输入yes此时如果报错的话，需要SSH Key解决办法： 进入github的 Settings &gt;&gt;&gt; 点击右侧的 SSH and GPG keys &gt;&gt;&gt; 点击New SSH key &gt;&gt;&gt; 进入 https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/ 按照网页提示在Git Bash内输入:ssh-keygen -t rsa -b 4096 -C &quot;改成自己的邮箱@example.com&quot; ，接着按3次回车，直至出现冒泡泡的画面 将生成的SSH key cat下来: cat ~/.ssh/id_rsa.pub 回到第1步将生成的SSH key粘贴进去 重新运行`git push -u origin master 常用命令git init: 把用Git Bash打开的本地文件夹变成Git可以管理的仓库git add 1.txt 2.txt: 将文件提交至暂存区,可以一次添加多个文件git add .: 将文件夹内的所有文件添加到暂存区git commit -m &quot;本次更新内容&quot;: 把add的文件一次性打包提交至本地版本库，-m后面输入的是本次更新的说明注释git push origin master: 将本地仓库推送到Github仓库git rm 1.txt: 删除一个文件git checkout -- 1.txt: 把误删的文件恢复到最新版本git rm 1.txt + git commit -m &quot;remove&quot;: 彻底删除文件]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime中如何使用terminal教程]]></title>
    <url>%2F2018%2F02%2F08%2Fsublime%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8terminal%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.安装terminal首先在sublime text3 中安装terminalctrl+shift+P打开package control面板,输入pci进入安装插件列表，输入terminal找到插件安装 2.配置terminalterminal默认调用系统自带的PowerShell，接下来我们改成cmd.exe 安装完成后在工具菜单选择“Preferences(首选项)”–“Package Settings”–“Terminal”–“Settings - User” 在里面输入打开cmd命令窗口的脚本，然后ctr+s保存。12345&#123; &quot;terminal&quot;: &quot;c:\\WINDOWS\\system32\\cmd.exe&quot;, &quot;parameters&quot;: [&quot;/START&quot;,&quot;%CWD%&quot;] &#125; 3.启动terminal现在我们打开sublime，使用ctrl+shift+t就可以打开cmd命令窗口了 4.更多关于terminal详情关于sublime的terminal插件的更多安装及配置方法:百度经验Github]]></content>
      <categories>
        <category>sublime</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漂亮的弹窗插件 —— SweetAlert教程]]></title>
    <url>%2F2018%2F02%2F08%2Fsweetalert%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[SweetAlert可以替代JavaScript原生的alert和confirm等函数呈现的弹出提示框，它将提示框进行了美化，并且允许自定义，支持设置提示框标题、提示类型、内容展示图片、确认取消按钮文本、点击后回调函数等。官方网站: https://sweetalert.js.org/Github: https://github.com/t4t5/sweetalert中文教程站: http://mishengqiang.com/sweetalert/ 使用方法1.引入(我用的CDN引入)12&lt;link href="https://cdn.bootcss.com/sweetalert/1.1.3/sweetalert.min.css" rel="stylesheet"&gt;&lt;script src="https://cdn.bootcss.com/sweetalert/1.1.3/sweetalert.min.js"&gt;&lt;/script&gt; 2.使用简称函数swal调用sweetAlert123456789101112swal(&#123; title: "确定删除吗？", text: "你将无法恢复该虚拟文件！", type: "warning", showCancelButton: true, confirmButtonColor: "#DD6B55", confirmButtonText: "确定删除！", closeOnConfirm: false&#125;,function()&#123; swal("删除！", "你的虚拟文件已经被删除。", "success"); &#125;); 3.举个栗子 html代码 1234567891011121314151617181.基本信息：&lt;button id="demo1"&gt;试一试&lt;/button&gt; &lt;br /&gt;2.带有文字的标题：&lt;button id="demo2"&gt;试一试&lt;/button&gt; &lt;br /&gt;3.成功提示：&lt;button id="demo3"&gt;试一试&lt;/button&gt; &lt;br /&gt;4.带有“确认”按钮的功能的警告消息：&lt;button id="demo4"&gt;试一试&lt;/button&gt; &lt;br /&gt;5.通过传递参数，您可以执行一些其他的事情比如“取消”。：&lt;button id="demo5"&gt;试一试&lt;/button&gt; &lt;br /&gt;6.一个有自定义图标的消息：&lt;button id="demo6"&gt;试一试&lt;/button&gt; &lt;br /&gt;7.自定义HTML信息：&lt;button id="demo7"&gt;试一试&lt;/button&gt; &lt;br /&gt;2秒后关闭：&lt;button id="demo8"&gt;试一试&lt;/button&gt; &lt;br /&gt;8.更换“提示”功能: &lt;button id="demo9"&gt;试一试&lt;/button&gt; &lt;br /&gt;9.使用加载程序（例如，用于AJAX请求）: &lt;button id="demo10"&gt;试一试&lt;/button&gt; &lt;br /&gt; js代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107document.getElementById("demo1").onclick = function() &#123; swal("这是一个信息提示框!")&#125;;document.getElementById("demo2").onclick = function() &#123; swal("这是一个信息提示框!", "很漂亮，不是吗？")&#125;;document.getElementById("demo3").onclick = function() &#123; swal("干得好", "你点击了按钮!", "success")&#125;;document.getElementById("demo4").onclick = function() &#123; swal(&#123; title: "你确定？", text: "您将无法恢复这个虚构的文件！", type: "warning", showCancelButton: true, confirmButtonColor: "#DD6B55", confirmButtonText: "是的，删除！", closeOnConfirm: false &#125;, function() &#123; swal("删除!", "您的虚构文件已被删除！", "success") &#125;)&#125;;document.getElementById("demo5").onclick = function() &#123; swal(&#123; title: "你确定？", text: "您将无法恢复这个虚构的文件！", type: "warning", showCancelButton: true, confirmButtonColor: "#DD6B55", confirmButtonText: "是的，删除！", cancelButtonText: "不，取消", closeOnConfirm: false, closeOnCancel: false &#125;, function(isConfirm) &#123; if (isConfirm) &#123; swal("删除!", "您的虚构文件已被删除！", "success") &#125; else&#123; swal("取消!", "您的虚构文件是安全的！", "error") &#125; &#125;)&#125;;document.getElementById("demo6").onclick = function() &#123; swal(&#123; title: "Sweet!", text: "这里是自定义图像!", imageUrl: "img/thumbs-up.jpg" &#125;)&#125;;document.getElementById("demo7").onclick = function() &#123; swal(&#123; title: "HTML &lt;small&gt;标题&lt;/small&gt;!", text: "A custom &lt;span style='color:pink'&gt;html&lt;span&gt; message.", html: true &#125;)&#125;;document.getElementById("demo8").onclick = function() &#123; swal(&#123; title: "自动关闭警报!", text: "2秒后自动关闭", timer: 2000, showConfirmButton: false &#125;)&#125;;document.getElementById("demo9").onclick = function() &#123; swal(&#123; title: "请输入！", text: "填写一些信息", type: "input", showCancelButton: true, closeOnConfirm: false, animation: "slide-from-top", inputPlaceholder: "请输入..." &#125;, function(inputValue) &#123; if (inputValue === false) &#123; return false; &#125; if (inputValue === "") &#123; swal.showInputError("内容不能为空！"); return false; &#125; swal("Nice!", "你输入的是：" + inputValue, "success") &#125;)&#125;;document.getElementById("demo10").onclick = function() &#123; swal(&#123; title: "AJAX请求实例", text: "提交运行Ajax请求", type: "info", showCancelButton: true, closeOnConfirm: false, showLoaderOnConfirm: true &#125;, function() &#123; setTimeout(function() &#123; swal("AJAX请求完成！"); &#125;, 2000) &#125;)&#125;; 效果预览 更多详情可以去中文教程站查看更多详情,里面包括了各种配置和方法，以及示例中文教程站: http://mishengqiang.com/sweetalert/ sweetalert2https://github.com/sweetalert2/sweetalert2 直接引入https://cdn.bootcss.com/limonte-sweetalert2/7.20.5/sweetalert2.all.min.js，不需要分别引入css和js了 例子12345678swal(&#123; title:'下面是您的预览链接', input: 'textarea', inputValue:'123', confirmButtonText:`&lt;a style="color:white;" href="//www.baidu.com"&gt;预览&lt;/a&gt;`, showCancelButton: true, cancelButtonText:'确定',&#125;) 【点击查看例子】 上面的例子也可以用then1234567swal(&#123; ..........&#125;).then((result)=&gt;&#123; if(result.value)&#123; open('//www.baidu.com'); &#125;&#125;);]]></content>
      <categories>
        <category>效果及美化</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>jq</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next主题个性化教程:打造炫酷网站]]></title>
    <url>%2F2018%2F02%2F08%2Fhexonext%2F</url>
    <content type="text"><![CDATA[看到有些next主题的网站很炫酷，那么是怎么配置的呢？接下来我会讲一讲如何实现一些炫酷的效果 主要有以下32种： 在右上角或者左上角实现fork me on github添加RSS添加动态背景实现点击出现桃心效果修改文章内链接文本样式修改文章底部的那个带#号的标签在每篇文章末尾统一添加“本文结束”标记修改作者头像并旋转博文压缩修改代码块自定义样式侧边栏社交小图标设置主页文章添加阴影效果在网站底部加上访问量添加热度网站底部字数统计添加 README.md 文件设置网站的图标Favicon实现统计功能添加顶部加载条在文章底部增加版权信息添加网易云跟帖(跟帖关闭，已失效，改为来必力)隐藏网页底部powered By Hexo / 强力驱动修改网页底部的桃心文章加密访问添加jiathis分享博文置顶修改字体大小修改打赏字体不闪动自定义鼠标样式为博客加上萌萌的宠物DaoVoice 在线联系点击爆炸效果 详细配置请参考: https://www.jianshu.com/p/f054333ac9e6]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日期时间控件jQuery datetimepicker的使用简介]]></title>
    <url>%2F2018%2F02%2F08%2Fjquerydatetimepicker%2F</url>
    <content type="text"><![CDATA[datetimepicker是一个配置灵活的日期选择插件，你可以定义它的展示方式，包括日期格式、语言、限制选择日期范围、添加相关按钮以及其它导航等 此项目的Github地址：https://github.com/xdan/datetimepicker演示地址: https://xdsoft.net/jqplugins/datetimepicker/ 使用方法1.添加引用添加jquery.js、datetimepicker.js和datetimepicker.css到您的页面123&lt;link href="https://cdn.bootcss.com/jquery-datetimepicker/2.5.17/jquery.datetimepicker.min.css" rel="stylesheet"&gt;&lt;script src="https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/jquery-datetimepicker/2.5.17/jquery.datetimepicker.full.min.js"&gt;&lt;/script&gt; 2.创建input元素1&lt;input id="datetimepicker" type="text" &gt; 3.设置成中文1$.datetimepicker.setLocale('zh'); 4.启用插件1$('#datetimepicker').datetimepicker(); 按以上步骤我们就实现jquery datetimepicker的使用，当然这只是最基本的样式，另外jquery datetimepicker的样式控制是通过传一个json对象的参数给datetimepicker来实现的。下面我们举个例子来看下：1$("#start").datetimepicker(&#123; format: 'Y/m/d', timepicker: false &#125;); 上面传入的参数设置只显示年月日，以及弹出层只能选择日期，而不能选择时间。 那我们接下来总结一下它常用的一些参数及其作用。 详细配置参数关于详细配置参数参考：https://xdsoft.net/jqplugins/datetimepicker/12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455$('#datetimepicker').datetimepicker(&#123; value: '' // 设置当前datetimepicker的值 rtl: false, // false 默认显示方式 true timepicker和datepicker位置变换 format: 'Y/m/d H:i', // 设置时间年月日时分的格式 如: 2016/11/15 18:00 formatTime: 'H:i', // 设置时间时分的格式 formatDate: 'Y/m/d', // 设置时间年月日的格式 startDate: false, // new Date(), '1986/12/08', '-1970/01/05','-1970/01/05', step: 10, // 设置时间时分的间隔 closeOnDateSelect: false, // true 设置datepicker可点击 false 设置datepicker不可点击 实际上可以双击 closeOnTimeSelect: true, // true 设置timepicker可点击 false 设置timepicker不可点击 closeOnWithoutClick: true, // true 设置点击input可以隐藏datetimepicker false 设置点击input不可以隐藏datetimepicker closeOnInputClick: true, // true 设置点击input可以隐藏datetimepicker false 设置点击input不可以隐藏datetimepicker (会有闪动 先隐藏 再显示) timepicker: true, // true 显示timepicker false 隐藏timepicker datepicker: true, // true 显示datepicker false 隐藏datepicker weeks: false, // true 显示周数 false 隐藏周数 defaultTime: false, // 如果输入值为空 可用来设置默认显示时间 use formatTime format (ex. '10:00' for formatTime: 'H:i') defaultDate: false, // 如果输入值为空 可用来设置默认显示日期 use formatDate format (ex new Date() or '1986/12/08' or '-1970/01/05' or '-1970/01/05') minDate: false, // 设置datepicker最小的限制日期 如：2016/08/15 maxDate: false, // 设置datepicker最大的限制日期 如：2016/11/15 minTime: false, // 设置timepicker最小的限制时间 如：08:00 maxTime: false, // 设置timepicker最大的限制时间 如：18:00 allowTimes: [], // 设置timepicker显示的时间 如：allowTimes:['09:00','11:00','12:00','21:00'] opened: false, // false默认打开datetimepicker可关闭 true打开datetimepicker后不可关闭 initTime: true, // 设置timepicker默认时间 如：08:00 inline: false, // ture设置datetimepicker一直显示 theme: '', // ture设置datetimepicker显示样式 如: 'dark' withoutCopyright: true, // ture默认隐藏左下角'xdsoft.net'链接 false 显示左下角'xdsoft.net'链接 inverseButton: false, // false 默认 true datepicker的上一月和下一月功能互换 timepicker的上下可点击按钮功能互换 hours12: false, // true设置12小时格式 false设置24小时格式 next: 'xdsoft_next', // 设置datepicker上一月按钮的样式 prev : 'xdsoft_prev', // 设置datepicker下一月按钮的样式 dayOfWeekStart: 0, // 设置默认第-列为周几 如：0 周日 1 周一 parentID: 'body', // 设置父级选择器 timeHeightInTimePicker: 25, // 设置timepicker的行高 timepickerScrollbar: true, // ture设置timepicker显示滑动条 false设置timepicker不显示滑动条 todayButton: true, // ture显示今天按钮 false不显示今天按钮 位置在datepicker左上角 prevButton: true, // ture显示上一月按钮 false不显示上一月按钮 位置在datepicker左上角 nextButton: true, // ture显示下一月按钮 false不显示下一月按钮 位置在datepicker又上角 scrollMonth: true, // ture 设置datepicker的月份可以滑动 false设置datepicker的月份不可以滑动 lazyInit: false, // 翻译： 初始化插件发生只有当用户交互。大大加速插件与大量的领域的工作 mask: false, // 使用输入掩码。真正的-自动生成一个字段的“格式”的面具，从0到9的数字，设置为值的最高可能的数字。例如：第一个小时的数字不能大于2，而第一位数字不能大于5 如：&#123;mask:'9999/19/39 29:59',format:'Y/m/d H:i'&#125; validateOnBlur: true, // 失去焦点时验证datetime值输入,。如果值是无效的datetime,然后插入当前日期时间值 yearStart: 1950, // 设置最小的年份 yearEnd: 2050, // 设置最大的年份 monthStart: 0, // 设置最小的月份 monthEnd: 11, // 设置最大的月份 roundTime: 'round', // 设置timepicker的计算方式 round四舍五入 ceil向上取整 floor向下取整 allowDateRe : null, // 设置正则表达式检查日期 如：&#123;format:'Y-m-d',allowDateRe:'\d&#123;4&#125;-(03-31|06-30|09-30|12-31)' &#125; disabledDates : [], // 设置不可点击的日期 如：disabledDates: ['21.11.2016','22.11.2016','23.11.2016','24.11.2016','25.11.2016','26.11.2016'] disabledWeekDays: [], // 设置不可点击的星期 如：disabledWeekDays:[0,3,4] yearOffset: 0, // 设置偏移年份 如：2 代表当前年份加2 -2 代表当前年份减2 beforeShowDay: null, // 显示datetimepicker之前可调用的方法 &#123;beforeShowDay:function(d) &#123;console.log("bsd"); &#125; &#125; enterLikeTab: true, // tab按键均可使datetimepicker关闭 true点击回车键可使datetimepicker关闭 false点击回车键不可使datetimepicker关闭 showApplyButton: false // 相当于确定按钮 true显示 false隐藏&#125;); jquery datetimepicker的相关点击方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* * 监听时间插件显示时的事件 */$('#datetimepicker').datetimepicker(&#123; onShow: function(dateText, inst) &#123; console.log("---已打开datetimepicker----"); &#125;&#125;); /* * 监听时间插件关闭时的事件 */$('#datetimepicker').datetimepicker(&#123; onClose: function(dateText, inst) &#123; console.log("---已关闭datetimepicker----"); &#125;&#125;); /* * 监听点击日期时的事件 */ $('#datetimepicker').datetimepicker(&#123; onSelectDate: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;); /* * 监听点击时分的事件 */ $('#datetimepicker').datetimepicker(&#123; onSelectTime: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;); /* * 监听点击datepicker 上一月下一月按钮及选择月份点击事件 */$('#datetimepicker').datetimepicker(&#123; onChangeMonth: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;);/* * 监听获取当前datetimepicker显示的所有日期信息 */$('#datetimepicker').datetimepicker(&#123; onGetWeekOfYear: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;); /* * 监听选择年份的点击事件 */$('#datetimepicker').datetimepicker(&#123; onChangeYear: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;); /* * 实时监听你选择的日期和时间 */$('#datetimepicker').datetimepicker(&#123; onChangeDateTime: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;); /* * 实时监听datetimepicker上的所有事件 */$('#datetimepicker').datetimepicker(&#123; onGenerate: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;);]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>jq</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[store.js的使用 -- 本地存储localStorage的封装插件]]></title>
    <url>%2F2018%2F02%2F08%2Fstore%2F</url>
    <content type="text"><![CDATA[store.js 是一个兼容所有浏览器的 LocalStorage 包装器，不需要借助 Cookie 或者 Flash来实现。它提供非常了简洁的 API 来实现跨浏览器的本地存储功能。使用store,js简化了使用localStorage原生方法的操作。本文主要介绍如何用store.js操作localStorage。 本地存储localstoragelocalstorage 是 HTML5 提供的在客户端存储数据的新方法，主要作用是将数据保存在客户端中，并且数据是永久保存的，除非人为干预删除。localstorage 的局限1、只有版本较高的浏览器中才支持 localstorage2、localStorage只能存储字符串，使用 JSON 时需转换3、如果存储内容过多会消耗内存空间，导致页面变卡，因为localStorage本质上是对字符串的读取 store.jsGithub地址 store.js 是一个兼容所有浏览器的 LocalStorage 包装器，不需要借助 Cookie 或者 Flash来实现。它提供非常了简洁的 API 来实现跨浏览器的本地存储功能。使用store,js简化了使用localStorage原生方法的操作。 store.js的使用 首先引入store.min.js插件: 1&lt;script src="https://cdn.bootcss.com/store.js/1.3.20/store.min.js"&gt;&lt;/script&gt; 判断浏览器是否支持本地存储 12345678910&lt;script type="text/javascript"&gt; init(); function init()&#123; if(!store.enabled)&#123; alert("你的浏览器不支持本地存储，请使用更高版本的浏览器"); return; &#125;else&#123; ...... &#125; &lt;/script&gt; 开始愉快地使用store.js吧~store.js的基本API有： 123456store.set(key, val) //存储 key 的值为 val；store.get(key) //获取 key 的值；store.remove(key) //移除 key 的记录；store.clear() //清空存储；store.getAll() //返回所有存储；store.forEach() //遍历所有存储。 使用方法：123456789101112131415161718store.set('username', 'marcus') store.get('username') store.remove('username') store.clear() store.set('user', &#123; name: 'marcus', likes: 'javascript' &#125;) var user = store.get('user') alert(user.name + ' likes ' + user.likes) // Get all stored values store.getAll().user.name == 'marcus' // Loop over all stored values store.forEach(function(key, val) &#123; console.log(key, '==', val) &#125;) set 单个存储字符格式：store.set(key, data[, overwrite]);123456789101112131415161718192021store.set('name','mavis'); //存储name的值为 mavisstore.set('name','angel'); //将name的值存储为angel例如：store.set('容器1', json)``` 在控制台显示 ![](https://sfault-image.b0.upaiyun.com/282/193/2821938934-5831460c5a712) ---- get 获取存入的key值 格式：`store.get(key[, alt]);` get获取时，有时需要判断是否存在localStorage```javascriptstore.set('name','mavis');store.set('name','angel');store.get('name'); //angel例如：var json = &#123;1:1,2:2,3:3,4:4&#125;;store.set('容器1', json)store.get('容器1');//&#123;1:1,2:2,3:3,4:4&#125; remove 移除key的记录1store.remove('name'); 在控制台可以看到name的值已经被移除 store.clear(); 清空所有本地存储 getAll 从所有存储中获取值格式：store.getAll() 12store.set('name','mavis');store.getAll().user.name == 'mavis'; //true forEach 遍历所有的值 12345store.set('user',&#123;name:'mavis',likes:'javascript'&#125;); // 存储对象 - 自动调用 JSON.stringifyvar user = store.get('user'); // 获取存储的对象 - 自动执行 JSON.parsestore.forEach(function(key, val) &#123; console.log(key, '==', val) &#125;) // 遍历所有存储 store.has(key)``javascriptconsole( store.has(‘容器1’) );//trueconsole( store.has(‘容器2’) );//false``` 在浏览器中查看LocalStorage的方法F12打开开发人员工具→Application→Storage→LocalStorage]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>jq</tag>
        <tag>插件</tag>
      </tags>
  </entry>
</search>
