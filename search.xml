<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[仿照jquery]]></title>
    <url>%2F2018%2F03%2F13%2F%E4%BB%BF%E7%85%A7jquery%2F</url>
    <content type="text"><![CDATA[如何封装一个js库把封装的js库添加到自定义的接口(自定义对象)上jquery的原理 封装函数封装函数获取兄弟节点(ele)1234567891011121314151617function 获取兄弟节点(ele)&#123; var parent = ele.parentElement; var allChildren = parent.children; var length = 0; var 伪数组=&#123;length:length&#125;; for(i=0;i&lt;allChildren.length;i++)&#123; if(allChildren[i] !== ele)&#123; 伪数组[length] = allChildren[i]; length++; 伪数组.length = length; &#125; &#125; return 伪数组;&#125;console.log( 获取兄弟节点(li4) ); 封装函数添加或删除多个class(ele,classes)12345678910111213141516var classes = &#123;'a':true, 'b':false,//false表示删除 'c':true &#125;;function 添加或删除多个class(ele,classes)&#123; for(var key in classes)&#123; if(classes[key])&#123; ele.classList.add(key); &#125;else &#123; ele.classList.remove(key); &#125; &#125;&#125;添加或删除多个class(li5,classes); 代码优化上面的代码可以优化为：12345678910原始代码：if(classes[key])&#123; ele.classList.add(key);&#125;else &#123; ele.classList.remove(key);&#125;优化：var method = classes[key] ? 'add' : 'remove';ele.classList[method](key); 打开console控制台查看结果JS Bin 命名空间12345678var stage = &#123;&#125;; // 或者 window.stage = &#123;&#125;stage.获取兄弟节点 = 匿名函数; //添加到对象内stage.添加或删除多个class = 匿名函数; //添加到对象内var x = stage.获取兄弟节点(li4);console.log(x);stage.添加或删除多个class(li6,&#123;'a':true,'b':false,'c':true&#125;); JS Bin 这种方法每次都要使用stage.xxx(ele,其他参数)太麻烦了 把ele放在前面的方法上面的方法每次使用都要在前面加上命名空间,比如stage.xxx(ele,其他参数)，这样太麻烦了 如何达到以下效果，不使用命名空间：12ele.获取兄弟节点()ele.添加或删除多个class(&#123;'a':true,'b':false,'c':true&#125;); 直接加到Node.prototype上将封装的函数直接加到Node的公用属性(原型)Node.prototype上。并且把传入的第一个参数去掉，函数体内改成this1234567891011121314151617Node.prototype.获取兄弟节点 = function &#123; var parent = this.parentElement; var allChildren = parent.children; var length = 0; var 伪数组=&#123;length:length&#125;; for(var i=0;i&lt;allChildren.length;i++)&#123; if(allChildren[i] !== this)&#123; 伪数组[length] = allChildren[i]; length++; 伪数组.length = length; &#125; &#125; return 伪数组;&#125;;console.log( li7.获取兄弟节点() );// 此处this就是li7 JS Bin 但是这种方法可能会污染Node的公用属性，因此不建议直接加到Node.prototype上 把封装的js库添加到自定义的接口上1234567891011121314151617181920212223242526272829var stage = function(node) &#123; return &#123; 获取兄弟节点: function() &#123; var parent = node.parentElement; var allChildren = parent.children; var length = 0; var 伪数组 = &#123; length: length &#125;; for (var i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== node) &#123; 伪数组[length] = allChildren[i]; length++; 伪数组.length = length; &#125; &#125; return 伪数组; &#125;, 添加或删除多个class: function(classes) &#123; for (var key in classes) &#123; var method = classes[key] ? 'add' : 'remove'; node.classList[method](key); &#125; &#125; &#125;&#125;;/////////////////console.log( stage(li3).获取兄弟节点() );stage(li3).添加或删除多个class(&#123; 'a': true, 'd': true &#125;); JS Bin 完善封装的js库123456789101112131415161718192021222324252627282930313233 function stage(node) &#123; if(typeof node === 'string')&#123;//如果传入的是个字符串 node = document.querySelector(node); &#125; return &#123; getSibings: function() &#123; var parent = node.parentElement; var allChildren = parent.children; var length = 0; var 伪数组 = &#123; length: length &#125;; for (var i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== node) &#123; 伪数组[length] = allChildren[i]; length++; 伪数组.length = length; &#125; &#125; return 伪数组; &#125;, add_remove_classes: function(classes) &#123; for (var key in classes) &#123; var method = classes[key] ? 'add' : 'remove'; node.classList[method](key); &#125; &#125; &#125;;&#125;;/////////////////console.log( stage('#li3').getSibings() );stage(li4).add_remove_classes(&#123; 'red': true&#125;);stage('ul&gt;li:nth-of-type(2)').add_remove_classes(&#123;'red':true&#125;); JS Bin 用$缩写(alias)1window.$ = stage; 12345678910111213141516171819202122232425262728var stage = function (node) &#123; var eles = &#123;length: 0&#125;; if (typeof node === 'string') &#123; //如果传入的是个字符串 var temps = document.querySelectorAll(node);//临时变量是个伪数组 for(var i=0;i&lt;temps.length;i++)&#123; //把临时变量存到伪数组eles内 eles[i] = temps[i]; eles.length = temps.length; &#125; &#125; //在eles里添加添加方法 eles.add_remove_classes = function(classes) &#123; for (var key in classes) &#123; var method = classes[key] ? 'add' : 'remove'; for (var j=0;j&lt;eles.length;j++)&#123; eles[j].classList[method](key); &#125; &#125; &#125;; //console.log(eles); return eles;//!!!一定要return，不然stage()调用完的返回值是undefined&#125;;window.$ = stage;/////////////////stage('li')..add_remove_classes(&#123;'blue': true&#125;);等同于：$('li').add_remove_classes(&#123;'blue': true&#125;); JS Bin 作业题12345678910111213141516171819202122232425262728293031$('div').addClass('red') // 可将所有 div 的 class 添加一个 red$('div').setText('hi') // 可将所有 div 的 textContent 变为 hiwindow.jQuery = function(node) &#123; var nodes = &#123; length: 0 &#125;; if (typeof node === 'string') &#123; var temp = document.querySelectorAll(node); for (var i = 0; i &lt; temp.length; i++) &#123; nodes[i] = temp[i]; nodes.length = temp.length; &#125; &#125; nodes.addClass = function(classs) &#123; for (var i = 0; i &lt; nodes.length; i++) &#123; nodes[i].classList.add(classs); &#125; &#125;; nodes.setText = function(text)&#123; for (var i = 0; i &lt; nodes.length; i++) &#123; nodes[i].textContent = text; &#125; &#125;; return nodes;&#125;;window.$ = jQuery;$('div').addClass('red');$('div').setText('hi'); JS Bin]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>笔记</tag>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM基础知识]]></title>
    <url>%2F2018%2F03%2F12%2FDOM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[DOM相关apitextContent与innerText与innerHTML的区别nodeType的值对应什么节点documentFragment性能优化 DOMDocument Object Model,文档对象模型即：把html当做对象来操作 Node节点(元素)相关api获取 元素.childNodes 获取该元素的所有子节点，包括换行形成的text节点。返回一个伪数组 元素.childNodes[0] 元素.children 获取该元素的所有子标签，不包括换行。返回一个伪数组 元素.children[0] 元素.parentNode 与 元素.parentElement 元素.firstChild 与 元素.firstElementChild 元素.lastChild 与 元素.lastElementChild 元素.previousSibling 与 元素.previousElementSibling 元素.nextSibling 与 元素.nextElementSibling 元素.parentNode 与 元素.parentElement 元素.nodeName 与 元素.tagName 返回的是大写的字符串，比如’DIV’,在做if判断时要配合toLowerCase使用 元素.innerHTML 与 元素.innerTEXT 与 元素.textContent123456789101112131415161718192021&lt;footer id="footer"&gt; &lt;p&gt;hello &lt;script&gt;document.write('2014-' + new Date().getFullYear())&lt;/script&gt; world &lt;/p&gt; &lt;/footer&gt;footer.textContent 与 footer.innerText返回结果一样: 'hello document.write('2014-' + new Date().getFullYear()) world'1.textContent会将style标签里的内容当做文本返回，而innerText会忽略style标签里包含的内容2.innerText不会返回display:none的元素的文本，而textContent会--------------------------------footer.innerHTML的返回结果：' &lt;p&gt;hello &lt;script&gt;document.write('2014-' + new Date().getFullYear())&lt;/script&gt;2014-2018 world &lt;/p&gt;' 面试题textContent与innerText的区别123456&lt;div id="test" class="test"&gt;test&lt;div style="display:none"&gt;&lt;span&gt;test&lt;/span&gt;&lt;/div&gt;&lt;style&gt;hi&lt;/style&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var testDiv = document.getElementById('test'); console.log(testDiv.textContent); console.log(testDiv.innerText);&lt;/script&gt; textContent会获取所有元素的内容，包括 &lt;script&gt; 和 &lt;style&gt; 里包含的内容。而innerText不会 textContent会获取display:none的节点的文本；而innerText不会返回隐藏元素的文本 innerHTML获取时，会将包含的标签还原出来123&lt;div id='x'&gt;&lt;p&gt;hello&lt;/p&gt;&lt;/div&gt;x.innerHTML // &lt;p&gt;hello&lt;/p&gt; 设置时，会将标签转成代码1x.innerHTML='&lt;i&gt;hello&lt;/i&gt;' // i标签自动转成斜体 面试题nodeType nodeType=1 元素节点(标签)，例如, nodeType=2 属性节点 比如class=”right” nodeType=3 文本节点 例如p标签里包含的文字 nodeType=8 注释节点 nodeType=9 document文档节点 nodeType=10 文档类型节点 比如html的文档类型是&lt;!DOCTYPE html&gt; nodeType=11 documentFragment文档片段节点12345document.nodeType === Node.DOCUMENT_NODE// truedocument.nodeType === 9// true 面试题documentFragment性能优化查看相关博客 操作DOM ul.appendChild(li) 把li插入ul的末尾内 div1.cloneNode(deep?)浅拷贝 深拷贝 元素.hasChildNodes() 元素是否含有子节点，有的话返回true，换行算作文本节点 ul.insertBefore(li, ul.children[0]) 把新节点插到ul最前面内 div1.isEqualNode(div2) 检查两个元素是否相等 div1.isSameNode(div2) 检查两个元素所有有相同节点。推荐使用div1===div2来代替此方法 ul.removeChild(ul.lastElementChildren) ul.replaceChild(newLi, oldLi) 元素.normalize() // 常规化 document相关api获取 document.body // &lt;body&gt;...&lt;/body&gt; document.children // 伪数组[html] document.documentElement // &lt;html&gt;...&lt;/html&gt; document.domain // “xiedaimala.com” document.origin // “https://xiedaimala.com“ document.head // &lt;head&gt;...&lt;/head&gt; document.images //获取页面中所有的&lt;img&gt;标签。通过document.images.length可以获取&lt;img&gt;标签数量 document.links //获取页面中所有的&lt;a&gt;标签。通过document.links.length可以获取&lt;a&gt;标签数量 document.location document.referrer //引荐人。从哪里跳转到这个页面的 document.title document.onxxxxx //onclick，onmouseover……. 操作document document.getElementById() document.getElementsByClassName() document.getElementsByTagName() document.querySelector() //只获取满足条件的第一个元素 document.querySelectorAll() //返回一个伪数组 document.createDocumentFragment() document.createElement() document.createTextNode() document.write() //紧接着写 document.writeln() //一行一行(line)写 Element相关apihttps://developer.mozilla.org/zh-CN/docs/Web/API/Element 作业题123456var parent = document.getElementById('parent');parent.childNodes.length // 2parent.appendChild(document.createElement('div'));parent.childNodes.length // 请问现在 length 是多少答案：3 123456var allDiv = document.querySelectorAll('div)allDiv.length // 假设是 2document.body.appendChild( document.createElement('div') )allDiv.length // 请问现在 length 的值是多少？？？答案：2 上面两题，为什么一个 length 会动态变化，另一个 length 却不会动态变化？ 1.parent.childNodes是动态集合。所谓动态集合就是一个活的集合，DOM树删除或新增一个相关节点，都会立刻反映在NodeList接口之中。2.document.querySelectorAll方法返回的是一个静态集合。DOM的增删，并不会实时反映在该方法的返回结果之中。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>笔记</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数Function基础知识]]></title>
    <url>%2F2018%2F03%2F12%2F%E5%87%BD%E6%95%B0Function%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[函数的声明方法函数的调用callthis作用域和闭包 函数声明方法总结 具名函数 1234function fn(x,y)&#123; return x + y;&#125;fn.name // 'fn' 匿名函数 123function (x,y) &#123; return x+y; &#125; var fn=匿名函数 1234var fn = function(x,y) &#123; return x+y;&#125;fn.name // 'fn' var fn=具名函数 1234567891011var fn = function f2(x,y)&#123; return x+y &#125;; fn.name // 'f2' console.log(f2) // f2 is not defined等同于 var fn; fn= function f2(x,y)&#123; return x+y &#125; var fn=new Function() 12345678910111213参数和函数体都以字符串的形式 var fn = new Function('x','y','return x+y') fn.name // "anonymous"面试题：var n = 3;var fn = new Function('x','y','return x+'+n+'+y');问：fn(2,4)的结果是A：9B：2n4C：234答案：9 ES6箭头函数 1234567891011121314151617181920 var fn = (x,y) =&gt; &#123; return x+y &#125;; fn(2,3); // 5如果函数体只有一句话，可以去掉花括号和return： var sum = (x,y) =&gt; x+y; sum(4,5); // 9如果只有1个参数，可以简写为： var fn2 = n =&gt; n*n; fn2(4); // 16箭头函数的复杂写法：var fn = (x,y) =&gt; &#123; const a=x*2; const b=y*3; return a+b;&#125;fn(3,5) // 21 evaleval方法可以将字符串当做代码执行。1eval('alert(1)') // 弹出1 eval方法一般很少会使用到。 函数的调用1234fn(参数1,参数2);等同于fn.call(undefined,参数1,参数2)； this和伪数组argumentsthis就是call的第一个参数fn(参数1,参数2)等同于fn.call(undefined,参数1,参数2)，因此fn(参数1,参数2)的this是undefined12345678910111213'use strict';function fn()&#123; console.log(this); console.log(arguments);&#125;fn.call(1,2,3);// this为1//arguments为伪数组[2,3]fn(1,2,3);//等同于fn.call(undefined,1,2,3)// this为undefined//arguments为伪数组[1,2,3] this相关面试题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function f()&#123; console.log(this)&#125;f.call(1)// Number对象&#123;1&#125;function f1()&#123; console.log(this) function f2()&#123;&#125;&#125;var obj = &#123;name: 'obj'&#125;f1.call( obj )//&#123;name: 'obj'&#125;----------function f()&#123; 'use strict' console.log(this)&#125;f.call(1)// 1-------------function f()&#123; console.log(this) //console.log(this === window)&#125;f.call()// window function f1()&#123; function f2()&#123; console.log(this) &#125; f2.call()&#125;var obj = &#123;name: 'obj'&#125;f1.call( obj )//window----------function f()&#123; 'use strict' console.log(this)&#125;f.call()//undefinedfunction f1()&#123; 'use strict'; function f2()&#123; console.log(this) &#125; f2.call()&#125;var obj = &#123;name: 'obj'&#125;f1.call( obj )//undefined call stack普通调用嵌套调用递归调用 作用域面试题最重要的一步：变量提升！！！！！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var a = 1;function f1()&#123; alert(a) // 是多少 var a = 2;// 由于函数内部有变量a了，所以不会访问外部作用域里的a&#125;f1(); //undefined-------------------var a = 1;function f1()&#123; alert(a) // 是多少&#125;f1();// 1f1内部没有变量a，因此会访问全局作用域里的a----------------------------var a = 1;function f1()&#123; var a = 2; //f1的局部a=2 f2();&#125;function f2()&#123; console.log(a) // 是多少&#125;f1(); // 1 由于f2内部没有变量a,因此会访问全局作用域里的a-----------------------------var a = 1;function f1()&#123; a = 2; //由于f1内部没有声明变量a，因此它赋值给的是全局作用域的a，此时全局a=2 f2();&#125;function f2()&#123; console.log(a) // 是多少&#125;f1(); // 2----------------------6个livar lis = document.getElementsByTagName('li');for(var i = 0; i&lt;lis.length; i++)&#123; lis[i].onclick = function()&#123; console.log(i) // 点击第3个 li 时，打印 2 还是打印 6？ &#125;&#125;//最终结果：6打印出来的是for循环结束完之后的i--------------------var改成letfor(let i = 0; i&lt;lis.length; i++)&#123; lis[i].onclick = function()&#123; console.log(i) // 点击第3个 li 时，打印 2 还是打印 6？ &#125;&#125;//最终结果：0,1,2,3,4,5 闭包面试题如果一个函数，使用了它外部作用域的变量，那么(这个函数+被使用的变量)就叫做闭包。12345var a = 1;function f1() &#123; console.log(a); //访问了外部的全局作用域的变量a&#125;f1(); // 1 闭包相关面试题 作业题123456789101112var a = console.log(1);a的值是多少？答案:undefined因为console.log的源码是将内容打印出来后，return undefinedalert的源码结尾也是return undefined----------------------function f()&#123; return 1;&#125;var a = f();//a的值是1 逗号表达式逗号表达式的一般形式是：表达式1，表达式2，表达式3……表达式n逗号表达式的求解过程是：先计算表达式1的值，再计算表达式2的值，……一直计算到表达式n的值。最后整个逗号表达式的值是表达式n的值。看下面几个例子：1234567891011var a = (1,2);a的值为2-----------var a = (1, console.log(2));a的值是undefined，因为console.log的返回值是undefinedx=8*2,x*4 /*整个表达式的值为64，x的值为16*/ (x=8*2,x*4),x*2 /*整个表达式的值为128，x的值为16*/ x=(z=5,5*2) /*整个表达式为赋值表达式，它的值为10，z的值为5*/ x=z=5,5*2 /*整个表达式为逗号表达式，它的值为10，x和z的值都为5*/ 12345678910111213141516171819202122232425262728function f()&#123; return function f2()&#123;&#125;&#125;var a = f();//a的值是函数f2---------------function f()&#123; return function f2()&#123;&#125;&#125;var a = f();var b = a();等同于 var b = f.call().call()又等同于 var b = f()(); //前一个括号调用后返回一个函数；后一个括号执行返回的这个函数//a的值是函数f2//b的值是undefined,f2没有写ruturn，则默认return undefinedf2();//f2 is not defined，因为f2无法单独执行，必须要通过f()才能执行f2function f()&#123; return function f2()&#123; return 'hello' &#125;&#125;var b = f.call().call();等同于 var b = f()(); //前一个括号调用后返回一个函数；后一个括号执行返回的这个函数//b的值为'hello' 1234567891011121314function f1()&#123; console.log(this) // 第一个 this function f2()&#123; console.log(this) // 第二个 this &#125; f2.call()&#125;var obj = &#123;name: 'obj'&#125;f1.call( obj )//第一个this为&#123;name: 'obj'&#125;//第二个this为window，在'use strict'模式下为undefined第一个this对应的call是f1.call(obj)第二个this对应的call是f2.call();]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>笔记</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组Array基础知识]]></title>
    <url>%2F2018%2F03%2F09%2F%E6%95%B0%E7%BB%84Array%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[数据类型new与不new的区别伪数组数组api 基本数据类型new不new的区别new String(x)和String(x)的区别 123456String(1) //"1" 变成字符串String(false) // 'false'String(null) // 'null'new String(1) // String &#123;"1"&#125; 变成String对象new String('sss') // String &#123;"sss"&#125; new Number(x)和Number(x)的区别 12345678910Number('3') //3 变成数字Number('sss') //NaN NaN也是数字类型Number(true) //1Number(false) //0Number(null) //0Number(undefined) //NaNnew Number('123') //Number &#123;123&#125; 变成Number对象new Number(111) //Number &#123;111&#125; 复杂数据类型new不new的区别new OBject(x)和Object(x)的区别【没区别】1234567891011Object(1) // Number &#123;1&#125; 传入数字则变成Number对象new Object(1) // Number &#123;1&#125; 与上面没区别Object('sss') // String &#123;"sss"&#125; 传入字符串则变成String对象new Object('sss') // String &#123;"sss"&#125;Object() //&#123;&#125; 什么都不传就是空对象new Object() //&#123;&#125;Object(false) // Boolean &#123;false&#125; 传入布尔值则变成Boolean对象new Object(false) // Boolean &#123;false&#125; 数组Array12345678910111213var arr = Array(3) // [undefined,undefined,undefined] 【生成length为3，每个值都是undefined的数组】arr[0] //undefinedarr[1] //undefinedarr[2] //undefined'0' in arr //false 从内存图可以看出，在地址99的数据里只有length和__proto__'length' in arr //true'__proto__' in arr //truearr.__proto__ == Array.prototype //arr是由Array构造的，所以它的__proto__指向Array的公用属性 //true 生成的数组的__proto__指向Array的公用属性(原型prototype)//这个公用属性中有push方法、shift方法等 1234567var arr = Array(3) // [undefined,undefined,undefined] 1个参数时表示生成长度为length、每一项的值为undefined的数组var arr = Array(3,3) // [3,3] 多于1个参数时，表示每一项的值var arr = new Array(3) 跟不加 new 一样的效果var arr = new Array(3,3) 跟不加 new 一样的效果 函数Function1234567891011var fn1 = function (a,b) &#123; return a+b;&#125;;fn1(5,9);// 14--------var fn2 = Function('a','b','return a-b');//参数和方法体都写成字符串的形式等同于var fn2 = new Function('a','b','return a-b');//加不加new都一样fn2(10,3) //7 总结 new不new的区别 基本数据类型不加new 则返回基本类型 1String(1) // '1' 基本数据类型加new 则返回一个对象 1new Number('123') //Number &#123;123&#125; 变成Number对象 复杂数据类型加不加new都一样 12Object('sss') // String &#123;"sss"&#125; 传入字符串则变成String对象new Object('sss') // String &#123;"sss"&#125; 伪数组 arguments 对象是伪数组 document.querySelectAll(‘div’) 返回的对象是伪数组上面两个有以下这些特征: 1.有 0:xx,1:xx,2:xx,3:xx…n:xx,length:xx 这些 key 的对象2.他们的proto不链接到数组的公用属性Array.prototype，即他们的原型链中没有Array.prototype 这样的对象就是伪数组12345678function fn() &#123; console.log(arguments)&#125;fn(1,3,5,7);//arguments有0,1,2...,length这些key,但是它的__proto__没有指向Array的公用属性Array.prototype，而是指向Object.prototypefn.push(9) // 报错，伪数组没有数组的api 判断是不是数组12var lis = document.querySelectorAll('li');lis instanceof Array;//false 数组的操作(api) 数组就是数据的有序集合 数组就是原型链中有 Array.prototype 的对象 遍历数组获取value和index用forEacharr.forEach(function (value,index) {执行函数体});forEach只用来操作数据,没有返回值map有返回值 forEach的用法与map方法一致,接受三个参数：value、index、整个数组。123456789101112131415161718var colors = ['red', 'green', 'blue'];colors.forEach(function (value) &#123; console.log(value);&#125;);//箭头函数写法：colors.forEach((value) =&gt; console.log(value));// red// green// blue-------var colors = ['red', 'green', 'blue'];colors.forEach(function (value,index) &#123; console.log(index + ':'+ value);&#125;);//0:red//1:green//2:blue forEach的原理： 排序sort sort用的快速排序 默认的sort会将数字先转成字符串，再按照字典顺序进行从小到大排序，所以会有bug 1234567891011['d', 'c', 'b', 'a'].sort()// ['a', 'b', 'c', 'd'][4, 3, 2, 1].sort()// [1, 2, 3, 4][11, 101].sort()// [101, 11] 先比较最前面的数，都是1，再比较第二位数，js误以为101小于11[10111, 1101, 111].sort()// [10111, 1101, 111] 先比较最前面的数，都是1；再依次比较后几位数，有bug 如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。 123456789101112从小到大排序a-b[10111, 1101, 111].sort(function (a, b) &#123; return a - b;&#125;)// [111, 1101, 10111]--------从大到小排序b-a[10111, 1101, 111].sort(function (a, b) &#123; return b - a;&#125;)[10111, 1101, 111] 根据给定的依据进行排序 1234567891011var students = ['小明','小红','小花']; var scores = &#123; 小明: 59, 小红: 99, 小花: 80 &#125;;students.sort(function(a,b) &#123; return scores[a]-scores[b]; //按照scores从小到大排序&#125;);//["小明", "小红", "小花"] students.sort(function(a,b) &#123; return scores[b]-scores[a];//按照scores从大到小排序&#125;);//["小红", "小花", "小明"] 123456789101112[ &#123; name: "张三", age: 30 &#125;, &#123; name: "李四", age: 24 &#125;, &#123; name: "王五", age: 28 &#125;].sort(function (o1, o2) &#123; return o1.age - o2.age;&#125;)// [// &#123; name: "李四", age: 24 &#125;,// &#123; name: "王五", age: 28 &#125;,// &#123; name: "张三", age: 30 &#125;// ] join 数组变字符串join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。12345var a = [1, 2, 3, 4];a.join(' ') // '1 2 3 4'a.join('xx') // "1xx2xx3xx4"a.join() // "1,2,3,4" 数组变字符串更简单的办法：1234var a = [1, 2, 3, 4];a+''; // "1,2,3,4"a+'3'; // "1,2,3,43" cancat连接多个数组concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。1234567891011['hello'].concat(['world'])// ["hello", "world"]['hello'].concat(['world'], ['!'])// ["hello", "world", "!"][].concat(&#123;a: 1&#125;, &#123;b: 2&#125;)// [&#123; a: 1 &#125;, &#123; b: 2 &#125;][2].concat(&#123;a: 1&#125;)// [2, &#123;a: 1&#125;] concot用来复制一个数组，由于concat返回的是一个新数组，因此虽然复制原数组，但两者不相等123var a = [1,2,3];var b = a.concat([]); // b = [1,2,3]a == b; // false 数组相加数组的相加，先将每个数组转变成字符串，然后连接起来1[1,2,3]+[4,5,6] // "1,2,34,5,6" mapmap方法将数组的所有value依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。原数组不变forEach没有返回值，map有返回值12345678910var numbers = [1, 2, 3];var newNum = numbers.map(function (value) &#123; return value + 1;&#125;);newNum; // [2,3,4]numbers; // [1, 2, 3]上面代码中，numbers数组的所有成员依次执行参数函数，运行结果组成一个新数组返回，原数组没有变化。 map有三个参数：value、index和数组本身。1234[1, 2, 3].map(function(value, index, arr) &#123; return value * index;&#125;);// [0, 2, 6] 用箭头函数=&gt;可以简写为：12var arr = [2,3,4];arr.map(value =&gt; value+3); // [5, 6, 7] map方法还可以返回包含对象的数组12345678var arr = [2,3,4];a.map(function(value,index)&#123; return &#123; '下标':index,'值':value; &#125;&#125;);// [ &#123;下标: 0, 值: 2&#125;, &#123;下标: 1, 值: 3&#125;, &#123;下标: 2, 值: 3&#125; ] filter过滤filter方法用于过滤数组value，满足条件的value组成一个新数组返回。 它的参数是一个函数，所有数组value依次执行该函数，返回结果为true的value组成一个新数组返回。 该方法不会改变原数组。 1234[1, 2, 3, 4, 5].filter(function (value) &#123; return (value &gt; 3); //结果为true的value组成一个新数组返回&#125;)// [4, 5] filter方法可以接受三个参数：value，index和整个数组。1234[1, 2, 3, 4, 5].filter(function (value, index, arr) &#123; return index % 2 == 0;&#125;);// [1, 3, 5] 先filter过滤再用map操作12345678var a = [1,2,3,4,5,6,7,8,9];a.filter(function(value)&#123; return value &gt; 5;&#125;).map(function(value)&#123; return value*2;&#125;)// [12, 14, 16, 18] 压缩累计reduce,reduceRightreduce方法和reduceRight方法依次处理数组的每个value，最终压缩累计为一个值。它们的差别是，reduce是从左到右处理（从第一个value到最后一个value），reduceRight则是从右到左（从最后一个value到第一个value），其他完全一样。 用reduce方法可以可以简化用for循环来累计的运算(比如求数组之和)12345678910var arr = [1, 2, 3, 4, 5];arr.reduce(function (sum, value) &#123; console.log(sum, value); return sum + value;&#125;, 0) //默认初始值为0,可以省略不写// 1 2// 3 3// 6 4// 10 5//最后结果：15 用箭头函数=&gt;简化：12arr.reduce((sum,value) =&gt; sum+value,0);//初始值为0//最后结果：15 reduce可以设置初始值1234[1, 2, 3, 4, 5].reduce(function (a, b) &#123; return a + b;&#125;, 10); // 从10开始累加// 最后结果：25 计算所有奇数之和：123456var a = [1,2,3,4,5,6,7,8,9];a.reduce( function(sum,value) &#123; value = value%2 == 0 ? 0 : value; return sum + value;&#125;,0) reduce替代map设置初始值为空数组[]12345678var arr = [2,3,4];将数组里的每一项乘以2，然后返回一个新数组arr.reduce(function(sum, value) &#123; sum.push(value*2); //push到初始值内 return sum;&#125;,[]) //初始值是个空数组// [4, 6, 8] reduce替代filter设置初始值为空数组[]12345678910var arr = [1,2,3,4,5,6,7,8,9];用reduce过滤出所有的偶数，然后返回新数组arr.reduce(function(sum,value)&#123; if(value%2==0)&#123; sum.push(value); &#125; return sum&#125;,[])// [2, 4, 6, 8]]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>笔记</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery知识点补充]]></title>
    <url>%2F2018%2F03%2F07%2Fjquery%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[jquery相关知识点补充 点击导航缓动到相应位置12345678910111213141516 &lt;nav style="position: fixed;top: 0;"&gt; &lt;a href="#a"&gt;a&lt;/a&gt; &lt;a href="#b"&gt;b&lt;/a&gt; &lt;a href="#c"&gt;c&lt;/a&gt;&lt;/nav&gt; &lt;div id="a" style="width: 100px;height: 100px;background: green;margin-top: 500px;"&gt;aaaa&lt;/div&gt; &lt;div id="b" style="width: 100px;height: 100px;background: green;margin-top: 500px;"&gt;bbb&lt;/div&gt; &lt;div id="c" style="width: 100px;height: 100px;background: green;margin-top: 500px;margin-bottom: 500px;"&gt;ccc&lt;/div&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; $('a').click(function(event) &#123; event.preventDefault(); var eleId = $(this).attr('href'); $('html,body').animate(&#123;scrollTop: $(eleId).offset().top&#125;, 800); &#125;);&lt;/script&gt; addClass(function(index){})1234var colors = ['red', 'yellow', 'blue', 'green'];$('li').addClass(function(i)&#123; return colors[i];&#125;); JS Bin 面试题123&lt;div id=x&gt;&lt;/div&gt;var div = document.getElementById('x')var $div = $('#x') 请说出 div 和 $div 的联系和区别。12345678910div 和 $div 的联系是：把 div 变成 $div ： $(div)把 $div 变成 div : 由于$div是一个伪数组，所以要取得他，需要用get()从数组中取出来$(div).get(0) 或者简写为$(div)[0]div 和 $div 的区别是：$div是JQuery对象，可以使用jq的api。而div是DOM对象，可以使用DOM的api两者可以调用的属性和方法不一样]]></content>
      <categories>
        <category>jq</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>面试题</tag>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全局函数、原型和原型链]]></title>
    <url>%2F2018%2F03%2F05%2F%E5%AF%B9%E8%B1%A1%2C%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%2C%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[全局函数原型(prototype)和原型链对象.proto === 全局函数.prototype 全局函数1.Number12var n = new Number(1) 创建一个 Number 对象var n = 1 与 var n = new Number(1) 的区别是什么？看内存图 2.String12var s = new String('hello') 创建一个 String 对象'hello' 与 new String('hello') 的区别是什么？看内存图 3.Boolean12345678var b = new Boolean(true) 创建一个 Boolean 对象true 与 new Boolean(true) 的区别是什么？看内存图var a = false;var b = new Boolean(false);if(a)&#123;console.log(1)&#125;if(b)&#123;console.log(2)&#125; 结果是2，因为b是个对象 4.Object1234var o1 = &#123;&#125;var o2 = new Object()o1 和 o2 的数据没区别但是o1不等于o2，因为他们两个在Stack区的地址不同 原型和原型链隐藏的公用属性(prototype)所有对象都有 toString 和 valueOf 属性，那么我们是否有必要给每个对象一个 toString 和 valueOf 呢？ 明显不需要。 JS 的做法是把 toString 和 valueOf 放在一个对象里（Object.prototype） 然后让每一个对象有1个隐藏的 proto 存储这个「公用属性组成的对象」的地址。 Object的proto指向null12345var obj =&#123; name: 'stage', age: 24&#125;;console.log(obj);//&#123;name: "stage", age: 24&#125; 以及隐藏的__proto__指向Object.prototype 重点公式1234567891011121314151617181920212223242526272829var 对象 = new 全局函数() //全局函数包括Number(123)、String('123')等对象.__proto__ === (构造了它的)全局函数.prototype //.__proto__用来存原型(prototype)的地址，从而引用prototype的数据//__proto__是对象的属性//prototype是函数的属性//对象的__proto__指向函数的prototype比如：var num = new Number(1);num.__proto__ === Number.prototype; //num由Number构造生成//创建的num，它的隐藏的__proto__指向【Number】的公用属性Number.prototypenum.__proto__.__proto__ === Object.prototype; //创建的num，它隐藏的__proto__指向Number.prototype,Number.prototype.的隐藏__proto__继续指向Object的公用属性Object.prototype----------obj.toString === Object.prototype.toString //对象的toString方法，实际上是调用了Object的公用属性(prototype)的toString方法-----------var fn = new Function() fn.__proto__ === Function.prototype //fn由Function构造生成 由于Function的数据类型也是对象，所以Function.__proto__ === Function.prototype 也就是说，Function.__proto__指向它本身的prototype]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>笔记</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js类型转换，内存图，数据的引用，垃圾回收，深拷贝vs浅拷贝]]></title>
    <url>%2F2018%2F03%2F05%2Fjs%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[js类型转换的方法6个falsy值内存图数据的引用垃圾回收深拷贝vs浅拷贝 转成字符串String(x)String(x)是一个window的全局方法 x.toString()null和undefined没有.toString()方法 121.toString() //报错1..toString() // '1' x + ‘’ 与空字符串相加这种方法比较简便，推荐用这种方法转成字符串 转成布尔值Boolean(x)注意!空对象是true !!x 转成数字Number(x)123456Number('3') //3 变成数字Number('sss') //NaN NaN也是数字类型Number(true) //1Number(false) //0Number(null) //0Number(undefined) //NaN parseInt(x)parseInt(&#39;123&#39;) 面试题1234567var a = 011; // a=9 js看到0开头默认转成8进制parseInt('011') // 11 【默认转成10进制】parseInt('011',8) // 9parseInt('s') // NaNparseInt('1s') // 1 parseFloat(x)parseFloat(3.14) x - 0 推荐这种12'123'-0 // 123'3.14'-0 // 3.14 +x 取正12+ '-1' // -1+ '3.14' // 3.14 6个falsy值0、NaN、空字符串、false、null、undefined 所有对象都是true12345var a = false;var b = new Boolean(false);if(a)&#123;console.log(1)&#125;if(b)&#123;console.log(2)&#125; 结果是2，因为b是个对象 内存图 JS 引擎将内存分为代码区和数据区 我们只研究数据区 数据区又分为 Stack区（栈内存） 和 Heap区（堆内存） 简单类型的数据直接存在 Stack 里 复杂类型(object)把地址存到 Stack 区，把地址对应的数据存到 Heap区 o2 = o;并不是修改了o2在Heap的数据，而是将o2的地址修改成o的地址，因此2访问o对应的数据 面试题-对象的引用12345678默认已经变量提升var a = &#123;name: 'a'&#125; //先在Heap区生成数据，然后在Stack区生成a的Address指向对应的数据var b = a // 将a的地址赋给b，而不是将a的数据赋值给bb = &#123;name: 'b'&#125; //在Heap区生成新的数据，然后生成b的地址指向对应的数据请问现在 a.name 是多少？ // 'a' a的地址没变，仍旧指向a的数据b = &#123;name:'b'&#125;并不会修改Heap区的数据，而是声明一个新的数据，然后Stack区的地址修改为新声明的数据对应的地址 12345默认已经变量提升var a = &#123;name: 'a'&#125; // 先在Heap区生成数据，然后在Stack区生成a的Address指向对应的数据var b = a // 将a的地址赋给b,此时b指向a的地址对应的数据b.name = 'b' // 修改a的地址对应的数据请问现在 a.name 是多少？ // 'b' 1234var a = &#123;name: 'a'&#125;var b = ab = null // null是简单类型，所以直接将b的STack区修改为null请问现在 a 是什么？ // &#123;name: 'a'&#125; 1234567var a = &#123;n:1&#125;; // heap区生成数据34，a生成地址34指向数据34var b = a; // b的地址也是34a.x = a = &#123;n:2&#125;; //此时最前面a.x是地址34的x// a.x等于地址a，即 34里的x = 新地址54【因为后面a在heap区生成了数据54&#123;n:2&#125;】alert(a.x);// --&gt; undefined 这里的a已经变成地址54了，54里的x是undefinedalert(b.x);// --&gt; [object Object] 由于b指向34,而34里的x = 新地址54 面试题-垃圾回收如果一个对象没有被引用(就是说没有地址指向它)，它就是垃圾，将会被回收 12345678910111213141516var fn = function ()&#123;&#125;;document.body.onclick = fn;fn = null;请问fn是垃圾吗？不是。一开始fn的Stack区是地址110,110指向数据fndocument是个复杂类型，所以Stack区存的地址222数据222里的body也是个复杂类型，所以body存的是地址333333里的onclick指向一开始声明的fnfn=null，null是简单类型，因此fn的Stack区更改为null虽然fn=null，但是fn被onclick引用，而onclick被body引用，body被document引用因此fn不是垃圾document.body.onclick = fn;此时fn是垃圾,因为没有东西引用它 浅拷贝vs深拷贝1234567891011121314151617181920212223var a = 1;var b = a;b = 2;//这个时候改变bconsole.log(a);// 1 【a 完全不受 b 的影响】把a赋值给b，当b改变时，a依然不变，这就是深拷贝对于简单类型的数据来说，赋值就是深拷贝。对于复杂类型的数据（对象）来说，才要区分浅拷贝和深拷贝。----------对象的浅拷贝：var a = &#123;name:'stage'&#125;; //复杂类型var b = a; // b的地址就是a的地址，因此指向a的数据b.name = 'xxx'; //修改a的地址对应的数据console.log(a.name) // 'xxx' 把a赋值给b(复杂类型的赋值只是将Stack区的地址进行了拷贝)，当b改变时，a也改变，这就是浅拷贝对象的深拷贝：var a = &#123;name: 'frank'&#125;var b = deepClone(a) // deepClone 还不知道怎么实现b.name = 'b'a.name === 'a' // true对象的深拷贝就是对 Heap 区进行完全的拷贝。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>笔记</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js里的数据类型]]></title>
    <url>%2F2018%2F03%2F03%2Fjs%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数字number字符串string布尔值booleanundefined未定义null对象object符号symbol js里的7种数据类型 number 数字 string 字符串 boolean 布尔值 symbol 符号 undefined null object 对象(数组array和函数function都是对象) typeof返回的都是字符串类型xxx 的类型stringnumberbooleansymbolundefinednullobjectfunctiontypeof xxx‘string’‘number’‘boolean’‘symbol’‘undefined’‘object’‘object’‘function’ number数字 整数和小数：1 1.1 .1 科学记数法：1.23e2 //123【表示1.23乘以10的2次方】 二进制：0b11 //3 【以0b开头的，js默认为二进制】 八进制：011（后来 ES5 添加了 0o11 语法）//3 【以0开头的默认为8进制】 十六进制：0x11 //17 【以0x开头的默认为16进制】 string字符串 空字符串：&#39;&#39; //空字符串的length=0 字符串换行： 12var s = `1234567890`; // 含换行符号,所以s.length=11 符号转义 1234567var s = '\''; // 'var s = '\n' // 回车var s = '\t' // tabvar s = '\\' // \ 用转义符转义斜杠 boolean布尔值 a &amp;&amp; b 与运算 a || b 或运算 null空对象,undefined空非对象 如果想声明一个对象，但暂且不赋值，用null表示空对象var obj = null 非对象声明，但暂且不赋值，用undefined(但是实际上你直接 var xxx 一下就行了)1234var notObj = undefined;简写为var notObj; object对象基本对象123456789101112var 王花花 = &#123; age: 18, gender: 'female', height: 168, weight: 57, married: true&#125;;王花花.age // 18等同于 王花花['age']王花花.gender // fenale等同于 王花花['gender'] 复杂对象12345678910111213141516var x = &#123; a: 1, b: 2, c: &#123; c1: 3, c2: 4, c3: &#123; d1: 5, d2: 6 &#125; &#125;&#125;;x.c // &#123;c1: 3, c2: 4&#125;x.c.c1 // 3x.c.c3.d2 // 6 对象的格式1234567891011121314151617var obj = &#123; 9a: 'hello' //报错，key不加引号，则命名需要按照变量名的命名规则，不能以数字开头&#125;; var obj = &#123; '9a': 'hello' //9a加上单引号就不报错了&#125;;-----------------var obj = &#123; '': 'hello' //空字符串可以作为key&#125;obj[''] // hellovar obj = &#123; 名字: '王花花' //可以用中文作为key名，因为在变量名的命名规则中，中文命名是合法的&#125; 操作对象12345678910111213141516171819var obj = &#123; a: 1, b: 2, c: 3&#125;;删除 delete obj.a;等同于delete obj['a'];某1个key是否存在'a' in obj;//true遍历对象for (var key in obj) &#123; console.log(key); // a,b,c console.log(obj[key]); //1,2,3&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>笔记</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js和npm]]></title>
    <url>%2F2018%2F03%2F02%2FNode-js%E5%92%8Cnpm%2F</url>
    <content type="text"><![CDATA[node.js的常用命令npm的配置及使用 Node.js从官网下载node.jsshift + 鼠标右键，选择在此处打开命令窗口 Node.js相关命令 where node ：查看node安装位置 where npm ：查看npm安装位置 node -v：查看版本号 npm -v exit：退出 npm配置npm12345678910111213npm config set registry https://registry.npm.taobao.org/npm config set loglevel httpnpm config set progress falsenpm config set strict-ssl false---------------npm config，可以看到config可以简写为c所以上面的4句话可以简写为npm c set registry https://registry.npm.taobao.org/npm c set loglevel httpnpm c set progress falsenpm c set strict-ssl false npm 的配置被存储在 ~/.npmrc，你可以随时通过npm c edit查看修改。 安装模块http-servernpm i http-server -g(默认安装在C:\Users\Administrator\AppData\Roaming\npm\node_modules) 然后就可以使用 http-server 或者 hs 来启动http-server了ctrl + C退出http-server http-server的使用: 输入 hs 文件路径 参数 启用，默认localhost:8080如果直接 hs -c-1 就是在当前目录启用,禁止缓存,自动打开浏览器如果hhs D:\饥人谷\resume -c-1 -o 就是在指定的路径启用,禁止缓存,自动打开浏览器 如果想改变端口和地址采用这个方式：http-server &lt;文件路径&gt; -a hostip -p 端口号。参数-a是监听地址，而参数-p是修改监听端口。 -o 启动服务器后打开浏览器窗口-c 设置缓存控制max-age头的缓存时间（以秒为单位），例如-c10 10秒（默认为’3600’）。要禁用缓存，请使用-c-1，因为有时候修改代码后重启服务页面不一定立刻生效，所以禁用缓存-p 要使用的端口（默认为8080）-a 要使用的地址（默认为0.0.0.0）-d 显示目录列表（默认为“True”）-s或--silent从输出中抑制日志消息:这个意思就是你输入之后，日志消息不会显示 hs -h查看帮助]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js获取数组中的最大值的方法]]></title>
    <url>%2F2018%2F02%2F28%2Fjs%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[12345678910111213max = Math.max(1,32,45,31,3442,4);max = Math.max.apply(null,arr); max = Math.max(...arr); max = Math.max.call(null,7,2,0,-3,5); max = arr.sort().reverse()[0]; max = arr.sort(function(a,b)&#123; return b-a;&#125;)[0]; 1.Math.max()法12var max = Math.max(1,32,45,31,3442,4);console.log(max) apply()法1234在ES5中，使用Math.max函数的apply方法获取数组最大值使用null作为参数var arr = [7,2,0,-3,5];var max = Math.max.apply(null,arr);console.log(max) Math.max(…arr);1234在ES6中, 我们使用展开运算符...作为函数的参数var arr = [7,2,0,-3,5];var max = Math.max(...arr);console.log(max); 2.call()法12var max = Math.max.call(null,7,2,0,-3,5)console.log(max) 3.sort()+reverse()后，获取第0个1234var arr = [7,2,0,-3,5];//sort()排序默认为从小到大，reverse()将数组反转var max = arr.sort().reverse()[0];console.log(max); 4.sort()b-a后获取第0个123456var arr = [7,2,0,-3,5];//b-a从大到小，a-b从小到大var max = arr.sort(function(a,b)&#123; return b-a;&#125;)[0];console.log(max)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>笔记</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习canvas]]></title>
    <url>%2F2018%2F02%2F28%2F%E5%AD%A6%E4%B9%A0canvas%2F</url>
    <content type="text"><![CDATA[基本语法12345678910111213&lt;canvas width="300" height="300" id="canvas"&gt;&lt;/canvas&gt;&lt;script type="text/javascript"&gt; var canvas = document.getElementById('canvas'); var ctx = canvas.getContext('2d');//获取canvas的2d上下文 //必须先给颜色，再画图，顺序不能错！！！ ctx.fillStyle = 'red';//填充色 ctx.fillRect(10, 10, 100, 100);//在(10,10)处画一个100x100的填充矩形(fillRect) ctx.fillStyle = 'red';//描边色 ctx.strokeRect(10, 10, 100, 100);//描边矩形&lt;/script&gt; 设置画布高度canvas设置宽高时，由于它是inline元素，所以先要设置display:block或者vertical-align: top;；然后修改它的属性宽高，而不是css的宽高12345#canvas&#123; display: block; 或者 vertical-align:&#125; 画个矩形12345ctx.fillStyle = 'red';//填充色ctx.fillRect(10, 10, 100, 100);//在(10,10)处画一个100x100的填充矩形(fillRect)ctx.fillStyle = 'red';//描边色ctx.strokeRect(10, 10, 100, 100);//描边矩形 画个三角形123456//画个三角 ctx.beginPath();//老子要开始画图啦！ ctx.moveTo(300,240);//先在(300,240)这取个点 ctx.lineTo(300,300);//连接到(300,300) ctx.lineTo(240,270);//连接到(240,270) ctx.fill();//填充颜色(默认填充最近的ctx.fillStyle的颜色) 画个圆Math.PI表示π,弧度=(Math.PI/180)*角度12345ctx.arc(x, y, 半径, 起始弧度, 结束弧度, 默认顺时针画/设置true逆时针画); ctx.beginPath();//老子要开始画图啦！ ctx.arc(160, 140, 10,0,2*Math.PI);//在(160,140)的位置，画1个半径为10,起始弧度0，终止弧度为2π的圆，默认顺时针画 ctx.fill();//填充颜色 画个圆弧边123ctx.beginPath();//老子要开始画图啦！ctx.arc(190, 170, 50,0,Math.PI/2);//在(160,140)的位置，画1个半径为10,起始弧度0，终止弧度为2π的圆，默认顺时针画ctx.stroke();//描边 画条线(绘制路径)1234567function drawLine(x1,y1,x2,y2) &#123; ctx.beginPath(); ctx.lineWidth = 5; ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); &#125; 橡皮擦123456擦除部分内容ctx.clearRect(50,50,10,10);//在(50,50)这点擦去10x10的矩形【橡皮擦】清屏var paper = document.getElementById('canvas');ctx.clearRect(0,0,paper.width,paper.height);//挖去一个和画布大小一样的矩形【橡皮擦】 保存为图片12345678 var paper = document.getElementById('canvas'); a.onclick = function () &#123; var imgUrl = paper.toDataURL("image/png"); a.href = imgUrl; a.download = '图片.png';//设置保存时的默认名字 &#125;`]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>html</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript知识点补充]]></title>
    <url>%2F2018%2F02%2F27%2FJavaScript%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[javascript查漏补缺，一些零碎的知识点的补充 sublime正则替换的用法store.js的使用记得判断是否存在容器12website = store.get('容器1') || website;//从容器1中取出website,如果存在就覆盖原始的website，如果不存在就使用原始的website prompt的使用弹出一个确认框。如果点击取消，则promote返回null，所以要做判断是否点击确定还是取消 键盘事件要加在document身上键盘事件要加在document身上1document.onkeypress = fn1; ev123xxx.onclick= function (ev) &#123; console.log(ev); //可以看到许多和ev有关的内容 &#125; ev.targetev.key和ev.keyCodeev.key直接获取按下哪个键ev.keyCode获取键值 oImg.onerror123oImg.onerror = function (ev) &#123; ev.target.src = &apos;//i.loli.net/2017/11/10/5a051fbc5e183.png&apos;;//如果网络图标下载出错就改用默认图标&#125; open和location.href12345open('http://www.qq.com'); //默认新窗口打开open('http://www.qq.com', '_blank');//同上open('http://www.qq.com', '_self');//在当前窗口打开location.href = 'http://www.baidu.com'//同上 函数封装123456function tag(tagName, attr)&#123; //tag('div', &#123;id:'div1', className:'test'&#125;) var ele = document.creatElement(tagName); for (var key in attr) &#123; //遍历attr里的所有键值对 ele[key] = attr[key]; //div.id=div1, div.className=test &#125; return ele; return多个时要用json123456789101112131415161718function init() &#123; var keys = [ ['q','w','e','r','t','y','u','i','o','p'], ['a','s','d','f','g','h','j','k','l'] ]; var website = &#123; 'q': 'qq.com', 'w': 'weibo.com' &#125;; return &#123; 'keys': keys, 'website': website &#125;&#125;var keys = init().keys; //或写成init()['keys']var website = init().website; //或写成init()['website'] 三元运算123var n = 7;var msg = '数字' + n + '是' + (n % 2 === 0 ? '偶数' : '奇数');console.log(msg); 变量提升所有的变量的声明语句var，都会被提升到代码的头部，这就叫做变量提升12345678console.log(a);//undefinedvar a = 1;等同于var a; //var提升到头部，此时a = undefinedconsole.log(a);a = 1; js命名规范js对大小写敏感，所以var a和var A是不同的。要求：第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。中文是合法的标识符，可以用作变量名。1var 临时变量 = 1; sitch语句。多个if…else连在一起使用的时候，可以转为使用更方便的switch结构。12345678910111213141516171819202122232425262728switch (fruit) &#123; case "banana": // ... break; case "apple": // ... break; default: // ...&#125;每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块var x = 1;switch (x) &#123; case 1: console.log('x 等于1'); case 2: console.log('x 等于2'); default: console.log('x 等于其他值');&#125;// x等于1// x等于2// x等于其他值上面代码中，case代码块之中没有break语句，导致一直执行下去 switch语句采用的是严格相等运算符（===），而不是相等运算符（==） do…while 循环 while循环句末没有分号，而do…while 循环 句末必须要有分号 不管条件是否为真，do…while都会执行一次语句1234567891011do &#123; 语句&#125; while (条件);-----------------var x = 3;var i = 0;do &#123; console.log(i); i++;&#125; while(i &lt; x); break 语句和 continue 语句 break语句用于直接跳出代码块或循环、直接停止。 123456789for (var i = 0; i &lt; 5; i++) &#123; console.log(i); if (i === 3) break; //i==3时跳出去，停止该循环&#125;// 0// 1// 2// 3 continue语句立即终止本次循环，并直接开始下一轮循环。 1234567var i = 0;while (i &lt; 100)&#123; i++; if (i % 2 === 0) continue; console.log('i 当前为：' + i);&#125; 上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环。 如果存在多重for循环，不带label的break语句和continue语句都只针对最内层循环。 跳转标签（label）123456789101112131415161718192021222324252627282930313233343536373839404142标签名: 语句 --------------- top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) break top; console.log('i=' + i + ', j=' + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0上面代码为一个双重for循环，break命令后面加上了top标签，满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。----------------------continue语句也可以与标签配合使用。here: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) continue here; console.log('i=' + i + ', j=' + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// i=2, j=0// i=2, j=1// i=2, j=2上面代码中，continue命令后面有一个标签名here，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环。 null和undefined123456789Number(null) // 05 + null // 5null是一个表示“空”的对象，null转为数字时，自动变成0。---------------Number(undefined) // NaN5 + undefined // NaNundefined是一个表示”此处无定义”的原始值，转为数值时为NaN 空数组（[]）和空对象（{}）对应的布尔值，都是true123456789if ([]) &#123; console.log('true');&#125;// trueif (&#123;&#125;) &#123; console.log('true');&#125;// true js中的科学计数法1234567123e3 // 123000123e-3 // 0.123-3.1e+12 //-3100000000000.1e-23 //1e-24小数点后紧跟5个以上的零，就自动转为科学计数法0.0000003 // 3e-7 js会自动进制转换默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。1234567891011120xff // 2550o377 // 2550b11 // 3----------有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。0888 // 8880777 // 511 判断浏览器是否支持标签的某个属性123判断浏览器是否支持a标签的download属性"download" in document.createElement('a');//true or false 获取移动端坐标123var ev = ev.touches[0];//获取第一个触摸点var x = ev.clientX;由于触摸屏支持多点触控，有好几个touches,所以不能通过ev.clientX获取坐标 移动端必须在ontouchstart时，ev.preventDefault();阻止屏幕的滚动btoa将字符串转成base64123456789101112btoa('stage'); // c3RhZ2U=atob将base64转回字符串atob('c3RhZ2U='); // stage不支持中文，要把中文转成base64，必须加入encodeURI()转码环节btoa('你好') //报错btoa(encodeURI('你好')) // JUU0JUJEJUEwJUU1JUE1JUJEbase64还原成中文需要decodeURI()解码decodeURI(atob('JUU0JUJEJUEwJUU1JUE1JUJE')) //你好注意，encode在中间环节，decode在最终环节 ev.target 和 ev.currentTarget12345678&lt;a href="#" id="a"&gt; &lt;span&gt;111&lt;/span&gt;&lt;/a&gt;a.onclick = function(ev)&#123; console.log(ev.target) // &lt;a href="#" id="a"&gt;&lt;span&gt;111&lt;/span&gt;&lt;/a&gt; console.log(ev.currentTarget) // &lt;span&gt;111&lt;/span&gt;&#125; a.href 和 a.getAttribute(‘href’)1234a.onclick = function () &#123; console.log(a.href);//自动添加http协议 console.log(a.getAttribute('href'));// #about&#125; ele.offsetTop() 和 window.scrollTo(x,y)12var posY = ele.offsetTop;window.scrollTo(0,posY); 缓动效果]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>笔记</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2018%2F02%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[本文主要介绍了哈希、队列、栈(stack)、链表、数(tree) 哈希（Hash）满足键值对(‘key’:’value’)的就是哈希。数组就是哈希 计数排序中的桶（复杂度 O(n+max)，比快排还快12345678910111213141516171819202122计数排序：数组[第0个是4，第1个是1，第二个是8......]将数组['0':4,'1':1,'2':8,'3':2,'4':9,'5':8,'length':6 //length等于最大下标index+1]里的值放入桶内hash=[]hash['1':1 //1有1个'2':1'4':1'8':2 //8有2个'9':1] //hash的length=10，因为最大下标index是9然后再从桶里把数值取出来newArr=[]newArr[1,2,4,8,8,9] 123456789101112131415161718192021222324252627282930313233计数排序的js代码var a = [0,2,1,56,4,67,3,2];//存入hashvar hash = &#123;&#125;;for (i=0;i&lt;a.length;i++) &#123; var num = a[i]; if(!hash[num])&#123;//如果还没有对应的hash hash[num] = 1; &#125; else &#123; hash[num]++; &#125;&#125;/* console.log(hash); 结果hash = &#123;0: 1, 1: 1, 2: 2, 3: 1, 4: 1, 56: 1, 67: 1&#125;，表示数字0有1个，数字1有1个，数字2有2个，数字3有1个...... *///从hash中取出var max = Math.max.apply(null,a);//获取hash里的最大值//最大值是max,那么hash的长度length就是max+1;var length = max+1;var result = [];for (i=0;i&lt;length;i++)&#123; var 个数 = hash[i]; if (个数) &#123;//如果不是0个 for (j=0;j&lt;个数;j++) &#123; result.push(i); &#125; &#125; &#125;console.log(result); (桶排序)[http://bubkoo.com/2014/01/15/sort-algorithm/bucket-sort/] 与计数排序的区别 123456789桶排序hash['1':[5,2,8] //第1个桶表示10以内的数有5,2,8，然后将这个桶内的数字二次排序'2':[]'3':[27]'4':[33,37,31] //40以内的数有33,37,31,将这几个数字二次排序]与计数排序的区别：假设数组中最大的数是1000，那么计数排序需要1000个桶，而桶排序(如果每个桶的区间是100一分割),那么只需要10个桶，但是桶内的数们需要二次排序 (基数排序)[http://bubkoo.com/2014/01/15/sort-algorithm/radix-sort/] 与计数排序的区别 1基数排序始终只有10个桶，按照个位、十位、百位、千位.....的数值进行比较,每个桶里的数们组成队列，先进先出 队列（Queue） 先进先出 可以用数组实现 举例：排队1var out = arr.shift() 栈（Stack） 先进后出 可以用数组实现 举例：坐电梯1var out = arr.pop() 链表（Linked List） 数组无法直接删除中间的一项，链表可以 用哈希（JS里面用对象表示哈希）实现链表(一个哈希指向另一个哈希) 123456789101112131415161718192021[0,2,1]var a = &#123;value:0, next:&#123; value:2, next:&#123; value:1, next:undefined &#125; &#125;&#125;a.value //0a.next.value //2a.next.next.value //1删除中间的2:a.next = a.next.next //将a.next指向a.next.nexta.value //仍旧是0a.next.value //变成了1a.next.next.value //undefined head、node 概念 12head：链表的表头node：节点，表头属于第一个节点 树（tree）https://segmentfault.com/a/1190000000740261 举例：有层级结构的需要用到tree，比如DOM树 概念：层数(第0层、第1层、第2层…)、深度(总共有几层)、节点个数(没有下一个节点的叫做叶子节点) 二叉树 满二叉树 完全二叉树 完全二叉树和满二叉树可以用数组实现 123456789arr=[1,2,3,4,5,6,7,8,9,10,11,12,13,15,15]如何取第3层的第1个数字？arr[Math.pow(2,3-1)-1] //4 【2的3减1次方后减1】如何取第3层的第2个数字？arr[Math.pow(2,3-1)-1+1]如何取第3层的第3个数字？arr[Math.pow(2,3-1)-1+2] 其他树可以用哈希（对象）实现 操作：增删改查 堆排序用到了 tree 1.将数组里的数表示成完全二叉树2.然后进行最大堆调整【每个父节点的数值都大于等于其两个孩子结点的数值】：从最后一层的最右边开始到最左边，然后上一层的最右边到最左边，每发生一次交换时，踢下来的数都需要与子节点再次比较3.最终，最上面的那个数就是最大的数，把他与最后一个数交换(即放到数组的最后一位)，且这个最大数不再参与排序4.由于顶上的数发生了交换，所以继续进行顶上的数与两个子节点比较(也就是说，一开始是从右往左，从下往上比较；当第一次最大堆调整完后，将顶点的数与最后一个数进行交换；接下来就是从上到下进行比较了) 12345671.将数组里的数表现成完全二叉树的形式2.进行最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点3.创建最大堆：将堆所有数据重新排序，使其成为最大堆此时最顶端(根节点)的数就是最大的数4.将根节点的数和最后一个数交换位置，并将最大数挪出，不参与下一轮的排序5.由于第4步根节点发生了变化，所以剩余的堆需要继续调整为最大堆6.重复2~5的过程，直到剩余数只有一个时结束。 其他：B树、红黑树、AVL树 堆排序可视化https://www.cs.usfca.edu/~galles/visualization/HeapSort.html 堆排序JS代码完整讲解（看到最后）：http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法初级]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%AE%97%E6%B3%95%E5%88%9D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[排序算法列表https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#排序算法列表 冒泡排序 http://bubkoo.com/2014/01/12/sort-algorithm/bubble-sort/ 插入排序 http://bubkoo.com/2014/01/14/sort-algorithm/insertion-sort/ 桶排序 http://bubkoo.com/2014/01/15/sort-algorithm/bucket-sort/ 其他排序：http://bubkoo.com/tags/algorithm/ 算法的5个特征 输入：一个算法必须有零个或以上输入量。 输出：一个算法应有一个或以上输出量，输出量是算法计算的结果。 明确性：算法的描述必须无歧义，以保证算法的实际执行结果是精确地匹配要求或期望，通常要求实际运行结果是确定的。 有限性：算法必须在有限个步骤内完成任务。 有效性：又称可行性，能够实现，比如：通过代码让电脑生个孩子出来是不可行的。 数据结构就是数据的结构。 一般来说是这样的： 我们要解决一个跟数据相关的问题 分析这个问题，想出对应的数据结构 分析数据结构，想出算法 先分析数据的结构，再想出对应的算法数据结构和算法是互相依存、不可分开的 你学习完排序算法，就能了解常见的数据结构 5种排序算法 身高两两对比法（冒泡排序,按顺序两两对比交换位置） 12345678910111213141516171819202122232425以数组 arr = [5, 1, 4, 2, 8] 为例说明，加粗的数字表示每次循环要比较的两个数字：第一次外循环( **5 1** 4 2 8 ) → ( **1 5** 4 2 8 )， 5 &gt; 1 交换位置( 1 **5 4** 2 8 ) → ( 1 **4 5** 2 8 )， 5 &gt; 4 交换位置( 1 4 **5 2** 8 ) → ( 1 4 **2 5** 8 )， 5 &gt; 2 交换位置( 1 4 2 **5 8** ) → ( 1 4 2 **5 8** )， 5 &lt; 8 位置不变第二次外循环（除开最后一个元素8不动，对剩余的序列）( **1 4** 2 5 8 ) → ( **1 4** 2 5 8 )， 1 &lt; 4 位置不变( 1 **4 2** 5 8 ) → ( 1 **2 4** 5 8 )， 4 &gt; 2 交换位置( 1 2 **4 5** 8 ) → ( 1 2 **4 5** 8 )， 4 &lt; 5 位置不变8固定在最后第三次外循环（除开已经排序好的最后两个元素，可以注意到上面的数组其实已经排序完成，但是程序本身并不知道，所以还要进行后续的循环，直到剩余的序列为 1）5,8固定不变( **1 2** 4 5 8 ) → ( **1 2** 4 5 8 )( 1 **2 4** 5 8 ) → ( 1 **2 4** 5 8 )4,5,8固定不变第四次外循环（最后一次）( *1 2* 4 5 8 ) → ( *1 2* 4 5 8 ) 体育老师一指禅法（选择排序,每次从一堆中选出最小的那个数排到最前面，然后后面剩余的数重复这个步骤） 整理扑克牌法（插入排序） 桌上散落的扑克牌整理法（桶排序、基数排序） 快排(每次快排择第一个数作为基准分割左右) 随机快排(每次快排随机选择一个数站定分割左右) 归并排序 堆排序 排序算法js代码https://www.cnblogs.com/Unknw/p/6346681.html 排序可视化排序可视化：https://visualgo.net/zh/sorting]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css知识点补充]]></title>
    <url>%2F2018%2F02%2F23%2Fcss%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[css知识点查漏补缺，知识点补充，比较零碎 文档流文档流：文档内 元素流动的方向。inline元素从左往右流动→，如果宽度不够另挤一行block元素独占一行，从上往下流动↓ 块级元素块级元素的高度由其 内部文档流元素 的 高度总和 决定 块级元素居中margin:0 auto; 内联元素的高度多个内联元素以baseline对齐内联元素如果同处一个块元素内，那么按照基线对齐(可以通过vertical-align来设置内联元素对齐方式)可以看到，x不是在div的正中间，而是与hug的基线对齐 渐变gradient 在线渐变生成器:http://www.colorzilla.com/gradient-editor/ 设置dib后，一定要加上vat12display: inline-block;vertical-align: top; text-transform: uppercase将字母变成大写 利用box-shadow实现多层边框(立体感)12box-shadow: 向左 向下 模糊程度 一个不模糊的边框 内阴影inset;box-shadow: 0 0 0 1px #1a1b1c, 0 0 0 2px #1f2020, 0 3px 0 1px #080808; 100vh使元素的高度占满可视区高度12div&#123;height: 100vh&#125;再利用flex就可以使元素内的item相对于可视区居中 icon图标123将favicon.ico放在根目录下如果要获取其他网站的icon，可以通过 //该网站根目录/favicon.ico比如 //www.qq.com/favicon.ico 就可以获得qq的icon overflow:hidden别给老子出现滚动条！]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>面试题</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习记录]]></title>
    <url>%2F2018%2F02%2F23%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[- 9.HTML 续http-server的安装视频iframe和a这一节有介绍 10.入门css知识点 如何做横向布局（float + clearfix） 继承样式inherit 四种引入 CSS 的方式：行间样式、内部样式、外部样式、@import 作业完成简历的logo和top-navbar 11.CSS 布局与定位知识点 尽量不要设置width和height，通过调节padding来自适应. 用max-width代替width，这样当屏幕小于这个width时会自适应缩放 高度是由什么决定的 什么是文档流【文档内元素流动的方向】 内联元素 与 块级元素 line-box 是啥 box 是啥（盒模型） 宽度是有什么决定的 position 的 5 个取值 脱离文档流 background-size:cover z-index 作业 大背景图 大名片card 12.CSS 布局与定位续知识点 太极图12线性渐变background: linear-gradient(to bottom, white 0%,white 50%,black 50%,black 100%);:before,:after伪元素 作业 制作下载按钮 技能百分比条 非线性布局1234设置dib后，一定要加上vatdisplay: inline-block;vertical-align: top; 13.命令行 HTTP Node.js HTML CSS 小结命令行复习123456789101112131415161718192021222324252627pwd progress working dircd change dirmkdir make dirtouch echo &quot;hi&quot; &gt; 1.txtecho &quot;hi&quot; &gt;&gt; 1.txtecho &quot;hi&quot; &gt;! 1.txtcp -rrm -rfmvtree git initgit addgit commit -m &quot;hi&quot;git pullgit pushgit clonecurl -L http://baidu.comcurl -s -v -- http://baidu.comping qq.comhexo inithexo ghexo serverhexo deploy HTTP请求与响应复习 请求包括 GET(获取) POST(上传) PUT(整体更新) PATCH(局部更新) DELETE(删除) HEAD OPTIONS等 能够手写http请求，能够手写http响应 Content-Type: application/x-www-form-urlencoded : 应用数据/还没有写入规范的格式-万维网-表单-用urlencode形式压缩 知道状态码的含义 TCP/IP协议 Node.jsServer14.算法初级 排序算法列表 https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#排序算法列表 冒泡排序 http://bubkoo.com/2014/01/12/sort-algorithm/bubble-sort/ 插入排序 http://bubkoo.com/2014/01/14/sort-algorithm/insertion-sort/ 桶排序 http://bubkoo.com/2014/01/15/sort-algorithm/bucket-sort/ 其他排序：http://bubkoo.com/tags/algorithm/ 快排、随机快排 排序算法js代码https://www.cnblogs.com/Unknw/p/6346681.html 15.数据结构哈希、队列、栈(stack)、链表、数(tree) 计数排序(有多少个数就有多少个桶)与桶排序(自定义一个范围桶)与基数排序(始终10个桶) 队列：先进先出，arr.shift() 栈：先进后出，arr.pop() 链表，可以用来删除数组中间的某个数 12345678910var a = &#123;value:0, next:&#123; value:2, next:&#123; value:1, next:undefined &#125; &#125;&#125; 树堆排序:https://www.cs.usfca.edu/~galles/visualization/HeapSort.html 16.JavaScript 初体验做一个键盘导航代码和预览：https://github.com/FrankFang/nav-demo text-transform: uppercase将字母变成大写 sublime正则替换的用法for循环创建divstore.js的使用记得判断是否存在容器12website = store.get('容器1') || website;//从容器1中取出website,如果存在就覆盖原始的website，如果不存在就使用原始的website create元素和append元素prompt的使用如果点击取消，则promote返回null，所以要做判断是否点击确定还是取消 键盘事件要加在document身上这个事件加在document身上1document.onkeypress = fn1; ev123xxx.onclick= function (ev) &#123; console.log(ev); //可以看到许多和ev有关的内容 &#125; ev.targetev.key和ev.keyCodeev.key直接获取按下哪个键ev.keyCode获取键值 open和location.href12345open('http://www.qq.com'); //默认新窗口打开open('http://www.qq.com', '_blank');//同上open('http://www.qq.com', '_self');//在当前窗口打开location.href = 'http://www.baidu.com'//同上 17.第一个 JS 作品完善上一节课的键盘导航键盘参考：http://mcdlr.com/key-sheet/代码参考：https://github.com/FrankFang/nav-demo/ 知识点渐变色1background: linear-gradient(to bottom,#292929,#111); 利用box-shadow实现多层边框(立体感)12box-shadow: 向左 向下 模糊程度 一个不模糊的边框 内阴影inset;box-shadow: 0 0 0 1px #1a1b1c, 0 0 0 2px #1f2020, 0 3px 0 1px #080808; 100vh使元素的高度占满可视区高度12body&#123;height: 100vh&#125;再利用flex就可以使元素内的item相对于可视区居中 ico图标123将favicon.ico放在根目录下如果要获取其他网站的icon，可以通过 //该网站根目录/favicon.ico比如 //www.qq.com/favicon.ico 就可以获得qq的icon oImg.onerror123oImg.onerror = function (ev) &#123; ev.target.src = &apos;//i.loli.net/2017/11/10/5a051fbc5e183.png&apos;;//如果网络图标下载出错就改用默认图标&#125; 函数封装123456function tag(tagName, attr)&#123; //tag('div', &#123;id:'div1', className:'test'&#125;) var ele = document.creatElement(tagName); for (var key in attr) &#123; //遍历attr里的所有键值对 ele[key] = attr[key]; //div.id=div1, div.className=test &#125; return ele; return多个时要用json123456789101112131415161718function init() &#123; var keys = [ ['q','w','e','r','t','y','u','i','o','p'], ['a','s','d','f','g','h','j','k','l'] ]; var website = &#123; 'q': 'qq.com', 'w': 'weibo.com' &#125;; return &#123; 'keys': keys, 'website': website &#125;&#125;var keys = init().keys; //或写成init()['keys']var website = init().website; //或写成init()['website'] 18.Canvas画板知识点鼠标事件123document.onmousemove = fn1;document.onmousedown = fn1;document.onmouseup = fn1; canvas canvas设置宽高时，由于它是inline元素，所以先要设置display:block或者vertical-align: top;；然后修改它的属性宽高，而不是css的宽高 19.手机端画板添加viewport方法:meta:vp + tab touch方法 手机端没有鼠标，所以不能用onmouse方法，而应该用ontouch方法 123元素.ontouchstart = fn;元素.ontouchmove = fn;元素.ontouchend = fn; 判断是否支持touch方法(特性检测) 1234567if (document.body.ontouchstart !== undefined) &#123; //是触屏设备&#125; else &#123; //是非触屏设备&#125; 判断浏览器是否支持标签的某个属性123判断浏览器是否支持a标签的download属性"download" in document.createElement('a');//true or false 判断是否是移动设备1234567891011在w3school上看到可以这样来判断平台：function checkStation()&#123; var info = navigator.userAgent; if(info.indexOf("iPod")!=-1 || info.indexOf("iPad")!=-1 || info.indexOf("iPhone")!=-1 || info.indexOf("Android")!=-1)&#123; alert("平板"); return true; &#125;else&#123; alert("电脑"); return false; &#125;&#125; 获取触摸坐标123var ev = ev.touches[0];//获取第一个触摸点var x = ev.clientX;由于触摸屏支持多点触控，有好几个touches,所以不能通过ev.clientX获取坐标 移动端必须在ontouchstart时，ev.preventDefault();阻止屏幕的滚动iconfont的使用 批量去色有些icon有默认色，为了icon颜色统一，建议批量去色选择完icon并添加至项目后，选择批量操作里的批量去色 局域网调试利用http-server进行局域网调试 20.JS里的7种数据 number string boolean symbol undefined null object 21.类型转换btoa将字符串转为base64类型转换5个falsy值内存图面试题-对象的引用面试题-垃圾回收面试题-深拷贝vs浅拷贝22.JS里的对象全局函数1.Numbervar n = new Number(1) 创建一个 Number 对象1 与 new Number(1) 的区别是什么？看内存图2.Stringvar s = new String(‘hello’) 创建一个 String 对象‘hello’ 与 new String(‘hello’) 的区别是什么？看内存图3.Booleanvar b = new Boolean(true) 创建一个 Boolean 对象true 与 new Boolean(true) 的区别是什么？看内存图4.Objectvar o1 = {}var o2 = new Object()o1 和 o2 没区别 原型prototypevar 对象 = new 全局函数() //函数包括Number(123)/String(‘123’)等全局函数对象.proto === 全局函数.prototype 23.给简历加 JS loading 动画 会变的navbar ， sticky navbar 鼠标滚动后导航栏黏着 会动的二级菜单menu 点击导航栏自己滚动到对应那一块 auto scroll smoothy chrome控制动画速度选中动画元素Elements → 点击三个点(更多) → More tools → Animations里控制动画的速度 scrollYvar y = scrollY;//window.scrollY,window可省略 字体颜色inheritev.target 和 ev.currentTargetxxx.tagName.toLowerCase()if (xxx.tagNamea.toLowerCase() == ‘ul’) a.href 和 a.getAttribute(‘href’)1234a.onclick = function () &#123; console.log(a.href);//自动补充完整http协议 console.log(a.getAttribute('href'));// #about&#125; ele.offsetTop() 和 window.scrollTo(x,y)12var posY = ele.offsetTop;window.scrollTo(0,posY); 24.给简历加 JS（续）平滑滚动smooth scroll tween.js滚动监听scrollspy检测元素出现在可视区12345678910111213141516171819&lt;div id="a"&gt;&lt;/div&gt;&lt;div id="b"&gt;&lt;/div&gt;&lt;div id="c"&gt;&lt;/div&gt;&lt;script&gt; var viewport = document.documentElement.clientHeight; var eles = document.querySelectorAll('div'); window.onscroll = function () &#123; for (var i = 0; i &lt; eles.length; i++) &#123; var eleCurrentTop = eles[i].getBoundingClientRect().top;//必须放在for循环里！ if(eleCurrentTop &lt; viewport-100)&#123; //alert('出现在可视区'); eles[i].classList.add('active'); &#125; &#125; &#125;&lt;/script&gt; 技能条加载动画25.JS 数组Array数据类型new不new的区别伪数组数组的操作(api)26.函数Function函数的声明方法eval()函数的调用call、this、arguments面试题call stack调用栈作用域面试题闭包27.DOM API文档对象模型 DOM各种api的操作28.jQuery 不过如此三等号===三等号 NaN永远不等于NaN对象永远不等于对象，因为他们在stack区的Address地址不一样 封装自己的js库jquery原理29.用 jQuery 做个轮播吧]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[空元素与可替换元素]]></title>
    <url>%2F2018%2F02%2F22%2F%E7%A9%BA%E6%A0%87%E7%AD%BE%E4%B8%8E%E5%8F%AF%E6%9B%BF%E6%8D%A2%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[空元素，不需要闭合的元素;没有伪元素:before和:after可替换元素,它的展现不由CSS来控制 空元素，不需要闭合的元素空元素没有伪元素:before和:after1234567891011121314151617&lt;br&gt;&lt;hr&gt;&lt;link&gt;&lt;meta&gt;&lt;img&gt;&lt;input&gt;&lt;area&gt;&lt;base&gt;&lt;col&gt;&lt;colgroup&gt; when the span is present&lt;command&gt;&lt;embed&gt;&lt;keygen&gt;&lt;param&gt;&lt;source&gt;&lt;track&gt;&lt;wbr&gt; 可替换元素,它的展现不由CSS来控制12&lt;img&gt;、 &lt;object&gt;、 &lt;video&gt; 、&lt;textarea&gt;、 &lt;input&gt;、&lt;audio&gt; 和 &lt;canvas&gt;这类元素一开始就有样式，比如img的宽高由引入的图片大小决定]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>面试题</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html知识点补充]]></title>
    <url>%2F2018%2F02%2F22%2Fhtml%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[html知识点补充，查漏补缺，比较零碎 iframe 标签嵌套页面12&lt;iframe src="https://www.baidu.com" name="qqqqq" width=100% height=200 &gt;&lt;/iframe&gt;&lt;a href="https://www.qq.com" name="qqqqq"&gt;在name=qqqqq的iframe中打开&lt;/a&gt; a 标签跳转页面（HTTP GET 请求） download属性123456&lt;a href="xxxx" download&gt;下载链接&lt;/a&gt;&lt;a href="http://www.xxx.com/3.png" download="3.png"&gt;下载图片3.png&lt;/a&gt;加上download属性，就会下载下来否则就是用浏览器打开预览文件download="文件名"用js可以操作文件名，比如a.download = imgName + '.png'; target属性12345&lt;a target="_blank|_self|_parent|_top|framename"&gt;_blank 在新窗口中打开_self 在a标签所在的页面中打开_parent 在a标签所在页面的父级窗口中打开_top 如果嵌套iframe,就在最顶层（也就是当前页面）中打开 href属性1234567891011121314151617181920212223绝对路径&lt;a href="www.qq.com"&gt;错误！！！！漏了协议&lt;/a&gt;&lt;a href="https://www.qq.com"&gt;正确，https协议&lt;/a&gt;&lt;a href="//www.qq.com"&gt;正确,自定义协议&lt;/a&gt;相对路径&lt;a href="./xxx.html"&gt;&lt;/a&gt;结果打开127.0.0.1:8080/xxx.html&lt;a href="#锚点"&gt;&lt;/a&gt;结果打开127.0.0.1:8080/index.html#锚点，锚点不发起请求&lt;a href="?name=stage"&gt;&lt;/a&gt;结果打开127.0.0.1:8080/index.html?name=stage,自动发起 ?name=stage 的GET请求&lt;a href="javascript:;"&gt;&lt;/a&gt;点击之后什么都不发生&lt;a href="#"&gt;&lt;/a&gt;点击之后不刷新，锚点变成#，滚回到顶部&lt;a href=""&gt;&lt;/a&gt;点击之后刷新当前页面 form12345678&lt;form action="index2.php" method="get"&gt; First name: &lt;input type="text" name="fname"&gt;&lt;br&gt; Last name: &lt;input type="text" name="lname"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;将fname=xxx&amp;lname=xxx提交到index2.php中文会转码 method属性 GET时，如果有提交的数据，数据会作为查询参数出现在地址栏127.0.0.1::8080/index.html?fname=xxx&amp;lname=xxx POST时，用Chrome开发者工具可以看到，数据在Form Data里 重点如果一个表单中没有input-submit时 如果有&lt;button&gt;没有写type的按钮&lt;/button&gt;，该button自动升级为type=submit，可以提交表单 如果写了type=button，则无法提交表单 label1234567891011&lt;label for="male"&gt;文字&lt;/label&gt;&lt;input type="checkbox" name="male" id="male"&gt;这样点击文字也能选中复选框，请将label的for与input的id名对应---------------------简便写法：label把input包起来&lt;label&gt;文字&lt;input type="checkbox" name="male"&gt;&lt;/label&gt;这样就不用for和id名了 select1234567&lt;select name=&quot;choose&quot; multiple&gt; &lt;option value=&quot;&quot;&gt; - &lt;/option&gt; &lt;option value=&quot;1&quot; selected&gt;默认&lt;/option&gt; &lt;option value=&quot;2&quot; disabled&gt;禁选&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;4&lt;/option&gt;&lt;/select&gt; multiple属性该属性允许多选对于 windows：按住Ctrl按钮来选择多个选项 table可以用colgroup&gt;col控制表格的样式，第一个col控制第一竖列，第二个col控制第2竖列123456789101112131415161718192021222324252627&lt;table border=&quot;1&quot;&gt;&lt;colgroup&gt; &lt;col width=200&gt; &lt;col bgcolor=red&gt;&lt;/colgroup&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;得分&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt;&lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小红&lt;/td&gt;&lt;td&gt;80&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;所有人&lt;/td&gt; &lt;td&gt;180&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt;]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>面试题</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 与 Node.js服务器]]></title>
    <url>%2F2018%2F02%2F21%2FTCPIP%E4%B8%8ENodejs%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[TCP/IP 是供已连接因特网的计算机进行通信的通信协议。HTTP 协议的底层其实是由 TCP 协议(规定如何传输)和 IP 协议(规定如何连网)（简称 TCP/IP协议）构建的。 资料：菜鸟教程 - 学习TCP/IP TCP 传输控制协议（Transmission Control Protocol）TCP面试题问：TCP 和 UDP 的区别是什么1简答：TCP 可靠(能够知道发送的请求是否成功)、面向连接、相对 UDP 较慢；UDP 不可靠，不面向连接、相对 TCP 较快。 问：TCP 的三次握手指的是什么12345简答：每次建立连接前，客户端和服务端之前都要先进行三次对话才开始正式传输内容，三次对话大概是这样的： 1. 客户端：我要连接你了，可以吗 2. 服务端：嗯，我准备好了，连接我吧 3. 客户端：那我连接你咯。 4. 开始后面步骤 IP 网络协议（英语：Internet Protocol）IP 分为「内网 IP」 和「外网 IP」 路由器有两个 IP，一个外网 IP（每次重启路由器后会重新分配一个新的外网IP）和一个内网 IP（192.168.1.1） 127.0.0.1 localhost 本地ip,表示设备自己 还有一个特别特殊的 IP：0.0.0.0，它不表示任何设备。 端口(Port)如果一个服务器既提供 HTTP 服务，又提供 FTP 服务，还提供 SMTP 服务（邮件服务），那么只用一个 IP 是无法告诉服务器你想要使用哪种服务。 所以这里有一个重要的原则：一个端口对应一个服务。 要提供 HTTP 服务使用 80 端口 12访问https://www.baidu.com实际上是访问https://www.baidu.com:80浏览器帮你加了默认端口号 80。 要提供 HTTPS 服务使用 443 端口 要提供 FTP 服务使用 21 端口 总结：使用 HTTP 协议访问另一个 IP 时，必须同时提供 IP 和端口号，缺一不可。 用Node.js创建一个服务器接收请求我们的脚本只需要一个文件就可以搞定 新建一个目录cd ~/Desktop; mkdir node-demo; cd node-demo touch server.js 编辑 server.js，内容我已经上传到 GitHub。 或者curl https://raw.githubusercontent.com/FrankFang/nodejs-test/7f1a0ce15c47a6c2c938fe322f042e5d62bc7d01/server.js &gt; ./node-demo/server.js将代码下载到server.js文件内 运行 node server.js，看到报错 根据报错提示调整你的命令 成功之后，这个 server 会保持运行，持续监听，无法退出 如果你想「中断」这个 server，按 Ctrl + C 即可（C 就是 Cancel 的意思） 中断后你才能输入其他命令 我建议你把这个 server 放在那里别动，新开一个 Bash 窗口，完成下面的教程 curl -s -v -- http://qq.com/xxx?name=ff，其中查询参数是?name=ff,查询参数是包含问号的 好了服务器完成。只不过 这个服务器目前只有一个功能，那就是打印出路径和查询字符串 还缺少一个重要的功能，那就是发出 HTTP 响应 目前我们先只做一个功能玩玩。 接下来你要发起一个请求到这个服务器。这听起来有点怪异，「我向自己发起请求」，目前是的，因为你买不起服务器啊。 在新的 Bash 窗口运行 curl http://localhost:你的指定的端口/xxx?name=yyyy 或者 curl http://127.0.0.1:你指定的端口/xxx?name=yyyy。 你会马上发现 server 打印出了路径： 这说明我们的 server 收到了我们用 curl 发出的请求由于 server 迟迟没有发出响应，所以 curl 就一直等在那里，无法退出（用 Ctrl + C 中断这个傻 curl） 发出响应接下来我们让我们 server 发出响应 编辑 server.js 在中间我标注的区域添加两行代码 12345678910console.log(&apos;方方说：得到 HTTP 路径\n&apos; + path)if (path == &apos;/&apos;) &#123; response.write(&apos;Hi\n&apos;) &#125; else if (path == &apos;/index&apos;) &#123; response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;) response.write(&apos;&lt;!DOCTYPE html&gt;\n&lt;head&gt;&lt;body&gt;&lt;h1&gt;你好&lt;/h1&gt;&lt;/body&gt;&lt;/head&gt;&apos;)&#125; else &#123; response.statusCode = 404&#125;response.end() Ctrl+C 中断之前的 server，重新运行 node server.js 8888 curl http://127.0.0.1:8888/xxx，结果如下：1Hi% 这个 % 不是我们的内容，% 表示结尾。 好了，响应添加成功 使用 curl -s -v -- &quot;http://localhost:8888/xxx&quot; 可以查看完整的请求和响应 根据请求返回不同的响应 响应 / 响应 /xxx 响应 404 响应 /xxx.html 响应 /xxx.frank 再次强调，后缀是废话。文件内容是有 HTTP 头中的 Content-Type 保证的 响应 /xxx.css 响应 /xxx.js HTTP 路径不是文件路径！！！/xxx.html 不一定对应 xxx.html 文件 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)var url = require(&apos;url&apos;)var port = process.argv[2]if(!port)&#123; console.log(&apos;请指定端口号好不啦？\nnode server.js 8888 这样不会吗？&apos;) process.exit(1)&#125;var server = http.createServer(function(request, response)&#123; var parsedUrl = url.parse(request.url, true) var path = request.url var query = &apos;&apos; if(path.indexOf(&apos;?&apos;) &gt;= 0)&#123; query = path.substring(path.indexOf(&apos;?&apos;)) &#125; var pathNoQuery = parsedUrl.pathname var queryObject = parsedUrl.query var method = request.method /******** 从这里开始看，上面不要看 ************/ console.log(&apos;HTTP 路径是\n&apos; + path) if (path == &apos;/style.css&apos;) &#123; response.setHeader(&apos;Content-Type&apos;, &apos;text/css; charset=utf-8&apos;) response.write(&apos;body&#123;background-color: #ddd;&#125;h1&#123;color: red;&#125;&apos;) &#125; else if (path == &apos;/main.js&apos;) &#123; response.setHeader(&apos;Content-Type&apos;, &apos;text/javascript; charset=utf-8&apos;) response.write(&apos;alert(&quot;这是js执行的&quot;)&apos;) &#125; else if (path == &apos;/&apos;) &#123; response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;) response.write(&apos;&lt;!DOCTYPE html&gt;\n&lt;html&gt;&apos;+ &apos;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/style.css&quot;&gt;&lt;body&gt;&apos;+ &apos;&lt;h1&gt;你好&lt;/h1&gt;&apos;+&apos;&lt;script src=&quot;/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/head&gt;&lt;/html&gt;&apos;) &#125; else &#123; response.statusCode = 404 &#125; response.end() /******** 代码结束，下面不要看 ************/&#125;)server.listen(port)console.log(&apos;监听 &apos; + port + &apos; 成功\n请用在空中转体720度然后用电饭煲打开 http://localhost:&apos; + port)]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>HTTP</tag>
        <tag>TCP/IP</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP请求与响应]]></title>
    <url>%2F2018%2F02%2F21%2FHTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[Server + Client + HTTP 浏览器负责发起请求 服务器在 80 端口接收请求 服务器负责返回内容（响应） 浏览器负责下载响应内容 HTTP 的作用就是指导浏览器和服务器如何进行沟通。资料：菜鸟教程 - 学习HTTP 重点 面试题 请求包括 GET(获取) POST(上传) PUT(整体更新) PATCH(局部更新) DELETE(删除) HEAD OPTIONS等 能够手写http请求，能够手写http响应 Content-Type: application/x-www-form-urlencoded : 应用数据/还没有写入规范的格式-万维网-表单-用urlencode形式压缩 知道状态码的含义:123456789101112200 OK:GET时返回，表示成功201 created:POST时返回，表示创建成功301 Moved Permanently:请求的资源已被永久的移动到新URI302 Found:临时移走了304 未修改Not Modified：所请求的资源未修改，使用缓存的文档404 Not Found ：无法找到这个网页403 Forbidden ：服务器拒绝执行此请求500 Internal Server Error：服务器内部错误，无法完成请求502 Bad Gateway ：充当网关或代理的服务器，从远端服务器接收到了一个无效的请求（比如服务器关了） HTTP请求发起GET请求 命令行执行curl -s -v -- &quot;https://www.baidu.com&quot;请求内容为：1234GET / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.54.0Accept: */* 发起POST请求 命令行执行curl -X POST -s -v -- &quot;https://www.baidu.com&quot;请求内容为：1234POST / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.54.0Accept: */* 发起带data的POST请求 命令行执行curl -X POST -d &quot;1234567890&quot; -s -v -- &quot;https://www.baidu.com&quot;请求内容为: 12345678POST / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.54.0Accept: */*Content-Length: 10Content-Type: application/x-www-form-urlencoded1234567890 请求的格式1234567891 动词 路径 协议/版本2 Key1: value12 Key2: value22 Key3: value32 Content-Type: application/x-www-form-urlencoded2 Host: www.baidu.com2 User-Agent: curl/7.54.03 4 要上传的数据 请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空） 第三部分永远都是一个回车（\n，作为第2部分与第4部分的分界线 动词有 GET POST PUT PATCH DELETE HEAD OPTIONS 等 这里的路径包括「查询参数」，但不包括「锚点」比如GET /s?wd=javascript HTTP/1.1 如果你没有写路径，那么路径默认为 / :GET / HTTP/1.1 第 2 部分中的 Content-Type 标注了第 4 部分的格式 用 Chrome 发请求 打开 Network 地址栏输入网址 在 Network 点击，查看Headers里的 Request Headers，点击「view source」就可以看到请求内容 如果是POST请求，要点Preserve log防止刷新页面后丢失，此时就有第四部分，那么在 FormData 或 Payload 里面可以看到 响应上面三个请求示例，前两个请求对应的响应分别为 对GET的响应用GET请求百度首页后的响应：123456789101112131415HTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: Keep-AliveContent-Length: 2443Content-Type: text/htmlDate: Tue, 10 Oct 2017 09:14:05 GMTEtag: &quot;5886041d-98b&quot;Last-Modified: Mon, 23 Jan 2017 13:24:45 GMTPragma: no-cacheServer: bfe/1.0.8.18Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; 后面太长，省略了…… 对POST的响应用POST请求百度首页后的响应：1234567891011HTTP/1.1 302 FoundConnection: Keep-AliveContent-Length: 17931Content-Type: text/htmlDate: Tue, 10 Oct 2017 09:19:47 GMTEtag: &quot;54d9749e-460b&quot;Server: bfe/1.0.8.18&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; 后面太长，省略了…… GET 请求和 POST 请求对应的响应可以一样，也可以不一样 响应的第四部分可以很长很长很长 响应的格式12345671 协议/版本号 状态码 状态解释2 Key1: value12 Key2: value22 Content-Length: 179312 Content-Type: text/html34 要下载的内容 状态码要背，是服务器对浏览器说的话 123451xx 不常用2xx 表示成功3xx 表示重定向4xx 表示你丫错了（客户端错误）5xx 表示好吧，我错了（服务端错误） 状态解释没什么用 第 2 部分中的 Content-Type 标注了第 4 部分的格式 第 2 部分中的 Content-Type 遵循 MIME 规范 用 Chrome 查看响应 打开 Network 输入网址 选择Headers 查看 Response Headers，点击「view source」 你会看到响应的前两部分 查看 Response 或者 Preview，你会看到响应的第 4 部分 总结http请求与响应的格式12345678910111213141516171819202122232425262728293031323334GET 请求 GET / HTTP/1.1 //GET /?w=xxx HTTP/1.1 查询参数为?w=xxxHost: baidu.comAccept: text/html //请求html格式的文件响应HTTP/1.1 200 OKContent-Type: text/html; charset=utf-8 //响应给我html文件Content-Length: 10000&lt;!DOCTYPE&gt; //html格式的文件&lt;html&gt;......&lt;/html&gt;--------------------------POST 请求POST /login?w=xxx HTTP/1.1Host: baidu.comAccept: application/json //请求一个json格式的页面Content-Type: application/x-www-form-urlencodedContent-Length: 10username=fangfang&amp;password=mima响应HTTP/1.1 403 ForbiddenContent-Type: application/json //返回json格式Content-Length: 200&#123;&quot;erroc&quot;:&quot;错误&quot;&#125; //返回json文件 比喻版12345678910111213工资请求GET 11月工资 工资协议/1.1Host: 百度公司Accept: 现金 (or 支付宝转账, or 银行汇款)工资响应工资协议/1.1 200 OK类型: 现金现金张数: 1010000]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>HTTP</tag>
        <tag>请求与响应</tag>
        <tag>状态码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脚本的简单运用]]></title>
    <url>%2F2018%2F02%2F20%2F%E8%84%9A%E6%9C%AC%E7%9A%84%E7%AE%80%E5%8D%95%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[写脚本Bash脚本、Node.js脚本node.js中文文档：http://nodejs.cn/api/ 写一个脚本 找个地方（比如local）新建文件.sh123mkdir ~/localcd ~/localtouch demo.sh 打开并往 demo.sh 里添加以下内容： 12345mkdir demo cd demo mkdir css js touch index.html css/style.css js/main.js exit 运行脚本在任意位置执行 sh ~/local/demo.sh 即可运行此脚本 12cd ~/Desktopsh ~/local/demo.sh 然后你会看到当前目录里多出一个 demo 目录，demo 目录里面还有一些文件 依次运行cd demo,然后在cmd模式下运行tree /f 好了，这个 demo.sh 就是你写出的第一个 Bash 脚本了。 path将 ~/local 添加到 PATH 里 cd ~/local; pwd 得到 local 的绝对路径 创建 ~/.bashrc：touch ~/.bashrc 编辑 ~/.bashrc：start ~/.bashrc，在最后一行添加 export PATH=”local的绝对路径:$PATH” 执行source ~/.bashrc 使其生效 之前你要运行 sh ~/local/demo.sh，现在你只需要运行 demo.sh ，不需要添加路径了 demo.txt 的后缀 .txt 很无聊，删掉它mv ~/local/demo.txt ~/local/demo现在你只要运行 demo 就能执行该脚本了。 细节 文件后缀的作用：毫无作用 PATH 的作用你每次在 Bash 里面输入一个命令时（比如 ls、cp、demo），Bash 都会去 PATH 列表里面寻找对应的文件，如果找到了就执行。 使用 type demo 可以看到寻找过程 使用 which demo 可以看到寻找结果 参数demo 脚本只能创建名字为 demo 的目录，太无聊了，我们让目录名是可变的吧。$1是第一个参数、$2是第二个参数、$3、$4……..12345mkdir $1cd $1mkdir css jstouch index.html css/style.css js/main.jsexit 此时在相应的文件夹里运行demo 参数，比如demo hello 就会在这个文件夹内生成一个名为hello的目录，里面有一些文件 完善版判断是否存在和$1同名的文件夹打开并编辑demo文件123456789101112if [ -d $1 ]; then echo &apos;error: dir exists&apos; exit 0else mkdir $1 cd $1 mkdir css js echo -e &quot;&lt;!DOCTYPE&gt;\n&lt;title&gt;Hello&lt;/title&gt;\n&lt;h1&gt;Hi&lt;/h1&gt;\n&quot; &gt; index.html touch css/style.css js/main.js echo &apos;success&apos; exit 1fi echo -e &quot;abc\ndef&quot; 输出：12abcdef -e表示启用解释反斜杠转义 exit 0 表示没有错误 exit 1 表示错误代码为 1 命令1 &amp;&amp; 命令2 ：命令1执行成功后才会执行命令2 命令1 || 命令2 ：命令1执行失败时，执行命令2 命令1 ; 命令2 : 命令1执行完后，执行命令2 Node.js 写脚本我们在 Bash 命令行里输入 Bash 命令，也可以在 Node.js 命令行里输入 JS 命令（Ctrl + D 退出）Bash 脚本能做的事情，JS 脚本也能做。(sh demo.sh 对应 node demo.js） Node.js命令node 进入node模式 切换目录 console.log(process.cwd()) : 显示当前目录路径，等同于bash里的pwd process.chdir(&quot;/Users/frank/Desktop&quot;) 进入相应的目录，等同于bash里的cd ~/Desktop console.log(1) ：等同于bash里的echo 1 创建目录12let fs = require(&quot;fs&quot;)fs.mkdirSync(&quot;目录名&quot;) 创建文件12let fs = require(&apos;fs&apos;)fs.writeFileSync(&quot;./index.html&quot;, &quot;内容&quot;) .表示当前文件夹 用 JS 脚本来重写 demo.sh 在bash模式下，执行cd ~/local进入目录 touch jsdemo : 创建js脚本 打开jsdemo文件，编辑它内容如下 123456789101112131415var fs = require(&apos;fs&apos;) var dirName = process.argv[2] // 你传的参数是从第 2 个开始的 process.chdir(&quot;/Users/stage/desktop/test&quot;) // cd ~/Desktop/tset fs.mkdirSync(&quot;./&quot; + dirName) // mkdir $1 process.chdir(&quot;./&quot; + dirName) // cd $1 fs.mkdirSync(&apos;css&apos;) // mkdir css fs.mkdirSync(&apos;js&apos;) // mkdir js fs.writeFileSync(&quot;index.html&quot;, &quot;&quot;) fs.writeFileSync(&quot;css/style.css&quot;, &quot;&quot;) fs.writeFileSync(&quot;js/main.js&quot;, &quot;&quot;) process.exit(0) 退出node模式 cd ~/Desktop/目录名 进入需要执行node命令的目录 node ~/local/jsdemo 参数 ：比如node ~/local/jsdemo testFile shebang的作用我们每次执行 ~/local/jsdemo 参数 都要在最前面添加 node 来执行，能不能做到不加 node也能执行呢（也就是指定执行环境），可以，在 jsdemo 里第一行加上这一句即可：#!/usr/bin/env node ：指定这个文件用node模式来执行 1234567891011121314151617#!/usr/bin/env nodevar fs = require(&apos;fs&apos;) var dirName = process.argv[2] // 你传的参数是从第 2 个开始的 process.chdir(&quot;/Users/stage/desktop/test&quot;) // cd ~/Desktop/tset fs.mkdirSync(&quot;./&quot; + dirName) // mkdir $1 process.chdir(&quot;./&quot; + dirName) // cd $1 fs.mkdirSync(&apos;css&apos;) // mkdir css fs.mkdirSync(&apos;js&apos;) // mkdir js fs.writeFileSync(&quot;index.html&quot;, &quot;&quot;) fs.writeFileSync(&quot;css/style.css&quot;, &quot;&quot;) fs.writeFileSync(&quot;js/main.js&quot;, &quot;&quot;) process.exit(0) 然后你就可以直接用 ~/local/jsdemo.js 参数 了（省得输入 node 了） 如果你已经把 ~/local 加入了 PATH，那么甚至可以直接输入 jsdemo 参数 来执行]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用的步骤与流程]]></title>
    <url>%2F2018%2F02%2F18%2Fgit%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AD%A5%E9%AA%A4%E4%B8%8E%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[git的使用，包括add、commit、打标签、创建以及合并分支、push到远程仓库 git常用命令init → 修改文件 → add → commit git的三种状态：modified修改文件 → add到暂存区 → commit造一颗后悔药 git config -l : 查看配置 git --version : 查看版本号 在文件夹右键选择Git Bash Here，如何运行git init: 创建仓库 git init file2 :创建一个文件夹file2并同时创建仓库 git clone xxxxxxx : 将github上的xxxxx clone到本地，文件夹名为此项目的repository名字 git clone xxxxxx test3 ：将xxxxx clone into 文件夹test3内，文件夹名就是test3 git status -sb : 查看文件状态。红色??表示该文件还没add过。绿色A表示add过但没commit了 git add . : 将所有修改添加至暂存区。然后运行git status -sb查看此时的状态。绿色A表示add过但没commit了 git commit -m &quot;描述&quot; ：造一颗后悔药 建议使用git commit -v来造后悔药git commit -v可进行多行描述，首行为title，次行开始description。比如首行“做了一些更新”，次行“详细更新了xxxx和xxxx以及xxxx” 组合技 git add . &amp;&amp; git commit -m &quot;描述&quot; ：将add和commit组合使用 git log : 查看后悔药的id（commit后面的代码），按↑ ↓键查看，按 Q 退出 12345commit f0d95058cd32a332b98967f6c0a701c64a00810a Author: xxxxxx &lt;xxxxxxxx@gmail.com&gt; Date: Thu Sep 28 22:30:43 2017 +0800 完成第一章 git log -p : 查看具体增删了哪些内容 git log --oneline : 在一行简要显示历史节点 git log --all --oneline ： 可以看到master和所有分支上的历史记录 git log --all --graph : 图示全部分支历史记录 git checkout 后悔药的id ：吃一颗后悔药~~ git checkout - : 回退到上一个历史节点 打tag git tag -a 标签名 -m &quot;描述&quot; ：打tag(如果项目比较大，有上百个commit时，给几个重要的后悔药打上tag方便查找，省去了拷贝后悔药id代码) git log --oneline: git tag -a 标签名 -m &quot;描述&quot; 后悔药的id ：给某个历史节点打标签 git tag : 列出所有tag git show 标签名 ：git show v1 查看v1的具体详情（记得↑ ↓翻页） git checkout 标签名 ：吃一颗后悔药~ 比如git checkout v1(省去了拷贝后悔药id代码) 分支branch假设在开发V3版时，发些V2版存在一些bug，那么可以在V2版上创建分支用来修复V2的bug，然后与后期的版本合并 git branch 分支名 ：在master主干上创建分支 git checkout 分支名 ：进入分支 组合技 git checkout -b 分支名 ：创建并进入这个分支 在3 not rich commit造完后悔药后，创建一个rich的分支并进入git branch rich &amp;&amp; git checkout rich 此时就是在rich分支上操作了，修改not rich为rich，然后add → commit git checkout master : 回到master分支 git log --all --oneline ： 可以看到master和所有分支上的历史记录 git log --all --graph : 图示全部分支历史记录 git merge 分支名 ：合并分支,合并完之后再次add和commit 上传到远程仓库github视频教程 ： 点我 git remote add origin git@github.com:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx/git-demo-1.git ：将本地仓库上传至远程仓库 git pull : 把远程仓库中最新的更改拖下来，然后在此基础上编辑文件，完成后add和commit git push -u origin master ：上传到远程仓库 clear 或者 Ctrl + L :清屏]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令以及偷懒小技巧]]></title>
    <url>%2F2018%2F02%2F17%2Fgit%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%81%B7%E6%87%92%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[本文简单介绍了git与github的配置，以及如何将本地仓库与github连接起来。还介绍了git常用的一些命令，以及如何简化git命令 参考资料: 饥人谷 配置 GitHub (SSH Key) 进入 https://github.com/settings/keys 如果页面里已经有一些 key，就点「delete」按钮把这些 key 全删掉。如果没有，就往下看 点击 New SSH key，你需要输入 Title 和 Key，但是你现在没有 key，往下看 打开 Git Bash 按照 https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/ 的教程 运行 ssh-keygen -t rsa -b 4096 -C &quot;你的邮箱&quot;，注意填写你的邮箱！ 按回车三次 运行 ll ~/.ssh,可以看到生成了id_rsa(钥匙)和id_rsa.pub(锁) 运行 cat ~/.ssh/id_rsa.pub，得到一串东西，完整的复制这串东西 回到上面第 3 步的页面，在 Title 输入「win7上的ssh」 在 Key 里粘贴刚刚你你复制的那串东西 点击 Add SSH key 回到 Git Bash 运行 ssh -T git@github.com，用你电脑上的钥匙打开上传到github的锁，你可能会看到这样的提示：输入 yes 回车 然后如果你看到 Permission denied (publickey). 就说明你失败了，请回到第 1 步重来，是的，回到第 1 步重来；如果你看到 Hi FrankFang! You’ve successfully authenticated, but GitHub does not provide shell access. 就说明你成功了！ 一台电脑只需要一个 SSH key 一个 SSH key 可以访问你的所有仓库，即使你有 1000000 个仓库，都没问题 如果你新买了电脑，就在新电脑上重新生成一个 SSH key，把这个 key 也上传到 GitHub，它可以和之前的 key 共存在 GitHub 上 如果你把 key 从电脑上删除了，重新生成一个 key 即可，替换之前的 key Git的配置与使用配置Gitgit --version :查看当前git版本号 12345git config --global user.name 你的英文名git config --global user.email 你的邮箱git config --global push.default matchinggit config --global core.quotepath falsegit config --global core.editor &quot;vim&quot; 五句话，依次运行。不执行的话，电脑可能会爆炸你信不信。 git config -l : 查看配置 只在本地使用Git步骤 创建目录作为我们的项目目录：mkdir git-demo-1 进入目录 cd git-demo-1 git init，初始化这句命令会在 git-demo-1 里创建一个 .git 目录 ls -la 你就会看到 .git 目录，它就是一个「仓库」，不要进去看，这仓库里面有毒，别进去！ 在 git-demo-1 目录里面添加任意文件，假设我们添加了两个文件，分别是 index.html 和 css/style.css 123touch index.htmlmkdir csstouch css/style.css 运行 git status -sb查看文件状态， 可以看到文件前面有 ?? 号 123## Initial commit on master?? css/?? index.html 这个 ?? 表示 git 一脸懵逼，不知道你要怎么对待这些变动。 使用 git add 将文件添加到「暂存区」你可以一个一个地 add12git add index.htmlgit add css/style.css 你也可以一次性 addgit add . 意思是把当前目录（.表示当前目录）里面的变动都加到「暂存区」 再次运行 git status -sb，可以看到 ?? 变成了 A123## Initial commit on masterA css/style.cssA index.html A 的意思就是添加，也就是说你告诉 git，这些文件我要加到仓库里 使用 git commit -m &quot;信息&quot;将你 add 过的内容「正式提交」到本地仓库（.git就是本地仓库），并添加一些注释信息，方便日后查阅你可以一个一个地 commit12git commit index.html -m &apos;添加index.html&apos;git commit css/style.css -m &quot;添加 css/style.css&quot; 你也可以一次性 commitgit commit . -m &quot;添加了几个文件&quot; 建议使用git commit -v来提交git commit -v可进行多行描述，首行为title，次行开始description。比如首行“做了一些更新”，次行“详细更新了xxxx和xxxx以及xxxx” 再再次运行 git status -sb，发现没有文件变动了，这是因为文件的变动已经记录在仓库里了。 这时你使用 git log 就可以看到历史上文件的变动：12345commit f0d95058cd32a332b98967f6c0a701c64a00810aAuthor: xxxxxx &lt;xxxxxxxx@gmail.com&gt;Date: Thu Sep 28 22:30:43 2017 +0800 添加几个文件 按↑ ↓键查看，按 Q 退出 运行history可以看到历史上输入过的命令 运行start css/style.css 会使用默认的编辑器编辑style.css，保存 运行git status -sb,可以看到style.css前面一个红色的M(Modified)，代表文件有过变动但未add到仓库 12## masterM css/style.css 运行git add style.css,可以看到红色的M变成了绿色的M，表示变动过的文件将添加到「暂存区」 运行git commit -m &quot;改动style.css&quot;这个改动就被提交到 .git 本地仓库了 再再次运行 git status -sb，会发现没有变更了，这说明所有变动都被本地仓库记录在案了。 删除文件rm style.css 运行git add style.css，将删除结果add到仓库 git status -sb，会发现前面有个绿色的D(Delete) 运行git commit -m &quot;删除style.css&quot; 总结 git init，初始化本地仓库 .git git status -sb，显示当前所有文件的状态 git add 文件路径，用来将变动加到暂存区 git commit -m &quot;信息&quot;，用来正式提交变动，提交至 .git 仓库 如果有新的变动，我们只需要依次执行 git add xxx 和 git commit -m &#39;xxx&#39; 两个命令即可。别看本教程废话那么多，其实就这一句有用！先 add 再 commit，行了，你学会 git 了。 git log 查看变更历史 将本地仓库上传到 GitHub如何将我们这个 git-demo-1 上传到 GitHub 呢？ 步骤 在 GitHub 上New一个repository，名称随意，一般跟本地目录名一致按照截图所示，除了仓库名，其他的什么都别改，其他的什么都别改，其他的什么都别改，其他的什么都别改，这样你才能创建一个空仓库 点击创建按钮之后，GitHub 就会把后续的操作全告诉你，如图 看图，点击 SSH 按钮，点击 SSH 按钮，点击 SSH 按钮，我想你现在肯定不会忘了点击 SSH 按钮了吧~~~~如果不点击这个按钮，你就会使用默认的 HTTPS 地址。但是千万不要使用 HTTPS 地址，因为 HTTPS 地址使用起来特别麻烦，每次都要输入密码，而 SSH 不用输入用户名密码。为什么 SSH 不用密码呢，因为你已经上传了 SSH public key。还记得吗？如果不记得，翻到本文第一部分「配置 GitHub」章节。 由于我们上之前创建过本地仓库了，所以看图，图中下面半部分就是你需要的命令，我们一行一行拷贝过来执行 4.1 找到图中的「…or push an existing repository from the command line」这一行，你会看到 git remote add origin https://github.com/xxxxxxxxxx/git-demo-1.git， 如果你发现这个地址是 https 开头的，那你就做错了，还记得吗，我们要使用 SSH 地址，GitHub 的 SSH 地址是以 git@github.com 开头的。 4.2 再次点击 SSH 按钮，不管我强调多少遍，总会有人忘记点击 SSH 按钮，为什么呢？我也不知道，为了防止你忘了点击 SSH 按钮，我最后再说一遍，「点击 SSH按钮」，点击之后，整个世界就会变得美好起来。 4.3 得到新的命令 git remote add origin git@github.com:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx/git-demo-1.git，复制并运行它 4.4 复制第二行 git push -u origin master，运行它 4.5 刷新当前页面，你的仓库就上传到 GitHub 了！是不是特别简单？只要你按照我说的做，一丝不苟，即可。 直接在 GitHub 创建一个仓库，然后下载到本地步骤 在GitHub 上新建一个仓库 git-demo-2，这次就不创建空仓库了，而是自带 README 和 Lisence 的仓库，创建截图如下：请按图中所示，填写一模一样的内容，然后点击创建按钮。 这样一来，这个仓库就会自动拥有三个文件： 这三个文件的作用请自行了解：.gitignore 的作用、README.md 的作用 以及 LISENCE 的作用 运行git clone 以git@github.com开头的地址运行完了你就会发现，桌面上多出一个 git-demo-2 目录。 cd git-demo-2 进入这个多出来的目录 运行 ls -la 你会看到，远程目录的所有文件都在这里出现了，另外你还看到了 .git 本地仓库。这时你就可以添加文件，git add，然后 git commit 了。 总结 git clone git@github.com:xxxx，下载仓库 git init，初始化本地仓库 .git git status -sb，显示当前所有文件的状态 git add 文件路径，用来将变动加到暂存区 git commit -m “信息”，用来正式提交变动，提交至 .git 仓库 如果有新的变动，我们只需要依次执行 git add xxx 和 git commit -m ‘xxx’ 两个命令即可。别看本教程废话那么多，其实就这一句有用！先 add 再 commit，行了，你学会 git 了。 git log 查看变更历史 如何上传更新你在本地目录有任何变动，只需按照以下顺序就能上传到github：1234git add 文件路径git commit -m &quot;信息&quot;git pull （相信我，你一定会忘记这一个命令）获取远程仓库最新文件git push 下面是例子1234567cd git-demo-1touch index2.htmlgit add index2.htmlgit commit -m &quot;新建 index2.html&quot;git pull退出vim: esc + : + q + !git push 然后你去 git-demo-1 的 GitHub 页面，就能看到 index2.html 出现在里面了。是不是很……简……单……呢…… 其他Git命令 git remote add origin git@github.com:xxxxxxx.git 将本地仓库与远程仓库关联 git remote set-url origin git@github.com:xxxxx.git 上一步手抖了，可以用这个命令来挽回 git branch 新建分支 git merge 合并分支 git stash 通灵术 git stash pop 反转通灵术 git revert 后悔了 git reset 另一种后悔了 git diff 查看详细变化 git操作偷懒技巧通过~/.bashrc 文件可以简化git操作 自动运行 首先 touch ~/.bashrc 创建一下这个文件 start ~/.bashrc 选用编辑器编辑这个文件，内容为 echo &#39;Hi&#39; 你也可以用命令行编辑文件 echo &quot;echo &#39;hi&#39;&quot; &gt;&gt; ~/.bashrc 关闭退出 Git Bash，然后打开 Git Bash，是不是看到了 Hi，这说明每次进入 Git Bash，就会优先运行 ~/.bashrc 里面的命令 重新编辑 ~/.bashrc，内容改为 cd ~/Desktop，重启 Git Bash，有没有发现默认就进入桌面目录了？ 你可以用 ~/.bashrc 在进入 Git Bash 前执行任何命令，十分方便。 alias(简写) 在 ~/.bashrc 里新增一行 alias f=&quot;echo &#39;frank is awesome&#39;&quot;，等于号两边不能有空格，你最好一个字都不要错。 运行 source ~/.bashrc，作用是执行 ~/.bashrc 运行 f，就会看到 frank is awesome 也就是说，现在 f 就是 echo ‘frank is awesome’ 的缩写了，利用这个技巧，我们可以把很多常见的命令缩写一下，比如1234567alias la=&apos;ls -a&apos;alias ll=&apos;ls -l&apos;alias gst=&apos;git status -sb&apos;alias ga=&apos;git add&apos;alias ga.=&apos;git add .&apos;alias gc=&apos;git commit&apos;alias gc.=&apos;git commit .&apos; 保存退出，然后运行 source ~/.bashrc 这样一来，你的 Git 操作就会简单很多：12345ga 1.txtga .gc 1.txtgc.gst 环境变量还可以在 ~/.bashrc 里面设置一些环境变量，比如你可以在 ~/.bashrc 里面添加一行 export SASS_BINARY_SITE=&quot;https://npm.taobao.org/mirrors/node-sass&quot;那么以后你安装 node-sass 的时候就不会因为被墙而报错了。以后会用到的，现在先说一下。 设置 PATHexport PATH=&quot;目录的绝对路径:$PATH&quot;可以在 PATH 里添加一个目录，不要运行，等用到的时候再来查。 其他命令1 &amp;&amp; 命令2 ：命令1执行成功后才会执行命令2命令1 || 命令2 ：命令1执行失败时，执行命令2命令1 ; 命令2 : 命令1执行完后，执行命令2]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行基础及常用命令]]></title>
    <url>%2F2018%2F02%2F16%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[介绍了命令行的一些基础知识，以及常用的一些命令 参考资料: 饥人谷 基本概述~ / . .. $ 的意思 ~/desktop : 其中的 ~ 表示电脑的username，所以这句命令等同于stage/desktop . : 当前目录 .. : 上级目录，cd ..表示进入上级目录常见单词英文翻译directory目录、文件夹file文件make新建remove删除move移动copy复制list罗列link链接find查找echo发出回音、重复touch触摸change改变 单词缩写命令全写缩写创建目录make directorymkdir删除removerm移动 / 重命名movemv复制copycp罗列listls改变目录change directorycd， windows下用cd %userprofile%\desktop进入桌面 缩写规则就是：删掉元音字幕（A E I O U），保留前 2 到 3 个辅音字母 基础命令 cd ~/Desktop 进入桌面 mkdir demo-1 创建目录，这时你可以切到桌面，看到 demo-1 目录 rm -rf demo-1 删除目录【-r表示递归，循环删除直至删光，-f表示强制，不提示yes/no】 touch 1.txt 创建文件 mv 1.txt 2.txt 这样我们就把 1.txt 移到 2.txt 了，也就是重命名 Linux常用命令(重点！！！)操作命令进入目录cd显示当前目录的详细路径pwd创建目录mkdir 目录名创建特殊名字的目录(比如带空格的文件名)mkdir “目 录名” : mkdir &quot;file 1&quot;创建多个目录mkdir 目录名1 目录名2 :mkdir file1 file2 file3创建深层次目录mkdir -p 目录路径：举个栗子 mkdir -p file1/file2/file3我是谁,显示用户名whoami清屏clear 或者 Ctrl + L––显示文件夹里的内容ls 文件夹路径 : ls显示当前文件夹里的内容，查看指定路径文件夹里的内容ls file1/file2查看文件夹里的所有内容，包括隐藏的ls -a 文件夹路径显示文件夹详细信息ls -l 文件夹路径 ： drwxr表示directory(d开头表示目录，-开头表示非目录)、read可读、write可写、x可运行显示详细信息，包括隐藏的文件ls -la 文件夹路径––创建文件echo ‘1’ &gt; 文件路径 ：echo &#39;xxx&#39; &gt; 1.txt追加文件内容echo ‘1’ &gt;&gt; 文件路径创建文件touch 文件名改变文件更新时间touch 文件名––复制文件cp 源路径 目标路径 : cp 1.txt 2.txt将1.txt里的内容复制到2.txt复制目录cp -r 源路径 目标路径 ： cp -r file1 file2––重命名文件名mv 原文件名 修改后的文件名 : mv 1.txt 2.txt––删除文件rm 文件路径 : rm 1.txt强制删除文件rm -f 文件路径删除目录rm -r 目录路径强制删除目录rm -rf 目录路径––【windows不支持】查看当前目录结构tree【windows不支持】建立软链接，相当于创建一个双胞胎目录ln -s 真实文件 双胞胎文件 ：ln -s demo demo-copy––下载文件curl -L https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js &gt; jq.js【将jq源码下载下来并保存到jq.js】拷贝网页wget -p -H -e robots=off https://www.baidu.com磁盘占用df -kh当前目录大小du -sh .各文件大小du -h]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行的安装和配置方法]]></title>
    <url>%2F2018%2F02%2F15%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[归纳总结了下 git、git bash、node、npm 的安装和配置方法. 参考资料: 饥人谷 本文参考 饥人谷 的文章后整理归纳了一下，主要包括git、git bash、node、npm的使用和配置方法。 Git Bash的使用第一种使用方式找一个目录，在目录上右键点击，然后选中「Git Bash Here」，即可用 Git Bash 打开这个目录。试试输入 touch 1.txt，回车后可以看到目录里多了一个touch 1.txt文件。 第二种使用方式直接打开 Git Bash，输入 cd ~/Desktop 即可来到桌面所在的目录。试试输入 touch 1.txt，回车后看看桌面上是不是多了一个文件。 Linux常用命令新建文件夹：mkdir my-dir 删除文件夹：rm -rf my-dir 创建文件：echo &quot;hello&quot; &gt; newFile.txt 创建空内容文件: touch file.txt 重命名: mv 1.txt 2.txt ,将1.txt重命名为2.txt 删除文件：rm newFile.txt 进入文件夹: cd my-dir 运行文件: start file.txt 显示文件夹内所有的文件: ls 清屏: clear 中断/退出模式: ctrl + C 关闭git bash: ctrl + D 或者输入 exit 进入node模式: node 进入npm模式: npm Node.js的使用从官网下载node.js 使用第一种使用方法 进入 Git Bash 输入 node，回车，就可以进入 node 运行环境，这个时候我们就可以写 JS 了 试试写最简单的 JS 语句，比如 1+2，回车 2 * 8，回车 node的另一种使用方法我们可以先创建一个 JS 文件，然后让 node 运行 来到桌面：cd ~/Desktop 新建一个目录用来玩耍：mkdir hello-node 进入这个目录：cd hello-node 新建一个有内容的 JS 文件：echo &quot;console.log(&#39;Hi, Node.js&#39;)&quot; &gt; main.js，那么 main.js 就新建成功了 输入 node main.js，回车，node 就会执行这个 main.js 文件，你会看到「Hi, Node.js」字样 玩完了，删除 hello-node：cd .. ; rm -rf hello-node npm的配置和使用配置打开 Git Bash，依次输入以下命令，按回车：1234npm config set registry https://registry.npm.taobao.org/npm config set loglevel httpnpm config set progress falsenpm config set strict-ssl false npm 的配置被存储在 ~/.npmrc，你可以随时改。 npm的使用我们可以用 npm 的翻译工具做一个随时可用的小字典，这个小工具的名字叫做 fanyi。 打开Git Bash，运行 npm i -g fanyi 即可安装 fanyi，安装完成之后，输入 fanyi frontend 就可以看到对应的中文释义了！ 是不是很帅呢？！ Git的配置和使用配置请在命令行运行这五句话！！！一定要运行这五句话，不然 git 就不能用了12345git config --global user.name xxx #方便产品经理找（怼）你git config --global user.email yyy #方便产品经理找（怼）你git config --global push.default simple # 本来我写的是 matching，不过想了想可能 simple 更好git config --global core.quotepath false #防止文件名变成数字git config --global core.editor &quot;vim&quot; # 使用vim编辑提交信息 git config -l : 查看配置信息 这样就可以愉快地使用git了~ ##Git的使用使用 在本地新建一个文件夹 test ，在文件夹上右键点击，然后选中「Git Bash Here」 在github上新建一个仓库New repository 在已经打开的Git Bash内输入123456echo &quot;# test&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://github.com/harry0071/test.gitgit push -u origin master 最后一段代码 git push -u origin master 回车后会询问 yes/no ,输入yes此时如果报错的话，需要SSH Key解决办法： 进入github的 Settings &gt;&gt;&gt; 点击右侧的 SSH and GPG keys &gt;&gt;&gt; 点击New SSH key &gt;&gt;&gt; 进入 https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/ 按照网页提示在Git Bash内输入:ssh-keygen -t rsa -b 4096 -C &quot;改成自己的邮箱@example.com&quot; ，接着按3次回车，直至出现冒泡泡的画面 将生成的SSH key cat下来: cat ~/.ssh/id_rsa.pub 回到第1步将生成的SSH key粘贴进去 重新运行`git push -u origin master 常用命令git init: 把用Git Bash打开的本地文件夹变成Git可以管理的仓库git add 1.txt 2.txt: 将文件提交至暂存区,可以一次添加多个文件git add .: 将文件夹内的所有文件添加到暂存区git commit -m &quot;本次更新内容&quot;: 把add的文件一次性打包提交至本地版本库，-m后面输入的是本次更新的说明注释git push origin master: 将本地仓库推送到Github仓库git rm 1.txt: 删除一个文件git checkout -- 1.txt: 把误删的文件恢复到最新版本git rm 1.txt + git commit -m &quot;remove&quot;: 彻底删除文件]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime中如何使用terminal教程]]></title>
    <url>%2F2018%2F02%2F08%2Fsublime%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8terminal%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.安装terminal首先在sublime text3 中安装terminalctrl+shift+P打开package control面板,输入pci进入安装插件列表，输入terminal找到插件安装 2.配置terminalterminal默认调用系统自带的PowerShell，接下来我们改成cmd.exe 安装完成后在工具菜单选择“Preferences(首选项)”–“Package Settings”–“Terminal”–“Settings - User” 在里面输入打开cmd命令窗口的脚本，然后ctr+s保存。12345&#123; &quot;terminal&quot;: &quot;c:\\WINDOWS\\system32\\cmd.exe&quot;, &quot;parameters&quot;: [&quot;/START&quot;,&quot;%CWD%&quot;] &#125; 3.启动terminal现在我们打开sublime，使用ctrl+shift+t就可以打开cmd命令窗口了 4.更多关于terminal详情关于sublime的terminal插件的更多安装及配置方法:百度经验Github]]></content>
      <categories>
        <category>sublime</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漂亮的弹窗插件 —— SweetAlert教程]]></title>
    <url>%2F2018%2F02%2F08%2Fsweetalert%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[SweetAlert可以替代JavaScript原生的alert和confirm等函数呈现的弹出提示框，它将提示框进行了美化，并且允许自定义，支持设置提示框标题、提示类型、内容展示图片、确认取消按钮文本、点击后回调函数等。官方网站: https://sweetalert.js.org/Github: https://github.com/t4t5/sweetalert中文教程站: http://mishengqiang.com/sweetalert/ 使用方法1.引入(我用的CDN引入)12&lt;link href="https://cdn.bootcss.com/sweetalert/1.1.3/sweetalert.min.css" rel="stylesheet"&gt;&lt;script src="https://cdn.bootcss.com/sweetalert/1.1.3/sweetalert.min.js"&gt;&lt;/script&gt; 2.使用简称函数swal调用sweetAlert123456789101112swal(&#123; title: "确定删除吗？", text: "你将无法恢复该虚拟文件！", type: "warning", showCancelButton: true, confirmButtonColor: "#DD6B55", confirmButtonText: "确定删除！", closeOnConfirm: false&#125;,function()&#123; swal("删除！", "你的虚拟文件已经被删除。", "success"); &#125;); 3.举个栗子 html代码 1234567891011121314151617181.基本信息：&lt;button id="demo1"&gt;试一试&lt;/button&gt; &lt;br /&gt;2.带有文字的标题：&lt;button id="demo2"&gt;试一试&lt;/button&gt; &lt;br /&gt;3.成功提示：&lt;button id="demo3"&gt;试一试&lt;/button&gt; &lt;br /&gt;4.带有“确认”按钮的功能的警告消息：&lt;button id="demo4"&gt;试一试&lt;/button&gt; &lt;br /&gt;5.通过传递参数，您可以执行一些其他的事情比如“取消”。：&lt;button id="demo5"&gt;试一试&lt;/button&gt; &lt;br /&gt;6.一个有自定义图标的消息：&lt;button id="demo6"&gt;试一试&lt;/button&gt; &lt;br /&gt;7.自定义HTML信息：&lt;button id="demo7"&gt;试一试&lt;/button&gt; &lt;br /&gt;2秒后关闭：&lt;button id="demo8"&gt;试一试&lt;/button&gt; &lt;br /&gt;8.更换“提示”功能: &lt;button id="demo9"&gt;试一试&lt;/button&gt; &lt;br /&gt;9.使用加载程序（例如，用于AJAX请求）: &lt;button id="demo10"&gt;试一试&lt;/button&gt; &lt;br /&gt; js代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107document.getElementById("demo1").onclick = function() &#123; swal("这是一个信息提示框!")&#125;;document.getElementById("demo2").onclick = function() &#123; swal("这是一个信息提示框!", "很漂亮，不是吗？")&#125;;document.getElementById("demo3").onclick = function() &#123; swal("干得好", "你点击了按钮!", "success")&#125;;document.getElementById("demo4").onclick = function() &#123; swal(&#123; title: "你确定？", text: "您将无法恢复这个虚构的文件！", type: "warning", showCancelButton: true, confirmButtonColor: "#DD6B55", confirmButtonText: "是的，删除！", closeOnConfirm: false &#125;, function() &#123; swal("删除!", "您的虚构文件已被删除！", "success") &#125;)&#125;;document.getElementById("demo5").onclick = function() &#123; swal(&#123; title: "你确定？", text: "您将无法恢复这个虚构的文件！", type: "warning", showCancelButton: true, confirmButtonColor: "#DD6B55", confirmButtonText: "是的，删除！", cancelButtonText: "不，取消", closeOnConfirm: false, closeOnCancel: false &#125;, function(isConfirm) &#123; if (isConfirm) &#123; swal("删除!", "您的虚构文件已被删除！", "success") &#125; else&#123; swal("取消!", "您的虚构文件是安全的！", "error") &#125; &#125;)&#125;;document.getElementById("demo6").onclick = function() &#123; swal(&#123; title: "Sweet!", text: "这里是自定义图像!", imageUrl: "img/thumbs-up.jpg" &#125;)&#125;;document.getElementById("demo7").onclick = function() &#123; swal(&#123; title: "HTML &lt;small&gt;标题&lt;/small&gt;!", text: "A custom &lt;span style='color:pink'&gt;html&lt;span&gt; message.", html: true &#125;)&#125;;document.getElementById("demo8").onclick = function() &#123; swal(&#123; title: "自动关闭警报!", text: "2秒后自动关闭", timer: 2000, showConfirmButton: false &#125;)&#125;;document.getElementById("demo9").onclick = function() &#123; swal(&#123; title: "请输入！", text: "填写一些信息", type: "input", showCancelButton: true, closeOnConfirm: false, animation: "slide-from-top", inputPlaceholder: "请输入..." &#125;, function(inputValue) &#123; if (inputValue === false) &#123; return false; &#125; if (inputValue === "") &#123; swal.showInputError("内容不能为空！"); return false; &#125; swal("Nice!", "你输入的是：" + inputValue, "success") &#125;)&#125;;document.getElementById("demo10").onclick = function() &#123; swal(&#123; title: "AJAX请求实例", text: "提交运行Ajax请求", type: "info", showCancelButton: true, closeOnConfirm: false, showLoaderOnConfirm: true &#125;, function() &#123; setTimeout(function() &#123; swal("AJAX请求完成！"); &#125;, 2000) &#125;)&#125;; 效果预览 更多详情可以去中文教程站查看更多详情,里面包括了各种配置和方法，以及示例中文教程站: http://mishengqiang.com/sweetalert/]]></content>
      <categories>
        <category>jq</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>教程</tag>
        <tag>jq</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next主题个性化教程:打造炫酷网站]]></title>
    <url>%2F2018%2F02%2F08%2Fhexonext%2F</url>
    <content type="text"><![CDATA[看到有些next主题的网站很炫酷，那么是怎么配置的呢？接下来我会讲一讲如何实现一些炫酷的效果 主要有以下32种： 在右上角或者左上角实现fork me on github添加RSS添加动态背景实现点击出现桃心效果修改文章内链接文本样式修改文章底部的那个带#号的标签在每篇文章末尾统一添加“本文结束”标记修改作者头像并旋转博文压缩修改代码块自定义样式侧边栏社交小图标设置主页文章添加阴影效果在网站底部加上访问量添加热度网站底部字数统计添加 README.md 文件设置网站的图标Favicon实现统计功能添加顶部加载条在文章底部增加版权信息添加网易云跟帖(跟帖关闭，已失效，改为来必力)隐藏网页底部powered By Hexo / 强力驱动修改网页底部的桃心文章加密访问添加jiathis分享博文置顶修改字体大小修改打赏字体不闪动自定义鼠标样式为博客加上萌萌的宠物DaoVoice 在线联系点击爆炸效果 详细配置请参考: https://www.jianshu.com/p/f054333ac9e6]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日期时间控件jQuery datetimepicker的使用简介]]></title>
    <url>%2F2018%2F02%2F08%2Fjquerydatetimepicker%2F</url>
    <content type="text"><![CDATA[datetimepicker是一个配置灵活的日期选择插件，你可以定义它的展示方式，包括日期格式、语言、限制选择日期范围、添加相关按钮以及其它导航等 此项目的Github地址：https://github.com/xdan/datetimepicker演示地址: https://xdsoft.net/jqplugins/datetimepicker/ 使用方法1.添加引用添加jquery.js、datetimepicker.js和datetimepicker.css到您的页面123&lt;link href="https://cdn.bootcss.com/jquery-datetimepicker/2.5.17/jquery.datetimepicker.min.css" rel="stylesheet"&gt;&lt;script src="https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/jquery-datetimepicker/2.5.17/jquery.datetimepicker.full.min.js"&gt;&lt;/script&gt; 2.创建input元素1&lt;input id="datetimepicker" type="text" &gt; 3.设置成中文1$.datetimepicker.setLocale('zh'); 4.启用插件1$('#datetimepicker').datetimepicker(); 按以上步骤我们就实现jquery datetimepicker的使用，当然这只是最基本的样式，另外jquery datetimepicker的样式控制是通过传一个json对象的参数给datetimepicker来实现的。下面我们举个例子来看下：1$("#start").datetimepicker(&#123; format: 'Y/m/d', timepicker: false &#125;); 上面传入的参数设置只显示年月日，以及弹出层只能选择日期，而不能选择时间。 那我们接下来总结一下它常用的一些参数及其作用。 详细配置参数关于详细配置参数参考：https://xdsoft.net/jqplugins/datetimepicker/12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455$('#datetimepicker').datetimepicker(&#123; value: '' // 设置当前datetimepicker的值 rtl: false, // false 默认显示方式 true timepicker和datepicker位置变换 format: 'Y/m/d H:i', // 设置时间年月日时分的格式 如: 2016/11/15 18:00 formatTime: 'H:i', // 设置时间时分的格式 formatDate: 'Y/m/d', // 设置时间年月日的格式 startDate: false, // new Date(), '1986/12/08', '-1970/01/05','-1970/01/05', step: 10, // 设置时间时分的间隔 closeOnDateSelect: false, // true 设置datepicker可点击 false 设置datepicker不可点击 实际上可以双击 closeOnTimeSelect: true, // true 设置timepicker可点击 false 设置timepicker不可点击 closeOnWithoutClick: true, // true 设置点击input可以隐藏datetimepicker false 设置点击input不可以隐藏datetimepicker closeOnInputClick: true, // true 设置点击input可以隐藏datetimepicker false 设置点击input不可以隐藏datetimepicker (会有闪动 先隐藏 再显示) timepicker: true, // true 显示timepicker false 隐藏timepicker datepicker: true, // true 显示datepicker false 隐藏datepicker weeks: false, // true 显示周数 false 隐藏周数 defaultTime: false, // 如果输入值为空 可用来设置默认显示时间 use formatTime format (ex. '10:00' for formatTime: 'H:i') defaultDate: false, // 如果输入值为空 可用来设置默认显示日期 use formatDate format (ex new Date() or '1986/12/08' or '-1970/01/05' or '-1970/01/05') minDate: false, // 设置datepicker最小的限制日期 如：2016/08/15 maxDate: false, // 设置datepicker最大的限制日期 如：2016/11/15 minTime: false, // 设置timepicker最小的限制时间 如：08:00 maxTime: false, // 设置timepicker最大的限制时间 如：18:00 allowTimes: [], // 设置timepicker显示的时间 如：allowTimes:['09:00','11:00','12:00','21:00'] opened: false, // false默认打开datetimepicker可关闭 true打开datetimepicker后不可关闭 initTime: true, // 设置timepicker默认时间 如：08:00 inline: false, // ture设置datetimepicker一直显示 theme: '', // ture设置datetimepicker显示样式 如: 'dark' withoutCopyright: true, // ture默认隐藏左下角'xdsoft.net'链接 false 显示左下角'xdsoft.net'链接 inverseButton: false, // false 默认 true datepicker的上一月和下一月功能互换 timepicker的上下可点击按钮功能互换 hours12: false, // true设置12小时格式 false设置24小时格式 next: 'xdsoft_next', // 设置datepicker上一月按钮的样式 prev : 'xdsoft_prev', // 设置datepicker下一月按钮的样式 dayOfWeekStart: 0, // 设置默认第-列为周几 如：0 周日 1 周一 parentID: 'body', // 设置父级选择器 timeHeightInTimePicker: 25, // 设置timepicker的行高 timepickerScrollbar: true, // ture设置timepicker显示滑动条 false设置timepicker不显示滑动条 todayButton: true, // ture显示今天按钮 false不显示今天按钮 位置在datepicker左上角 prevButton: true, // ture显示上一月按钮 false不显示上一月按钮 位置在datepicker左上角 nextButton: true, // ture显示下一月按钮 false不显示下一月按钮 位置在datepicker又上角 scrollMonth: true, // ture 设置datepicker的月份可以滑动 false设置datepicker的月份不可以滑动 lazyInit: false, // 翻译： 初始化插件发生只有当用户交互。大大加速插件与大量的领域的工作 mask: false, // 使用输入掩码。真正的-自动生成一个字段的“格式”的面具，从0到9的数字，设置为值的最高可能的数字。例如：第一个小时的数字不能大于2，而第一位数字不能大于5 如：&#123;mask:'9999/19/39 29:59',format:'Y/m/d H:i'&#125; validateOnBlur: true, // 失去焦点时验证datetime值输入,。如果值是无效的datetime,然后插入当前日期时间值 yearStart: 1950, // 设置最小的年份 yearEnd: 2050, // 设置最大的年份 monthStart: 0, // 设置最小的月份 monthEnd: 11, // 设置最大的月份 roundTime: 'round', // 设置timepicker的计算方式 round四舍五入 ceil向上取整 floor向下取整 allowDateRe : null, // 设置正则表达式检查日期 如：&#123;format:'Y-m-d',allowDateRe:'\d&#123;4&#125;-(03-31|06-30|09-30|12-31)' &#125; disabledDates : [], // 设置不可点击的日期 如：disabledDates: ['21.11.2016','22.11.2016','23.11.2016','24.11.2016','25.11.2016','26.11.2016'] disabledWeekDays: [], // 设置不可点击的星期 如：disabledWeekDays:[0,3,4] yearOffset: 0, // 设置偏移年份 如：2 代表当前年份加2 -2 代表当前年份减2 beforeShowDay: null, // 显示datetimepicker之前可调用的方法 &#123;beforeShowDay:function(d) &#123;console.log("bsd"); &#125; &#125; enterLikeTab: true, // tab按键均可使datetimepicker关闭 true点击回车键可使datetimepicker关闭 false点击回车键不可使datetimepicker关闭 showApplyButton: false // 相当于确定按钮 true显示 false隐藏&#125;); jquery datetimepicker的相关点击方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* * 监听时间插件显示时的事件 */$('#datetimepicker').datetimepicker(&#123; onShow: function(dateText, inst) &#123; console.log("---已打开datetimepicker----"); &#125;&#125;); /* * 监听时间插件关闭时的事件 */$('#datetimepicker').datetimepicker(&#123; onClose: function(dateText, inst) &#123; console.log("---已关闭datetimepicker----"); &#125;&#125;); /* * 监听点击日期时的事件 */ $('#datetimepicker').datetimepicker(&#123; onSelectDate: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;); /* * 监听点击时分的事件 */ $('#datetimepicker').datetimepicker(&#123; onSelectTime: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;); /* * 监听点击datepicker 上一月下一月按钮及选择月份点击事件 */$('#datetimepicker').datetimepicker(&#123; onChangeMonth: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;);/* * 监听获取当前datetimepicker显示的所有日期信息 */$('#datetimepicker').datetimepicker(&#123; onGetWeekOfYear: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;); /* * 监听选择年份的点击事件 */$('#datetimepicker').datetimepicker(&#123; onChangeYear: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;); /* * 实时监听你选择的日期和时间 */$('#datetimepicker').datetimepicker(&#123; onChangeDateTime: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;); /* * 实时监听datetimepicker上的所有事件 */$('#datetimepicker').datetimepicker(&#123; onGenerate: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;);]]></content>
      <categories>
        <category>jq</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>教程</tag>
        <tag>jq</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[store.js的使用 -- 本地存储localStorage的封装插件]]></title>
    <url>%2F2018%2F02%2F08%2Fstore%2F</url>
    <content type="text"><![CDATA[本地存储localstoragelocalstorage 是 HTML5 提供的在客户端存储数据的新方法，主要作用是将数据保存在客户端中，并且数据是永久保存的，除非人为干预删除。localstorage 的局限1、只有版本较高的浏览器中才支持 localstorage2、localStorage只能存储字符串，使用 JSON 时需转换3、如果存储内容过多会消耗内存空间，导致页面变卡，因为localStorage本质上是对字符串的读取 store.jsGithub地址 store.js 是一个兼容所有浏览器的 LocalStorage 包装器，不需要借助 Cookie 或者 Flash来实现。它提供非常了简洁的 API 来实现跨浏览器的本地存储功能。使用store,js简化了使用localStorage原生方法的操作。 store.js的使用 首先引入store.min.js插件: 1&lt;script src="https://cdn.bootcss.com/store.js/1.3.20/store.min.js"&gt;&lt;/script&gt; 判断浏览器是否支持本地存储 12345678910&lt;script type="text/javascript"&gt; init(); function init()&#123; if(!store.enabled)&#123; alert("你的浏览器不支持本地存储，请使用更高版本的浏览器"); return; &#125;else&#123; ...... &#125; &lt;/script&gt; 开始愉快地使用store.js吧~store.js的基本API有： 123456store.set(key, val) //存储 key 的值为 val；store.get(key) //获取 key 的值；store.remove(key) //移除 key 的记录；store.clear() //清空存储；store.getAll() //返回所有存储；store.forEach() //遍历所有存储。 使用方法：123456789101112131415161718store.set('username', 'marcus') store.get('username') store.remove('username') store.clear() store.set('user', &#123; name: 'marcus', likes: 'javascript' &#125;) var user = store.get('user') alert(user.name + ' likes ' + user.likes) // Get all stored values store.getAll().user.name == 'marcus' // Loop over all stored values store.forEach(function(key, val) &#123; console.log(key, '==', val) &#125;) set 单个存储字符格式：store.set(key, data[, overwrite]);123456789101112131415161718192021store.set('name','mavis'); //存储name的值为 mavisstore.set('name','angel'); //将name的值存储为angel例如：store.set('容器1', json)``` 在控制台显示 ![](https://sfault-image.b0.upaiyun.com/282/193/2821938934-5831460c5a712) ---- get 获取存入的key值 格式：`store.get(key[, alt]);` get获取时，有时需要判断是否存在localStorage```javascriptstore.set('name','mavis');store.set('name','angel');store.get('name'); //angel例如：var json = &#123;1:1,2:2,3:3,4:4&#125;;store.set('容器1', json)store.get('容器1');//&#123;1:1,2:2,3:3,4:4&#125; remove 移除key的记录1store.remove('name'); 在控制台可以看到name的值已经被移除 store.clear(); 清空所有本地存储 getAll 从所有存储中获取值格式：store.getAll() 12store.set('name','mavis');store.getAll().user.name == 'mavis'; //true forEach 遍历所有的值 12345store.set('user',&#123;name:'mavis',likes:'javascript'&#125;); // 存储对象 - 自动调用 JSON.stringifyvar user = store.get('user'); // 获取存储的对象 - 自动执行 JSON.parsestore.forEach(function(key, val) &#123; console.log(key, '==', val) &#125;) // 遍历所有存储 store.has(key)``javascriptconsole( store.has(‘容器1’) );//trueconsole( store.has(‘容器2’) );//false``` 在浏览器中查看LocalStorage的方法F12打开开发人员工具→Application→Storage→LocalStorage]]></content>
      <categories>
        <category>jq</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>教程</tag>
        <tag>jq</tag>
        <tag>插件</tag>
      </tags>
  </entry>
</search>
