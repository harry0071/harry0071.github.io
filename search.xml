<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[🔒 JQuery版云音乐]]></title>
    <url>%2F2018%2F04%2F17%2Fjquery%E7%89%88%E4%BA%91%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[云音乐需求分析利用LeanCloud用来存取数据利用七牛云存储保存静态文件(图片、mp3、视频、js文件、css文件) 需求分析用例图use-cases用户能够： 查看首页 歌曲列表页 评论 播放页 播放 暂停 歌词 搜歌 按歌名搜 按歌手搜 后台能够： 登录 注册 忘记密码 上传歌曲 拖拽上传 编辑歌曲 删除 线框图Sketchxiaopiu:网易云音乐原型图 架构图 LeanCloud的使用LeanCloud只能用来存数据/字符串，无法存文件(比如mp3、视频等)ACL(Access Control Layer)访问控制层：控制可读/可写SDK(api套件)：给你一堆api 用LeanCloud创建数据库 登录LeanCloud 创建应用(等同于创建了个数据库) 点开，选择创建Class,User用来存管理员信息，Song用来存歌曲信息，Playlist用来存歌单信息 使用 npm 的包管理工具安装 SDK12 # 存储服务（包括推送和统计）$ npm install leancloud-storage --save Git Bash创建本地仓库git --version：查看git Bash 版本号ll -a:罗列当前目录下的文件，包括隐藏的tree:展开当前目录下所有文件cd ..:返回上一级目录 新建一个目录，mkdir src文件夹放初始源码，mkdir dist文件夹用来放编译之后的代码 在当前目录下打开命令行，输入npm init -y:模块初始化 忽略node_modules文件夹，touch .gitignore新建忽略文件 –&gt;vi .gitignore用vi打开 –&gt; /node_modules填入要忽略的文件,这样这个文件夹就不会上传到github 退出vim: esc + : + w + q git init：初始化本地仓库 git status -sb,这个 ?? 表示 git 一脸懵逼，不知道你要怎么对待这些变动。另外，可以看到没有node_modules,说明成功ignore了 git add:你可以一个一个地add git add index.html,git add css/style.css，也可以add整个目录git add . git commit -m:你可以一个一个地 commit,git commit index.html -m &#39;添加index.html&#39;,git commit css/style.css -m &quot;添加 css/style.css&quot;,你也可以一次性 commit git commit . -m &quot;添加了几个文件&quot; git commit -v提交时显示所有diff信息 在src下新建index.html,开始写代码 初始化LeanCloud并验证初始化1234567var APP_ID = 'uTQBfXRvG7xxxxxxxxxxx-gzGzoHsz';var APP_KEY = 'xKkNrIrxxxxxxxxxxxxxxxfvNS';AV.init(&#123; appId: APP_ID, appKey: APP_KEY&#125;); 验证123456789101112测试代码：//在数据库中创建Class，名为TestObjectvar TestObject = AV.Object.extend('TestObject');//获取名为TestObject的Classvar testObject = new TestObject();testObject.save(&#123; //保存 words: 'Hello World!'到该Class中 words: 'Hello World!'&#125;).then(function(object) &#123; alert('LeanCloud Rocks!');&#125;) 用七牛云存储存文件利用七牛云存储保存静态文件(图片、mp3、视频、js文件、css文件)]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>教程</tag>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿锤子3Dbanner]]></title>
    <url>%2F2018%2F04%2F17%2F%E4%BB%BF%E9%94%A4%E5%AD%903Dbanner%2F</url>
    <content type="text"><![CDATA[See the Pen 3D Banner by qingjin (@mqhe2007) on CodePen. 本文转载自：锤子官网3D翻转特效banner插件 预览效果 html页面代码1234567891011121314&lt;div class="container"&gt; //外层容器名 &lt;div class="banner"&gt;Hello&lt;/div&gt; //内层banner名&lt;/div&gt; &lt;script type="text/javascript"&gt; // 调用插件函数，传入参数实现效果 3dbanner(&#123; container:".container", banner:".banner", initDeg: 10, url: "../images/img1.jpg", con_height: 400 &#125;); &lt;/script&gt; 引入js插件使用说明12345678910111213141516// 该插件依赖于jquery// 使用者需要在页面中书写这样的标签// &lt;div class=""&gt;// &lt;div class=""&gt;&lt;/div&gt;// &lt;/div&gt;// 引入该插件后会得到一个3dBanner方法，可以全局调用// 方法的参数data 是一个对象// 下面是参数的说明// &#123;// container: 容器盒子的类名 字符串// banner： 展示banner盒子的类名 字符串// initDeg: 最大旋转角度 数值// url: banner背景图路径 字符串// con_height: 容器盒子的高度 数值 // &#125; js插件核心代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758(function(win)&#123; function fnBanner(data)&#123; var con_height=data.con_height || 400; var ban_height=con_height*0.7; var con_padding=con_height*0.15; $(data.banner).css(&#123; height:ban_height+"px", width:"80%", margin:"0 auto", transition:"transform 0.1s" &#125;).css("background","url("+data.url+") no-repeat center").css( "background-size","contain").css("box-shadow","0 0 15px rgba(0,0,0,0.3)") $(data.container).css(&#123;height:con_height+"px", padding:con_padding+"px 0", width:"100%", background:"white", border:"1px solid gray", perspective:"1000px" &#125;).css("box-sizing","border-box") $(data.container).on("mousemove",function(e)&#123; var offset=$(data.container).offset(); var x=e.pageX-offset.left; var y=e.pageY-offset.top; var centerX=$(data.container).outerWidth()/2; var centerY=$(data.container).outerHeight()/2; var distanceX=x-centerX; var distanceY=y-centerY; var perX=distanceX/centerX; var perY=distanceY/centerY; var initDeg=data.initDeg || 10; $(data.banner).css(&#123; transform:'rotateX('+initDeg*-perY+'deg) rotateY('+initDeg*perX+'deg)' &#125;) &#125;) $(data.container).on("mouseleave",function()&#123; $(data.banner).css(&#123; transform:'' &#125;) &#125;) console.log("ok"); &#125; win.banner3d=fnBanner;&#125;)(window);]]></content>
      <categories>
        <category>效果及美化</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 如何写简历]]></title>
    <url>%2F2018%2F04%2F16%2F%E5%A6%82%E4%BD%95%E5%86%99%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[简历里应该有哪些重要内容如何做出精美的简历如何投递简历 写简历简历的目的是展示自己会什么技能、有多么的牛叉 基本信息 姓名，年龄，性别，目标职位(写在pdf文件名里，比如stage-应聘前端工程师-2018)、学校 联系方式：手机(不要写在网上，只写在pdf里)、邮箱、QQ、微信 技能描述【按照投递公司的需求对技能排序】 小程序制作可以独立进行小程序开发，熟悉AAAA、BBB、CCCC相关API或组件的使用。 Vue【将别人博客文章里经常提到的技术关键字提炼出来】熟悉 Vue 常用功能，如组件、Vue-Router、双向绑定等。 jQuery熟悉 jQuery 的常用 API，能使用 jQuery 制作网站、轮播、Tab 组件等。 HTML 5 &amp; CSS 3能独立制作精美网页，掌握 CSS 3 动画、过渡效果、响应式等常用技术。 移动端页面会使用 REM、vw/vh、FastClick 等技术制作适配手机设备的页面。 前端框架理解 MVC、MVVM 等思想，可以熟练使用相关的库，如 Vue、React ES6会使用ES6的let、const、解构赋值、箭头函数 项目展示数量：6~8个，给方方看，让他删选。一定要配预览截图项目种类： 手机端项目 框架（Vue、React） CSS 3（皮卡丘） 原生 JS、jQuery（网易云音乐）:表示即使没有框架也能做项目 Node.js 命令行 小程序、React、echarts.js 项目只要好看，就是好项目。只要不好看就会扣分。给面试官看的东西，不要有明显的缺点。如果是在线网页，网页里的图片大小全部都不能超过 300kb 画板 给源码链接 预览链接（手机预览给二维码 https://cli.im） 关键词：原生 JavaScript、Canvas、响应式、jQuery、Vue 描述【用3句话:①通过xx技术实现了yyy功能。②由自己独立开发③用到了VUE-Router、Webpack、第三方库(比如swiper、axios)等】：该项目使用原生JS实现，主要调用 Canvas API，实现了划线、调色、橡皮擦、保存等功能。完全由我独立开发。用 XXX - 实现了 XXX 功能，用 XXX 实现了 XXX 功能。 简历生成器 源码链接 预览链接 关键词：Vue、原生 JS、Vue-Router、响应式、webpack、SASS、Babel、vue-cli 描述：该项目使用 Vue - 实现了一个可编辑简历的工具，该工具可以在线修改简历、分享简历、换主题等。这是我通过两周的学习，实现的第一个 Vue 项目，目前已经发布上线。我用 Vue-Router 实现了路由功能，使用 webpack 打包代码…… 教育经历本科，xxx学士学位。【也可以写到基本信息里】 工作经历经历如果跟编程无关，就简单描述，比如在机械相关行业做过1年，最后加一句自学前端半年。经历跟前端有关，就说技术名称，如 Java、Linux命令行、HTTP，自学前端半年。 链接：博客链接、GitHub链接 博客：至少有8篇 GitHub：要有点绿再给面试官看 你翻译的文章链接 你在 MDN 上贡献的编辑 其他 得奖 英语四六级 计算等级考试 其他可能有两点的东西 投递简历 拉勾、boss直聘里起薪低于9k的你都可以尝试。 BOSS直聘，如果没有技术面试直接录取，就别去，可能是传销。 智联招聘、前程无忧、大街网、猎聘网等基本都是外包。 去搜公司的官网，在官网找「加入我们」「招聘」字样 微博搜「前端招聘」微信搜「杭州 前端」点击找人，也可以用推特搜 v2ex，可能被喷 从培训班出来之后找工作的经历，教会了我这五件事 一个炫酷的简历模板 面试词典：什么叫精通？什么叫熟悉？什么叫了解？ 平时你从哪里获取前端知识？ 如果中国前端已经一半海水了，那么 Java、iOS 和安卓就…… HR的心态假想面试官刚吃完早饭，10分钟后去开会，现在要看10份简历，你的简历是否能脱颖而出，是否有亮点，没有亮点是否有美图。 把所有学过的东西随意组合（不要自己设计），让自己的简历跟同学的不一样。 美化简历，添加效果搜索关键词：js amazing effects如果要搜库，就在后面加上关键词 lib前端在线简历能用到的炫酷UI库]]></content>
      <categories>
        <category>简历</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios的使用]]></title>
    <url>%2F2018%2F04%2F14%2Faxios%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[axios中文文档axios发送GET、POST请求axios拦截器的使用 用axios代替ajaxAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。axios中文文档 基础用法1234567891011121314151617181920212223242526272829303132// 发送 GET 请求axios(&#123; method: 'get', url: '/user', params: &#123; ID: 12345, &#125;&#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);;// 发送 POST 请求【data属性只能用于POST】axios(&#123; method: 'post', url: '/user', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);; 执行GET请求123456789101112131415161718192021// 为给定 ID 的 user 创建请求axios.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 可选地，上面的请求可以这样做axios.get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行POST请求12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 拦截响应，返回自定义假数据123456789101112131415161718192021// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 let &#123;config:&#123;url,method,data&#125;&#125; = response; //↑ 分解成let url = response.config.url; if (url === '/book/1' &amp;&amp; method === 'get') &#123; response.data = &#123; name: stage, &#125; &#125; else if (url === '/books/1' &amp;&amp; method === 'put') &#123; data = JSON.parse(data) Object.assign(book, data) response.data = book &#125; return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;);]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 webpack入门]]></title>
    <url>%2F2018%2F04%2F13%2Fwebpack%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前端工程化：自动化(用命令行自动转译)、模块化、性能优化模块自动化构建工具：webpack的使用postcss：自动添加浏览器私有前缀sass：sass转cssless：less转cssbabel：es6转es5extract-text-webpack-plugin：分离出独立的css文件webpack4参考教材webpack：从入门到真实项目配置关于 webpack 的面试题有哪些？ 前端工程化大公司里怎样开发和部署前端代码? 个人：写html、css、js 大公司：工程化(自动化、模块化、性能优化) 自动化(命令行自动实时转译) 用Less命令行将less自动转成css 用Bable命令行将es6语法自动转成es5 用Autoprefixer命令行将css3自动加上浏览器私有前缀 webpack模块自动化构建工具什么是模块？在 webpack 下，所有类型的文件都可以是模块，包括 CSS、图片、JSON，等等。 前端工程化遇到的问题： Less、Babel、Autoprefixer等必须全部开着命令行监控文件的变化，才能实时自动转译。 前端发展很快，html–&gt;pug–&gt;slim, css–&gt;less–&gt;sass–&gt;scss–&gt;stylus, js–&gt;es6–&gt;Typescript 能不能不要开那么多命令行窗口呢？并且根据文件后缀名自动转成标准的前端文件呢？用模块自动化构建工具(打包工具)！ 模块自动化构建工具(打包工具)发展史Grunt –&gt; Gulp –&gt; Webpack –&gt; Parcel 项目目录结构 .bin:binary,可执行的 dist:distributable,可分发的 12345678910111213|||-- src //source，未经转译过的源文件| |-- imgs //图片放这里| |-- js //原始js代码放这里| |-- style //原始样式代码(.less,.scss,.sass)放这里||-- dist //distribution，转译后的代码| |-- index.html||-- node_modules //通过npm下载的第三方库||-- vendors //自己找的第三方库 使用步骤 退出vim：esc +：+ w + q $ node_modules/.bin/webpack –watch //监听变动并自动打包 $ node_modules/.bin/webpack -p //压缩混淆脚本，这个非常非常重要！ $ npm list -g –depth=0 查看所有全局安装 先全局安装[不推荐全局安装 webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中，可能会导致构建失败。]npm i webpack webpack-cli -g 进行全局安装【如果出现npm install出现”Unexpected end of JSON input while parsing near”错误,执行npm cache clean --force】 在项目目录下打开命令行，npm init -y初始化模块，生成package.json npm i webpack webpack-cli -D（-D表示--save-dev），安装webpack到当前目录(局部安装) webpack装在了node_modules文件夹下一个.bin文件夹里(binary:可执行的) 创建./src/index.js 打开package.json并添加 1234"scripts": &#123; "dev": "webpack --mode development", "build": "webpack --mode production" &#125; 这样，在执行npm run dev时吐出未压缩的包，执行npm run build时吐出压缩后的包 webpack4参考教材：https://blog.zfanw.com/webpack-tutorial/ 默认入口和出口 创建文件./src/index.js 从webpack 4开始，不需要定义入口点：它会将./src/index.js作为默认值！【可以创建webpack.config.js进行修改】 打开package.json并添加一个构建脚本：”scripts”: { “build”: “webpack”}保存并关闭文件 执行npm run build，默认在 ./dist/main.js中获得该软件包。webpack4会查找./src/index.js作为默认入口点。 而且，它默认会在./dist/main.js中吐出这个包。 创建./dist/index.html,并引入main.js 配置入口和出口如果不想要默认配置，可以自定义配置 新建webpack.config.js（这个配置文件可以拷贝官方文档） 1234567module.exports = &#123; entry: './src/a.js' //入口 a.js可以简写成a output: &#123; //出口 path: path.resolve(__dirname, 'dist'), //__dirname表示当前目录,后面的参数表示文件夹名 filename: 'bundle.js' &#125;&#125;; 这样，我们只需要执行npm run build，就可以将src下的a.js打包到dist下的bundle.js(压缩模式) 1234567891011多入口，多出口配置module.exports = &#123; entry: &#123; home: './src/home.js' //home.js可以简写成home ,signup: './src/signup.js' &#125;, output: &#123; //出口 path: path.resolve(__dirname, 'dist'), //__dirname表示当前目录,后面的参数表示文件夹名 filename: '[name].bundle.js' //生成home.bundle.js和signup.bundle.js &#125;&#125;; 生产模式production和开发模式development生产模式build：压缩，体积小开发模式dev：未压缩，体积大 事实上，如果你注意npm run build的输出，你会看到一个很好的警告： The ‘mode’ option has not been set. Set ‘mode’ option to ‘development’ or ‘production’ to enable defaults for this environment.（“mode”选项尚未设置。 将“mode”选项设置为“development”或“production”以启用此环境的默认值。） 打开package.json并添加1234"scripts": &#123; "dev": "webpack --mode development", "build": "webpack --mode production" &#125; 这样，在执行npm run dev时吐出未压缩的包，执行npm run build时吐出压缩后的包 文件实时更新【会自动更新mian.js】打开package.json并添加123"scripts": &#123; "watch": "webpack --mode development --watch" &#125; 这样，执行npm run watch就可以实时监控文件，一旦文件有变化就自动更新 自动刷新浏览器【更新的文件保存在缓存中】webpack-dev-server 为你提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)。安装：npm i webpack-dev-server -D打开package.json并添加123"scripts": &#123; "start": "webpack-dev-server --mode development --content-base ./dist --open",&#125; 这样，在执行npm start就会看到浏览器自动加载页面。 注意：你启动webpack-dev-server后，你在./dist/main.js中是看不到编译后的文件的,实时编译后的文件都保存到了浏览器内存当中。因此很多同学使用webpack-dev-server进行开发的时候都看不到编译后的文件【解决办法】多开一个命令行串口，用npm watch实时监控文件变动随时编译就行了。webpack-dev-server的端口怎么修改?【解决方法】用–port来制定参数，比如webpack-dev-server --port 8888 LOADER转译器Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件(ES6,less,sass,scss等)，就需要使用 loader 进行转换。 css相关loadersass-loader 把sass转成csscss-loader 会遍历 CSS 文件，然后找到 url() 表达式然后处理他们style-loader 把CSS 代码插入页面中的一个 style 标签中。 sass-loadernpm i -D css-loader style-loadernpm i -D sass-loader node-sassnpm i -D less less-loadernpm i -D extract-text-webpack-plugin@nextnpm i -D postcss-loader //添加前缀12345678910111213141516171819202122232425262728创建postcss.config.jsmodule.exports = &#123; plugins: &#123; 'postcss-import': &#123;&#125;, 'postcss-cssnext': &#123;&#125;, 'cssnano': &#123;&#125; //压缩css代码 &#125;&#125;``` 在index.js中将样式表引入`import ../css/style.scss`### babel-loadernpm i -D babel-core babel-preset-env babel-loader在webpack.config.json填入 ```javascriptmodule: &#123; rules: [&#123; test: /\.js$/, //以.js结尾的文件 exclude: /(node_modules|bower_components)/, //排除 use: &#123; loader: 'babel-loader', options: &#123; presets: ['env'] &#125; &#125; &#125;] &#125; 常用指令用npx可以自动找到命令行工具所在位置，比如npx webpack --mode development --watch等同于./node_modules/.bin/webpack --mode development --watch这样就不需要安装到global全局也能使用，比如原本http-server要安装到全局，然后才能http-server -c-1 -o，现在可以不安装到全局，直接npx http-server -c-1 -o打开 npx webpack -v：查看webpack版本号 npm run dev 不压缩文件 npm run build 压缩文件 npm run watch启动watch监视 面试题http://ovenzeze.coding.me/]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>教程</tag>
        <tag>webpack</tag>
        <tag>打包工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[console.log添加样式及图片]]></title>
    <url>%2F2018%2F04%2F13%2Fconsole-log%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F%E5%8F%8A%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[console.log在控制台打出css样式的文字及图片 console.log增强api谷歌开发者中心上面关于谷歌浏览器控制台console.log()的文档 Format Specifier %s Formats the value as a string. %d or %i Formats the value as an integer. %f Formats the value as a floating point value. %o Formats the value as an expandable DOM element (as in the Elements panel). %O Formats the value as an expandable JavaScript object. %c Formats the output string according to CSS styles you provide. 可以看到，通过占位符%c,可以对输出到console控制台的文字进行CSS控制。 格式如下： console.log(&quot;%c需要输出的信息 &quot;, &quot;css 代码&quot;); 输出3D TEXT1console.log("%c3D Text"," text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);font-size:5em") 彩色背景文字1console.log("%c彩色文字","background: rgba(252,234,187,1);background: -moz-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%,rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -webkit-gradient(left top, right top, color-stop(0%, rgba(252,234,187,1)), color-stop(12%, rgba(175,250,77,1)), color-stop(28%, rgba(0,247,49,1)), color-stop(39%, rgba(0,210,247,1)), color-stop(51%, rgba(0,189,247,1)), color-stop(64%, rgba(133,108,217,1)), color-stop(78%, rgba(177,0,247,1)), color-stop(87%, rgba(247,0,189,1)), color-stop(100%, rgba(245,22,52,1)));background: -webkit-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -o-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -ms-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: linear-gradient(to right, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#fceabb', endColorstr='#f51634', GradientType=1 );font-size:5em") 文字颜色1console.log('%c我是蓝色字','color:blue;font-size:24px'); 设置不同的css1console.log("%c 第一 %c 第二 %c 第三", "color:red","color:green","color:green") 在Chrome控制台输出图片1console.log("%c", "padding:50px 300px;line-height:120px;background:url('http://www.iconpng.com/png/tailwaggers_free/pug.png') no-repeat;"); 参考资料https://www.cnblogs.com/Wayou/p/chrome_dev_tool_style_console.html]]></content>
      <categories>
        <category>效果及美化</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>教程</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端性能优化：HTTP缓存资源(文件)]]></title>
    <url>%2F2018%2F04%2F12%2Fhttp%E7%BC%93%E5%AD%98cachecontrol%2F</url>
    <content type="text"><![CDATA[如何加速网页访问(减少HTTP请求)？HTTP缓存！Cache-Control:max-age=30000ExpiresEtagLast-Modified菜鸟教程：HTTP 通过Cache-Control加快请求速度前端性能优化中,减少HTTP请求可以提高页面的响应速度后端对某个要传送的文件设置Cache-Control响应头,使其缓存30秒，然后发送给浏览器；浏览器在30秒内刷新，不会再次发送请求，而是直接从缓存中取得该文件。超过30秒后刷新，会向服务器发送请求。1response.setHeader('Cache-Control', 'max-age=30') 必须是相同的Request URL才能在过期前从缓存中取文件。通过更改Request URL的查询参数（比如http://a.b.com/main.js?v1），每次向服务器发送的请求就都不一样了，于是不会从缓存中取文件。 文件在后端有升级怎么办设置main.js缓存10年，这样每次请求main.js时都会从缓存中获取。如果中途main.js有升级，就将main.js的Request URL的查询参数改成main.js?v2，这样就可以获取最新的js文件，并且新文件缓存10年；如果再升级，就将main.js的Request URL的查询参数改成main.js?v3 chrome调试如果在chrome的开发者工具 –&gt; network 中选择disable cache，那么就不会从缓存中获取文件，而是向服务器发送请求 Expires从前人们用Expires缓存现在人们用Cache-Control缓存如果设置了Cache-Control响应头，那么Expires响应头就会被忽略 后端程序员通过Expires响应头，设置过期时间1response.setHeader('Expires', 'Thu, 19 Apr 2018 08:17:46 GMT') //GMT格式 Expires与Cache-Control的区别Expires设置具体的过期时间(绝对时间点)Cache-Control设置多长时间段后过期(相对时间段) 如果用户修改了本地的时间，那么Expires就会受到影响。比如Expires到2018年x月x日过期，用户将本地时间改成2019年x月x日，那么Expires就失效了。而Cache-Control是一个相对过期时间，所以不存在这个问题。 Etag/If-None-MatchEtag/If-None-Match要配合Cache-Control使用。当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。服务器收到请求后发现有头If-None-Match 则与被请求资源的Etag值进行比对，决定返回200或304。 Etag 服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）后端程序员通过Etag响应头，设置Etag值(唯一标识)1response.setHeader(&apos;Etag&apos;, &apos;xxxxxxxxx&apos;) 浏览器首次发送请求后，服务器会传给浏览器Etag查看响应头123456Response HeadersCache-Control:max-age=600Connection:keep-aliveContent-Length:0Etag:xxxxxxxxx If-None-Match 浏览器再次发送请求时，在Request Headers里的If-None-Match带上Etag值：123Request HeadersIf-None-Match:xxxxxxxxx 如果发送请求时带上的这个If-None-Match的值与服务端的Etag值一样，那么就返回304，且不下载资源 304304 Not Modified：未曾修改过后端返回304，则不下载响应体(文件) Etag与Cache-Control的区别Cache-Control设置资源有效期10年，那么只要这个资源的Request URL不变，则10年内后端都不会收到请求【直接不请求】服务器给浏览器种下Etag后，浏览器发送请求时会在请求头带上If-None-Match，服务器收到请求后，对比If-None-Match的值与服务器上的Etag值，如果一样，则返回304，不下载资源文件【有请求，但不下载】Cache-Control更好，因为Cache-Control直接不发送请求，提高了页面的响应速度 Last-Modified/If-Modified-SinceLast-Modified/If-Modified-Since要配合Cache-Control使用。 Last-Modified：标示这个响应资源的最后修改时间。服务器在响应请求时，告诉浏览器资源的最后修改时间。 If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向服务器请求时带上头 If-Modified-Since，表示请求时间。服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源最近有改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用本地缓存文件。 总结浏览器第一次请求： 浏览器再次请求时： 参考资料：浏览器缓存机制]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>面试题</tag>
        <tag>web前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步与回调]]></title>
    <url>%2F2018%2F04%2F11%2F%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%9B%9E%E8%B0%83%2F</url>
    <content type="text"><![CDATA[同步与异步的区别通过【回调】获得异步任务的结果输出结果的优先级：同步 =&gt; 异步 =&gt; 回调参考资料：方应杭：异步与回调 代码执行顺序同步优先、异步靠边、回调垫底12345console.log(1)setTimeout(function()&#123; console.log(2)&#125;,0)console.log(3) 上面代码的书写顺序是 1 -&gt; 2 -&gt; 3； 但是执行顺序是 1 -&gt; 3 -&gt; 2。 中间的 console.log(2) 就是异步执行的。 你现在知道了「代码的书写顺序和执行顺序居然可以不同！」 同步与异步的区别同步：你用饿了么点外卖，然后在楼下一直等外卖小哥，直到他把外卖送到异步：你用饿了么点外卖，然后去玩游戏，过一会外卖小哥打电话说外卖送到楼下了，你再下楼去取外卖。【其中，外卖小哥打电话通知你的这个行为称为“回调”】 同步：一定要等任务执行完了，得到结果，才执行下一个任务。123456function taskSync()&#123; return '同步任务的返回值'&#125;var result = taskSync() // 那么 result 就是同步任务的结果nextTask() // 然后执行下一个任务 异步：不等任务执行完，直接执行下一个任务。123456789function taskAsync()&#123; var result = setTimeout(function()&#123; console.log('异步任务的结果') &#125;, 3000) return result&#125;var result = taskAsync() // result 不是异步任务的结果，而是一个 timer idotherTask() // 立即执行其他任务，不等异步任务结束 我们拿到的 result 不是异步执行的结果，而是一个 timer id,那么要怎么拿到异步任务的结果呢？ 答案是用【回调】！ 回调将一个函数作为参数传递给另一个函数，作为参数的这个函数就是回调函数。 同步回调1234567891011var callback = function(arg3) &#123; console.log('cb:' + arg3) &#125;function fn(arg1, arg2, cb) &#123; var Total = arg1 + arg2; cb(Total); console.log('fn1:' + Total)&#125;fn(2, 2, callback) // 调用fn()函数，并传入2, 2, callback作为参数 上面的代码执行结果为：12cb:4fn1:4 不对啊！ 回调函数不是应该在主函数的最后执行吗？上面的例子是一个同步回调函数，函数的执行顺序依然自上而下顺序执行。那么什么是异步回调呢？ 异步回调在异步回调中，同步 =&gt; 异步 =&gt; 回调123456789101112function f2() &#123; console.log('f2 finished') &#125;function f1(cb) &#123; setTimeout(cb,1000) //用setTimeout()模拟耗时操作 console.log('f1 finished')&#125;f1(f2); //得到的结果是 f1 finished ，f2 finished 「回调」经常用于获取「异步任务」的结果:1234567891011function taskAsync(callback)&#123; var result = setTimeout(function()&#123; callback('异步任务的结果') &#125;, 3000) return result&#125;taskAsync(function(result)&#123; console.log(result) // 三秒钟后，这个 callback 函数会被执行&#125;)otherTask() // 立即执行其他任务，不等异步任务结束 回调函数的参数 将回调函数的参数作为与回调函数同等级的参数进行传递 回调函数的参数在调用回调函数内部创建]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储状态:cookie、session、localStorage、sessionStorage与登入注册]]></title>
    <url>%2F2018%2F04%2F10%2Fcookie%E4%B8%8E%E7%99%BB%E5%85%A5%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[参考书目：图解HTTP若愚：cookie、session、localStorage分别是什么？有什么作用？读图解http有感：认识HTTP—-Cookie和Session篇复习HTTP请求与响应cookie的相关知识通过cookie发送sessionIDlocalStorage与cookie的区别sessionStorage Cookie、Session、Cache-Control https://zh.wikipedia.org/wiki/Cookie https://zhuanlan.zhihu.com/p/22396872?refer=study-fe Session 维基百科：https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6) Cache-Control 注意！这是响应头，不是请求头！！ 复习HTTP的请求与响应chrome 发送Request请求 –&gt; server12345GET /xxx HTTP/1.1Content-Type:application/x-www-form-urlencoded;charset=UTF-8Content-Length:160回车换行name=stage&amp;age=24 server 发送Response响应 –&gt; chrome12345HTTP/1.1 200 OKContent-Type:text/html; charset=utf-8Content-Length:23570回车换行&lt;!DOCTYPE html&gt;&lt;html&gt;.....省略&lt;/html&gt; 登入注册功能用到的代码：https://github.com/FrankFang/sign-in-demo cookiecookie是存储在浏览器上的一小段数据，用来记录某些当页面关闭或者刷新后仍然需要记录的信息。 服务端通过Set-Cookie设置响应头发送给浏览器，告诉浏览器保存Cookie。response.setHeader(&#39;Set-Cookie&#39;,sign_in_email=${email}) 浏览器得到cookie后，以后每次向该服务器发送请求时都会自动带上cookie 服务器读取到浏览器发送过来的cookie后，对比服务器上的数据，就知道用户的信息(email)了 cookie的特点 cookie不安全，可以直接在浏览器里篡改。Session 可以解决这个问题，防止用户篡改 cookie默认在关闭浏览器后失效（可以人为设置过期时间） 大小在4kb以内 如何操作cookie阮一峰：cookie注意！每个cookie以分号+空格 隔开:name=stage; expires=Thu, 01 Jan 1970 00:00:00 GMTkey与value之间的等号不能有空格：name=stage不能写成name = stage 前端操作cookie 获取cookie：var x = document.cookie; 设置/添加cookie：document.cookie=&quot;username=stage&quot;;【如果您设置了另一个 cookie，旧的 cookie 不会被覆盖。 】 修改：创建同名Cookie，覆盖原来的Cookie 设置过期时间(以 UTC 或 GMT 时间）：document.cookie=&quot;username=stage; expires=Thu, 18 Dec 2018 12:00:00 GMT&quot;;则username这一条数据将在该时间过期 expires属性的值为 GMT 格式，表示具体过期的时间点 max-age属性的值为秒数，表示xx秒后过期 如果同时指定了expires和max-age，那么max-age的值将优先生效。 删除指定cookie：document.cookie = &quot;username=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;; 后端操作cookie 设置过期时间：response.setHeader(&#39;Set-Cookie&#39;, &#39;name=stage; Expires=Thu, 18 Dec 2018 12:00:00 GMT&#39;); Expires属性指定一个具体的到期时间，到了指定时间以后，浏览器就不再保留这个 Cookie。 Max-Age属性指定从现在开始 Cookie 存在的秒数，比如60 60 24 * 365（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。 Expires根据用户电脑时间，如果用户电脑时间不对，会影响cookie的过期时间，而Max-Age是一个相对时间，因此不受用户电脑时间的影响。 如果同时指定了Expires和Max-Age，那么Max-Age的值将优先生效。 删除cookie，只需要设置为以前的时间：response.setHeader(&#39;Set-Cookie&#39;, &#39;name=stage; Expires=Thu, 01 Jan 1970 00:00:00 GMT&#39;) Sessioncookie存在的问题：用户可以随意篡改 Cookiesession很安全，用户无法篡改session的有效期采用发呆时间，默认是用户不操作超过20分钟（可以人为修改发呆时间），服务器会把长时间没有活动的Session从服务器内存中清除。 Cookie与Session当一个用户打开淘宝登录后，刷新浏览器仍然展示登录状态。服务器如何分辨这次发起请求的用户是刚才登录过的用户呢？ Cookie 服务器通过设置 Set-Cookie 响应头给浏览器一串字符串(种下cookie) 浏览器每次访问相同域名的网页时，必须带上这段字符串 浏览器要在一段时间内保存这个Cookie Cookie 默认在用户关闭页面后就失效，后台代码可以任意设置 Cookie 的过期时间 大小大概在 4kb 以内 没有Cookie信息状态下的请求 第2次以后（存有Cookie信息状态）的请求 HTTP 请求报文和响应报文的内容如下①请求报文（没有Cookie 信息的状态）123GET /reader/ HTTP/1.1Host: hackr.jp*首部字段内没有Cookie的相关信息 ②响应报文（服务器端生成Cookie 信息）12345HTTP/1.1 200 Set-Cookie: name=stage; path=/; expires=Wed,10-Oct-12 07:12:20 GMTDate: Thu, 12 Jul 2012 07:12:20 GMTServer: ApacheContent-Type: text/plain; charset=UTF-8 ③请求报文（自动带上Cookie信息发送给服务器）123GET /image/ HTTP/1.1Host: hackr.jpCookie: name=stage Session 服务器通过 Cookie 发送给浏览器一个 SessionID（随机数) 服务器有一块内存（哈希表）保存了所有 session 每次浏览器访问服务器时自动带上SessionID 服务器通过读取SessionID，我们可以得到对应用户的隐私信息，如 id、email 这块内存（哈希表）就是服务器上的所有 session 12345服务端：var sessions=&#123;&#125;;var sessionID = Math.random()*100000; //随机数sessions[sessionId] = &#123;sign_in_email: email&#125;;response.setHeader('Set-Cookie', `sessionID=$&#123;sessionID&#125;`) 由于SessionID是随机数，无法知道另一个用户的SessionID，因此无法篡改。 cookie与session的区别 session是基于cookie实现的。 cookie是session的基石。 cookie不安全，可以直接在浏览器里篡改。 session通过cookie给浏览器发送sessionID(随机数)，因此用户无法篡改 cookie默认在关闭浏览器后失效（可以人为设置过期时间） session的有效期采用发呆时间，默认是用户不操作超过20分钟（可以人为修改有效期），服务器会把长时间没有活动的Session从服务器内存中清除。 cookie和session不归前端管，交给后端去设置和读取！ localStoragecookie和session在浏览器每次发送请求时都会被自动带上，如果cookie或session太多太大，对传输效率会有影响。 localStorage是HTML5提供的Web 存储 session是存储在服务器上的哈希表(浏览数据) localStorage是存储在本地的哈希表(浏览数据) 特点 LocalStorage 跟 HTTP 无关，浏览器发送请求时不会带上 LocalStorage 的值 只有相同域名的页面才能互相读取 LocalStorage（没有同源那么严格） 每个域名 localStorage 最大存储量为 5Mb 左右（每个浏览器不一样） 常用场景：记录有没有alert过用户，记录用户有没有点过赞（记录不敏感的信息，不能记录密码） LocalStorage 永久存储，除非用户清理缓存(chrome -&gt; 清除浏览数据 -&gt; 高级 -&gt; Cookie及其他网站数据) localStorage相关api 存值：localStorage.setItem(&#39;key&#39;,&#39;value&#39;); 或者 localStorage.key = &#39;value&#39;; 只能存字符串，如果是对象，要通过Json.stringify(obj)转成字符串123456789var x = localStorage;x.setItem('name','stage');等价于 localStorage.name = 'stage'可以用中文：x.setItem('姓名','stage');x.setItem('obj',JSON.stringify(&#123;'name':'stage'&#125;))查看所有值：console.log(x) 取值：localStorage.getItem(&#39;key&#39;) 12x.getItem('name');x.getItem('obj'); 删除单个数据：localStorage.removeItem(&#39;key&#39;); 清空：localStorage.clear(); 得到某个索引的key：localStorage.key(index); localStorage与cookie的区别cookie参与网络传输。每次浏览器发送请求时， Request headers 中都会带上cookie。localStorage是本地存储，不参与网络传输。 cookie最大4kblocalStorage最大5mb sessionStoragesessionStorage的特点与localStorage的前3个特点一样与localStorage的区别在于，sessionStorage在用户关闭页面后（会话结束）就失效。 sessionStorage的api与localStorage的用法一样1234567891011var x = sessionStorage;存值：x.setItem('name','stage');等价于x.name = 'stage';取值：x.getItem('name');查看所有值：console.log(x)删除单个数据：x.removeItem('name');清空：x.clear(); sessionStorage与localStorage的区别LocalStorage 永久存储，除非用户清理缓存sessionStorage在用户关闭页面时（会话结束）就失效。 关于有效期cookie在关闭浏览器后失效(可以人为修改过期时间)session采用发呆时间，服务器会把长时间没有活动的Session从服务器内存中清除，此时Session便失效。默认用户超过20分钟不操作就失效。(可以人为修改发呆时间)sessionStorage在关闭当前页面时失效localStorage永久存储，除非人为清空缓存]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>请求与响应</tag>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 JS高级基础知识考试]]></title>
    <url>%2F2018%2F04%2F07%2FJS%E9%AB%98%E7%BA%A7%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[原型链new命令的作用，以及new命令中的thisjson和javascriptMVC的概念ES5实现类Promise的使用 填空题123456789101112131415161718var object = &#123;&#125;object.__proto__ === ????填空1???? // 为 truevar fn = function()&#123;&#125;fn.__proto__ === ????填空2???? // 为 truefn.__proto__.__proto__ === ????填空3???? // 为 truevar array = []array.__proto__ === ????填空4???? // 为 truearray.__proto__.__proto__ === ????填空5???? // 为 trueFunction.__proto__ === ????填空6???? // 为 trueArray.__proto__ === ????填空7???? // 为 trueObject.__proto__ === ????填空8???? // 为 truetrue.__proto__ === ????填空9???? // 为 trueFunction.prototype.__proto__ === ????填空10???? // 为 true 答： Object.prototype Function.prototype Object.prototype Array.prototype Object.prototype Function.prototype Function.prototype Function.prototype Boolean.prototype Object.prototype 构造函数，new命令中的this1234function fn()&#123; console.log(this)&#125;new fn() new fn() 会执行 fn，并打印出 this，请问这个 this 有哪些属性？这个 this 的原型有哪些属性？答：这里的this指向fn的实例对象，此处是一个空对象，因此这个this没有什么属性。this 的原型有constructor 属性，以及从Object.prototype继承的属性 知识点 在构造函数或者构造函数原型对象中this指向构造函数的实例所谓”构造函数”，就是专门用来生成实例对象的函数。new命令的作用，就是执行构造函数，返回一个实例对象。new命令做了以下几件事： 创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。(this指向这个自动生成的空对象) 然后执行构造函数内部的代码。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。 12345678910111213141516//不使用new指向windowfunction Person (name) &#123; console.log(this); // window this.name = name;&#125;Person('inwe');//使用newfunction Person (name) &#123; this.name = name; console.log(this); // xxx self = this; &#125; var xxx = new Person('iwen'); console.log(self === xxx) //true//这里new改变了this指向，将this由window指向Person的实例对象xxx constructor 属性：new 操作为了记录「空对象是由哪个构造函数创建的」，所以会自动给「构造函数.prototype」加了一个 constructor 属性： constructor 属性返回对象的构造函数。 返回值是函数的引用(比如数组 constructor 属性返回 function Array() { [native code] })，而不是函数名： 1234567function P()&#123; console.log(this);&#125;var x = new P();P.prototype.constructor === P // truex.constructor === P // truep.constructor === P.prototype.constructor // true constructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。12var x = new Array(1,2,3);x.constructor === Array // true Object的共有属性所有对象都继承了Object.prototype的属性。这就是所有对象都有valueOf和toString方法的原因，因为这是从Object.prototype继承的。 JSON 和 JavaScript JSON 和 JavaScript 是什么关系？JSON 和 JavaScript 的区别有哪些？答：关系： JS 是一门语言，JSON 是另一门语言 json这门语言是道格拉斯抄袭js的语言 JSON 使用 Javascript语法来描述数据对象 道格拉斯还写了本《javascript语言精粹》，俗称蝴蝶书，来吐槽js中垃圾的地方 区别：json里的字符串必须用双引号，不能用单引号！json没有undefined和function| js语法 | json语法 || :—-: |:———:|| 123 | 123 || ‘stage’ | “stage” || true | true || [‘a’, ‘b’] | [“a”, “b”] || {name: ‘stage’} | {“name”: “stage”} || null | null || undefined | json没有undefined || function fn(){} | json没有function | 前端 MVC前端 MVC 是什么？请用代码大概说明 MVC 三个对象分别有哪些重要属性和方法。(不用写详细代码，只需要说明重要属性的名称即可)MVC是一种设计模式 Model（模型）- 通常模型对象负责在数据库中存取数据。 View（视图） - 通常视图是将模型里的数据可视化。 Controller（控制器） - 从视图读取数据，控制用户输入，并向模型发送数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var model = &#123; fetch: function()&#123; /* 获取服务端数据 */ &#125; save: function(data)&#123; /* 将数据保存到服务端 */ &#125;&#125;var view = document.querySelector('xxx');var controller = &#123; view: null, model: null; init: function(view,model)&#123; this.view = view; this.model = model; this.form = view.querySelector('form'); this.getData(); this.saveData(); this.bindEvent(); &#125;, getData: function()&#123; this.model.fetch().then(function()&#123;&#125;); &#125;, saveData: function()&#123; this.model.save(data).then(function()&#123;&#125;) &#125;, bindEvent: function()&#123; this.form.addEventListener('submit', function(ev)&#123; ev.preventDefault(); this.saveData(); &#125;) &#125;&#125;controller.init(view, model);``` # 在 ES5 中如何用函数模拟一个类？```javascriptfunction Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job;&#125;Person.prototype.country = 'china';var zs = new Person("张三","29","teacher");var ls = new Person("李四","22","doctor");zs.name // 张三zs.age // 29ls.job // doctorzs.country // chinals.country // china 关于Promise用过 Promise 吗？举例说明。如果要你创建一个返回 Promise 对象的函数，你会怎么写？举例说明。答：Promise的使用：1234567891011121314151617$.get(url).then(function(data)&#123;console.log(data)&#125;,function()&#123;console.log('失败')&#125;);``` 创建： ```javascriptfunction preloadImage(path) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;;preloadImage('/xxx.jpg').then(function()&#123;console.log('成功')&#125;,function()&#123;console.log('失败')&#125;); 知识点Promise 对象是 JavaScript 的异步操作解决方案，从而不必一层层地嵌套回调函数endFn。传统的写法可能需要把f2作为回调函数传入f1，比如写成f1(f2)，异步操作完成后，在f1内部调用f2。Promise 使得f1和f2变成了链式写法。不仅改善了可读性，而且对于多层嵌套的回调函数尤其方便。1234567891011121314151617// 传统回调写法step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // ... &#125;); &#125;); &#125;);&#125;);回调地狱！！// Promise 的写法(new Promise(step1)) .then(step2) .then(step3) .then(step4); 创建一个返回 Promise 对象的函数:1234567891011function preloadImage(path) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;;preloadImage('/xxx.jpg').then(function(data)&#123;console.log('成功');console.log(data)&#125;, function(data)&#123;console.log('失败');console.log(data)&#125;); Promise 对象的状态Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。 pending等待态: 初始状态，既不是成功，也不是失败状态。 fulfilled完成态: 异步操作成功。 rejected拒绝态: 异步操作失败。 上面三种状态里面，fulfilled和rejected合在一起称为resolved（已定型）。这三种的状态的变化途径只有两种。 从“未完成”到“成功” 从“未完成”到“失败” 一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。 因此，Promise 的最终结果只有两种。 异步操作成功，从 pending 变为 fulfilled 异步操作失败，从 pending 变为 rejected。 只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 一开始，我们先设置好等状态从 pending 变成 fulfilled 和 rejected 的预案（当成功后我们做什么，失败时我们做什么）。 Promise 启动之后，当满足成功的条件时我们让状态从 pending 变成 fullfilled （执行 resolve）；当满足失败的条件，我们让状态从 pending 变成 rejected（执行 reject） Promise简单理解原始写法： 12345678910111213141516171819202122232425262728function fn1(callback) &#123; setTimeout(()=&gt;&#123; console.log('fn1') callback() &#125;, 1000)&#125;function fn2(callback) &#123; setTimeout(()=&gt;&#123; console.log('fn2') callback() &#125;, 1000)&#125;function fn3() &#123; setTimeout(()=&gt;&#123; console.log('fn3') &#125;, 1000)&#125;回调地狱↓fn1(function()&#123; fn2(function()&#123; fn3() &#125;)&#125;)//fn1,fn2,fn3 Promise写法：1234567891011121314151617181920212223242526272829303132333435function fn1() &#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log('fn1...') resolve() &#125;, 1000) &#125;)&#125;function fn2() &#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log('fn2...') resolve() &#125;, 1000) &#125;)&#125;function fn3() &#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log('fn3...') resolve() &#125;, 1000) &#125;)&#125;function onerror() &#123; console.log('error')&#125;fn1().then(fn2).then(fn3).catch(onerror)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逻辑运算符 || 和 &&]]></title>
    <url>%2F2018%2F03%2F30%2F%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[&amp;&amp;与运算，有假就返回第一个的假值，全真就返回最后一个真值||或运算，有真就返回第一个的真值，全假就返回最后一个假值&amp;&amp; 的优先级高于 || 与运算 &amp;&amp;&amp;&amp;在运算时找falsy值，只要找到假值，那么输出的值为找到的第一个假值；没找到就输出最后面那个运算结果1234561 &amp;&amp; 0 //01 &amp;&amp; 0 &amp;&amp; 2 &amp;&amp; 3 //0 与运算看到0后就不执行后面的运算了1 &amp;&amp; null &amp;&amp; 3 //null1 &amp;&amp; 0 &amp;&amp; console.log(3) //0 1 &amp;&amp; 2 &amp;&amp; 3 //3 或运算 ||||在运算时找truy值，只要找到第一个真值，那么输出的值为找到的第一个真值。如果没找到真值，那么输出的值为最后面那个运算结果12340 || null || 1 //10 || null || 1 || 2 //1null || undefined || 0 //0 因此，var a = b || {}表示，如果b已经声明了，那么a = b，否则a = {} &amp;&amp; 的优先级高于 ||&amp;&amp; 的优先级高于 ||，先运算&amp;&amp;,再运算||12341 || 'a' &amp;&amp; 2 //1先进行&amp;&amp;运算，结果为2，在运行1 || 2，最终结果为1(1 || 'a') &amp;&amp; 2 //2]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 面向对象编程(OOP)]]></title>
    <url>%2F2018%2F03%2F30%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[面向对象OOP(Object Oriented Programming)特点：继承、封装、多态 面向对象面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。 名词解释 Class 类定义对象的特征。它是对象的Property属性和Method方法的模板. Object 对象类的一个实例。对象是一个容器，封装了属性（property）和方法（method）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。 Property 属性对象的特征，比如颜色。 Method 方法对象的能力，比如行走。 Constructor 构造函数对象初始化的瞬间, 被调用的方法. 通常它的名字与包含它的类一致. Inheritance 继承一个类可以继承另一个类的特征。 Encapsulation 封装一种把数据和相关的方法绑定在一起使用的方法. Abstraction 抽象结合复杂的继承，方法，属性的对象能够模拟现实的模型。 Polymorphism 多态多意为‘许多’，态意为‘形态’。不同类可以定义相同的方法或属性。 用new执行构造函数new命令的作用，就是执行构造函数，返回一个实例对象。下面的例子中，humanX 这个对象本身具有属性 name 和 cityhumanX.proto 对应的共有属性（也就是原型）具有物种（species）、走（walk）和使用工具（useTools）这几个属性 humanX.proto.constructor === Human 为 true123456789101112function Human(options)&#123; //构造函数建议开头大写 //自有属性 this.name = options.name; this.city = options.city;&#125; //共有属性(自带constructor属性和Object.prototype)Human.prototype.species = '人族';Human.prototype.walk = function()&#123;&#125;;Human.prototype.useTools: function()&#123;&#125;var humanX = new Human(&#123;name:'stage', city: 'shanghai'&#125;);]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务器LeanCloud的使用]]></title>
    <url>%2F2018%2F03%2F28%2F%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8LeanCloud%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[云服务器LeanCloud的使用 LeanCloud存储数据 登陆 选择应用 -&gt; 创建新应用 (相当于创建一个服务器) 设置完新应用名称后，点击创建 这样就创建了一个服务器 点击应用名称进入对应服务器 点击创建Class，从而创建数据库 输入Class名称后，点击创建Class 根据帮助手册操作 选择开发语言或平台 -&gt; 选择 LeanCloud 应用 获取SDK：选择CDN加速，将av-min.js引入html文件中，得到window.AV对象 初始化：将代码引入js文件中进行初始化 验证：ping一下，看看能否访问LeanCloud的服务器 ping通后，在项目中编写提供的测试代码 然后打开 控制台 &gt; 存储 &gt; 数据 &gt; TestObject，如果看到如下内容，说明 SDK 已经正确地执行了上述代码，安装完毕。 获取数据数据存储开发指南 选择开发指南中的批量操作获取数据：1234567var query = new AV.Query('Message');//对应数据库中的Class名称query.find().then(function(datas) &#123; console.log(datas);//获取全部数据 datas.forEach(function(value) &#123; console.log(value); //遍历数据 &#125;);&#125;); 查询结果数量和排序参考Guide 设置返回 10 条结果：12345678var now = new Date();query.lessThanOrEqualTo('createdAt', now);//查询今天之前创建的 Todo // 按时间，选出老的 query.ascending('createdAt'); // 按时间，选出最新的 query.descending('createdAt');query.limit(10);// 最多返回 10 条结果]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>数据库</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包基础知识]]></title>
    <url>%2F2018%2F03%2F27%2F%E9%97%AD%E5%8C%85%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[什么是闭包闭包的作用闭包的例子 什么是闭包123456(function ()&#123; var local = '变量'; function fn()&#123; console.log(local); &#125;&#125;)(); 「函数」和「函数内部能访问到的变量」的总和，就是一个闭包。上面代码中的函数fn，它里面可以访问到 local 变量，那么函数fn和local变量形成一个闭包。 闭包的作用闭包的作用是用来「间接访问一个变量」。换句话说，「隐藏一个变量」。利用闭包可以将函数内部的变量传递到外部，从而实现在外部访问另一个函数内部的局部变量。 123456789101112131415(function()&#123; var person = window.person = &#123;//将这个对象的Address赋给window.person name: 'stage', &#125; var a=1;//传不出去&#125;)();//访问上面这个立即执行函数内部的person(function()&#123; var person = window.person;//获取window.person的Address，并赋给变量person console.log(person);//可以访问到 console.log(a);//访问不到&#125;)(); 闭包的使用如果person等于window.person，别人就可以访问到person内的数据，这样看起来很不妥。万一别人不小心修改了person内的数据怎么办。所以我们不能让别人「直接访问」这个变量。怎么办呢？用局部变量。但是用局部变量别人又访问不到，怎么办呢？如何从外部读取函数内部的局部变量？暴露一个访问器（在函数的内部，再定义一个函数），让别人可以「间接访问」。 1234567891011121314151617181920(function()&#123; var person = &#123; name: 'stage', age: 24, &#125; window.addAge = function ()&#123; //访问器 person.age++; return person.age; &#125;&#125;)();(function()&#123; var person = window.person;//获取不到 console.log(person);//undefined //无法获取person的信息，只能操作它的addAge方法 var newAge = window.addAge(); console.log(newAge);&#125;)(); ！ 上面代码中，利用闭包，让别的函数无法获取和修改person的name和age，只能通过addAge间接给age加一，从而隐藏并保护了person内的数据。 再举个例子：123456789101112131415var xxx = (function()&#123; var a = 1; return &#123; getA:function()&#123; return a; &#125;, addA:function()&#123; a++; return a; &#125; &#125;&#125;)();xxx.addA();xxx.getA(); 总结 立即执行函数使得person无法被外部访问 闭包使得内部的匿名函数可以访问到person window.addAge保存了匿名函数的地址，该匿名函数用来操作person 从而，任何地方都可以通过window.addAge里的方法操作person，但却无法访问到person的详细数据 优化，去除window1234567891011121314151617//赋给全局变量addAgevar addAge = (function()&#123; var person = &#123; name: 'stage', age: 24, &#125; return function ()&#123; person.age++; return person.age; &#125;&#125;)(); //返回一个匿名函数，并赋给全局变量addAge(function()&#123; var newAge = addAge();//执行返回的这个匿名函数 console.log(newAge);&#125;)(); 12345678910111213var person = (function()&#123; return &#123; sayName : function(name)&#123; var _name = name || '无'; return _name; &#125;, sayAge : function(age)&#123; var _age = age || 18; return _age; &#125;, &#125;;&#125;)(); 上面代码可以写成下面这样，这样写可以清楚知道return的内容，但是需要在上面取名字： 12345678910111213141516171819202122 var person = (function()&#123; var _sayName = function(name)&#123; var _name = name || '无'; return _name; &#125;; var _sayAge = function(age)&#123; var _age = age || 18; return _age; &#125;; return &#123; sayName : _sayName, sayAge : _sayAge &#125;&#125;)(); console.log(person.sayName('lucy')); //lucyconsole.log(person.sayName());//无console.log(person.sayAge(20));//20 再看一个例子12345678910111213141516171819202122232425262728293031var person = (function ()&#123; var name, age, sex; return &#123; getName: function()&#123; return name; &#125;, setName: function(newName)&#123; name = newName; &#125;, getAge: function()&#123; return age; &#125;, setAge: function(newAge)&#123; age = newAge; &#125;, getSex: function()&#123; return sex; &#125;, setSex: function(newSex)&#123; sex = newSex; &#125;, &#125;&#125;)();person.setName('王花花');console.log(person.getName());person.setAge(20);console.log(person.getAge());person.setSex('女');console.log(person.getSex()); 面试题正确打印出下标 12345&lt;ul&gt; &lt;li&gt;index 00000&lt;/li&gt; &lt;li&gt;index 11111&lt;/li&gt; &lt;li&gt;index 22222&lt;/li&gt;&lt;/ul&gt; 用闭包： 123456789var oLi = document.getElementsByTagName('ul')[0].children;for (var i = 0; i &lt; oLi.length; i++)&#123; (function(index)&#123; oLi[index].onclick = function()&#123; console.log(index); &#125;; &#125;)(i);&#125; 闭包还有一种写法: 1234567for (var i = 0; i &lt; oLi.length; i++)&#123; oLi[i].onclick = (function(index)&#123; return function()&#123; console.log(index); &#125; &#125;)(i);&#125; 方法三：将下标index作为对象的一个属性，添加到每个数组元素中 123456for (var i = 0; i &lt; oLi.length; i++)&#123; oLi[i].index = i; oLi[i].onclick = function()&#123; console.log(this.index); &#125;;&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC模型视图控制器]]></title>
    <url>%2F2018%2F03%2F27%2FMVC%E6%A8%A1%E5%9E%8B%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[MVC模式一个事件发生的过程（通信单向流动）：1、用户在视图 V 上与应用程序交互2、控制器 C 触发相应的事件，要求模型 M 改变状态（读写数据）3、模型 M 将数据发送到视图 V ，更新数据，展现给用户 MVC模式是什么MVC是一种设计模式它是一种编程思想 Model（模型）- 通常模型对象负责在数据库中存取数据。 View（视图） - 通常视图是将模型里的数据可视化。 Controller（控制器） - 从视图读取数据，控制用户输入，并向模型发送数据。 MVC的步骤原始代码:1234567891011//黏着导航(function() &#123; var topNavbar = document.getElementById('top-navbar'); window.addEventListener('scroll', function() &#123; if (pageYOffset &gt; 0) &#123; topNavbar.classList.add('sticky'); &#125; else &#123; topNavbar.classList.remove('sticky'); &#125; &#125;);&#125;)(); 添加view和controller：1234567891011121314151617181920212223242526272829303132//黏着导航，控制HTML中的top-navbar那么top-navbar就是view(function() &#123; var view = document.querySelector('#top-navbar'); var controller = &#123; view: null ,init: function (view)&#123; this.view = view; this.bindEvents(); //this.bindEvents.call(this) &#125; ,bindEvents: function () &#123; var view = this.view; window.addEventListener('scroll', () =&gt; &#123; //箭头函数没有this if (pageYOffset &gt; 0) &#123; this.sticky(); &#125; else &#123; this.unsticky(); &#125; &#125;); &#125; ,sticky: function()&#123; this.view.classList.add('sticky'); &#125; ,unsticky: function()&#123; this.view.classList.remove('sticky'); &#125; &#125; controller.init(view);&#125;)(); MVC的作用 Model：用来存取数据。所有与服务器交互的操作(存储、获取数据)都放在Model里 View：数据可视化。要将数据展示在哪一块区域就将那一区域作为View。 Controller：处理用户交互的部分。其他所有的操作放在controller里 Controller监听View，当用户点击View，View就会通知Controller Controller接收到通知，就会调用Model Model向服务器请求数据，然后服务端将数据返回给Model Model将从服务器返回的数据传给Controller Controller得到数据后，更新View Controller不直接访问服务器，而是专门由Model来负责]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>MVC模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机专用的自适应方案 - 动态rem]]></title>
    <url>%2F2018%2F03%2F23%2F%E6%89%8B%E6%9C%BA%E7%AB%AF%E5%8A%A8%E6%80%81rem%2F</url>
    <content type="text"><![CDATA[rem不是响应式方案，它只针对手机端一切尺寸以width为基准记得要加上meta:vp使html的 font-size 与 pageWidth 建立联系border和非根元素font-size建议用pxsublime插件：cssrem各家公司的rem方案 做手机端页面的流程首先让设计师给出PC端和手机端的效果图，然后才能开始做。PC端使用float/flex布局，一般定宽min-width:1000px手机端则使用下面的方法↓ 手机端布局的几种方法 宽高写死，body设置width:320px并居中这样在所有的手机上，效果都和在宽度320px的手机上一样 百分比布局，尺寸不写死，用% 但是百分比布局无法知道height，因此设置height:20%无效 整体缩放 rem如果设计稿的宽度640px，其中一个元素尺寸320x320我们希望在宽度320px的手机上，这个元素尺寸是160x160在宽度为414px的手机上，这个元素的尺寸是207x207 什么是动态rem动态rem不是响应式方案，它只适用于手机端，电脑和ipad不适用比如https://h5.m.taobao.com/ 在电脑端打开就会看起来很奇怪 常用尺寸 px：1像素 em：一个汉字的宽度(实际上是一个M的宽度) rem：根元素(html)的font-size的大小 vh：视口高度的1/100，100vh等于整个视口的高度 vw：视口宽度的1/100，100vw等于整个视口的宽度 min-width:无论如何，都不会小于这个宽度max-width:无论如何，都不会比这个宽度大 面试题浏览器默认font-size: 16px;，此时1rem = 16px = 1emchrome默认字号最小只能到12px rem与em的区别123456html&#123; font-size: 20px; //如果不自定义，则默认16px&#125;p&#123; font-size: 2rem; // 40px&#125; 1234p&#123; font-size: 18px; width: 2em; // 36px&#125; rem的使用步骤 添加meta:vp 让html的font-size等于页面宽度 给body添加font:size:16px; border和非根元素font-size建议用px 123456&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt;&lt;script&gt; var pageWidth = document.documentElement.clientWidth; var html = document.documentElement; html.style.fontSize = pageWidth+'px'; //或者pageWidth/10+'px'&lt;/script&gt; 此时，1rem = 页面宽度如果设计稿中，有一个元素宽度是设计稿宽度的40%，高度是设计稿宽度的20%,margin是设计稿宽度的5%那么这个元素width:0.5rem，height:0.25rem，margin:0.05rem拖动改变宽度，然后点击“run with js”查看效果 优化html.style.fontSize = pageWidth/10+&#39;px&#39;;这样1rem = 页面宽度的十分之一如果设计稿中，有一个元素宽度是设计稿宽度的40%，高度是设计稿宽度的20%,margin是设计稿宽度的5%那么这个元素width:5rem，height:2.5rem，margin:0.5rem注意，font-size不能是页面宽度的1/100,因为浏览器最小字号限制12px，假设页面宽度360px，那么字号是3.6px，会有bug border和非根元素font-size建议用px px2rem用Less将px自动转成rem假设1rem = 页面宽度的十分之一,那么123456789101112//Less:@design:640; //设计稿的宽度@px2rem: (1/@design)*10rem; //乘以10是因为页面宽度的十分之一div &#123; wifth:320*@px2rem;&#125;//css结果：div &#123; wifth: 5rem;&#125;]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
        <tag>css</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime使用技巧]]></title>
    <url>%2F2018%2F03%2F23%2Fsublime%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[sublime快捷键常用插件snippet的使用 常用插件emmet前身是zencoding，作为前端界最出名（我觉得没有之一）的插件，几乎是可以稳定的提升50%的书写效率，用得多了以后的后遗症就是，好多CSS属性本来的拼法都记不清了。 emmet使用技巧 lorem可以打出一长串无意义字符串 lorem4可以打出4个字符串 jQuery主要是用来直接调出AJAX语法块，以及绑定事件响应。 SublimeGit好用到哭的git插件，妈妈再也不用担心我改出bug无法回滚了。几年前一个前辈教导我说，哪怕不做开源，自建一个本地仓库用git来管理代码也是很有必要的。一方面是能够控制代码版本，出了问题可以分步回滚，另一方面也是有一个task的概念，培养自己把软件开发任务做粒度的划分，便于估计自己的开发能力，预估工期。 JsFormat作为一个上升处女座的程序员，难以忍受凌乱的格式，更加难以忍受按无数次tab对齐代码，JsFormat可以格式化HTML，CSS和js代码。不过在写react的时候遇到很麻烦，你们懂的。目前还没有找到可以把react代码格式化做的很漂亮的插件。 CSSREMsublime px转rem插件：cssrem 快捷键 Esc ： 关闭搜索框，命令框等 Ctrl+D：选择单词，重复可增加选择下一个相同的单词 Alt+F3：一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中所有相同的变量名、函数名等。 Ctrl+P,搜索侧边栏中的文件名 shift+end ： 选择行，从光标当前所在位置开始选中到行尾 Ctrl+L：选择整个行，重复可依次增加选择下一行 shift+home ： 从光标当前所在位置开始选中到行首 Ctrl+Shift+M ：选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。 Ctrl+M ：：光标移动至括号内结束或开始的位置。 Ctrl+F :打开底部搜索框，查找关键字。 Ctrl+shift+F :在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。 Ctrl+P :打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl+G :打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 Ctrl+R: 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl+: :打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 ctrl+alt+ ↓ ： 光标选择多行进行编辑(比如可以给多行前面添加-) Ctrl+J：合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。 Ctrl+G：跳转到第几行 Ctrl+W：关闭当前打开文件 Ctrl+F：查找内容 Ctrl+/：用//注释当前行 Ctrl+Shift+/ : 用/**/注释多行 ctrl+shift+enter： 在上一行插入新行 ctrl+[ ： 收起代码段 ctrl+] : 展开代码段 Ctrl+X ： 剪切 shift+ → ： 右移并选中 Shift+ ↑ ： 上移并选中 ctrl+shift+ → ： 光标按\w规则跳跃移动 alt+ → ： 光标按单词移动 alt+shift+ → ： 按单词移动并选择 home : 光标移到行首 end ： 光标移到行尾 ctrl+home ： 滚到文件最前面 ctrl+end ： 滚到文件最后面 Ctrl+Shift+上下键：整行移动交换位置 Ctrl+Shift+Y：选中计算表达式后按这个快捷键可以计算出结果 snippet点击工具 &gt; 插件开发 &gt; 新建代码片段 就可以创建一个新的snippet 在线生成工具：https://snippets.now.sh/1234567891011&lt;snippet&gt;&lt;!-- $&#123;1&#125;代表的是第一个光标位置，代码片会默认选中this，当按下tab之后，会选中$&#123;2&#125;中的snippet --&gt; &lt;content&gt;&lt;![CDATA[Hello, $&#123;1:this&#125; is a $&#123;2:snippet&#125;.]]&gt;&lt;/content&gt; &lt;!-- 设置关键词↓ --&gt; &lt;!-- &lt;tabTrigger&gt;hello&lt;/tabTrigger&gt; --&gt; &lt;!-- 设置生效的语言环境text.html,source.css,source.js --&gt; &lt;!-- &lt;scope&gt;source.js&lt;/scope&gt; --&gt;&lt;/snippet&gt;]]></content>
      <categories>
        <category>sublime</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[封装$.ajax]]></title>
    <url>%2F2018%2F03%2F22%2F%E5%B0%81%E8%A3%85ajax%2F</url>
    <content type="text"><![CDATA[ajax设置请求头的四部分ajax获取响应头的四部分封装$.ajax使用ES6解构赋值进行优化Promise的使用 头headers的4部分 请求头Request Headers请求头Request Headers的4部分：123451 GET /data.json HTTP/1.1 //动词 路径 协议/版本2 Host: 127.0.0.1:80802 Content-Type: application/x-www-form-urlencoded4 要上传的数据 响应头Response Headers响应Response Headers的4部分：123456781 HTTP/1.1 200 OK2 Content-Length: 24432 Content-Type: text/html2 Date: Tue, 10 Oct 2017 09:14:05 GMT2 Last-Modified: Mon, 23 Jan 2017 13:24:45 GMT4 &lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; 后面太长，省略了…… ajax操作第一部分设置请求用xhr.open()设置第一部分的请求方式和路径1操作第一部分 xhr.open('GET', '/data.json', true); 获取响应123xhr.status // 获取状态码，比如200xhr.statusText // 状态码对应的英文解释 比如200表示OK// 200 OK ajax操作第二部分设置请求用POST发送请求时，必须设置content-type用xhr.setHeader()设置第二部分设置请求头时，必须在xhr.send()之前设置123操作第一部分 xhr.open('post', '/xxx', true);操作第二部分 xhr.setHeader('content-type','x-www-form-urlencoded');操作第四部分 xhr.send(); 获取响应123xhr.getResponseHeader('content-type') // x-www-form-urlencodedxhr.getResponseHeader('content-length')xhr.getAllResponseHeaders() //获得所有的第二部分(请求头) ajax操作第四部分设置请求在用POST发送请求时，用xhr.send()可以设置第四部分将数据传给后端1操作第四部分 xhr.send('username=stage&amp;age=24'); 获取响应1xhr.responseText; 封装$.ajax123456789101112131415161718192021222324window.$.ajax(&#123; method: 'get' ,url: 'php.php' ,data: 'fname=stage&amp;age=24' //用for-in遍历↓ ,headers: &#123; 'content-type': 'application/x-www-form-urlencoded', test: 89 &#125; ,success: function (xhr)&#123;console.log(JSON.parse(xhr.responseText));&#125; ,fail: function (xhr) &#123; f1(xhr); f2(xhr); &#125;&#125;);&#125;function f1(xhr) &#123;console.log(xhr.status);&#125;function f2(xhr) &#123;console.log(xhr.statusText);&#125; 12345678910111213141516171819202122232425262728293031323334window.jQuery = &#123;&#125;;window.jQuery.ajax = function (options)&#123; var method = options.method; var url = options.url; var data = options.data; var success = options.success; var fail = options.fail; var headers = options.headers; /* 上面代码可以用ES6解构赋值（解析结构然后赋值）来进行优化 window.jQuery.ajax = function (&#123;method, url ,data, headers, success, fail&#125;)&#123; */ var xhr = new XMLHttpRequest(); xhr.open(method, url, true); for (var key in headers) &#123; xhr.setRequestHeader(key, headers[key]); &#125; xhr.onreadystatechange = function() &#123; if (this.readyState === 4) &#123; if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) &#123; success(xhr); &#125; else &#123; fail(xhr); &#125; &#125; &#125;; xhr.send(data);&#125;window.$ = window.jQuery; ES6解构赋值的用法交换a和b的值12345let a = 1;let b = 2;[a,b] = [b,a];a // 2b // 1 问题是每个程序员的回调名不一样，我们无法知道成功函数和失败函数的具体名字，也许别的程序员取名叫done和error呢 Promise 解决了这个问题 用Promise进行优化JavaScript Promise 对象 语法：return new Promise(function (resolve, reject){ 代码 } 用Promise之后，就不需要给success和fail这两个回调函数取名字了1234567891011121314window.$.ajax(&#123; method: 'get' ,url: 'php.php' ,data: 'fname=stage&amp;age=24' ,headers: &#123; 'content-type': 'application/x-www-form-urlencoded', test: 89 &#125;&#125;).then( //不需要取名字了，成功时执行第一个函数，失败时执行第二个函数 xhr =&gt; &#123;console.log('success');console.log(JSON.parse(xhr.responseText));&#125;, xhr =&gt; &#123;console.log('fail');console.log(xhr.status);&#125; ); 12345678910111213141516171819202122232425window.jQuery = &#123;&#125;;window.jQuery.ajax = (&#123;method, url ,data, headers&#125;/*es6解构赋值*/) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123;//如果一切都正常，则调用 resolve解析，否则调用 reject拒绝 const xhr = new XMLHttpRequest(); xhr.open(method, url, true); for (let key in headers) &#123; xhr.setRequestHeader(key, headers[key]); &#125; xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 400) &#123;//用了箭头函数，this就不是xhr了，而是window resolve(xhr); //不需要取名字success了 &#125; else &#123; reject(xhr); //不需要取名字fail了 &#125; &#125; &#125;; xhr.send(data); &#125;);&#125;window.$ = window.jQuery; Promise总结原始函数1$.ajax(&#123;success:fn1, fail:fn2&#125;); Promise方法：123$.ajax().then(fn1, fn2);//成功则调用fn1，失败调用fn2$.ajax().then(fn1).then(fn3); //fn1调用完后，再调用fn3]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
        <tag>ajax</tag>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax,jsonp]]></title>
    <url>%2F2018%2F03%2F21%2Fajax%2Cjsonp%2F</url>
    <content type="text"><![CDATA[阮一峰：浏览器同源政策及其规避方法同源政策:同协议、同域名、同端口阮一峰：ajax教程ajax用XMLHttpRequest向后端发送请求，但是AJAX无法跨源json语法；通过JSON.parse(string)将后端返回的字符串转换成JS对象jsonp动态添加script标签实现跨域请求，但jsonp只能发送GET请求CORS跨域，支持所有请求 jsonJSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）JSON 使用 Javascript语法来描述数据对象 JS 是一门语言，JSON 是另一门语言 json这门语言是道格拉斯抄袭js的语言 JSON 使用 Javascript语法来描述数据对象 道格拉斯还写了本《javascript语言精粹》，俗称蝴蝶书，来吐槽js中垃圾的地方 json铁轨图http://json.org json语法json里的【字符串】必须用双引号，不能用单引号！！json没有undefined和function| js数据 | json数据 || :—-: |:———:|| 123| 123 || ‘stage’| “stage” || true| true || [‘a’, ‘b’] | [“a”, “b”] || {name: ‘stage’} | {“name”: “stage”} || null | null || undefined| json没有undefined || function fn(){}| json没有function | 浏览器同源策略 同协议 同域名 同端口 举例来说，http://www.example.com/d/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口80可以省略）。12345http://www.example.com/d2/other.html // 同源http://example.com/d/other.html // 不同源（域名不同）http://v2.www.example.com/d/other.html // 不同源（域名不同）http://www.example.com:81/d/other.html // 不同源（端口不同）https://www.example.com // 不同源（协议不同） 不刷新页面，使用xhr发送请求局部更新数据：AJAXAJAX - 异步的 JavaScript 和 XMLAJAX就是使用XMLHttpRequest技术向服务端发送请求AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 使用 XMLHttpRequest 发请求 服务器返回 JSON 格式的字符串(后来人们不用XML，改用JSON了) JS 解析 JSON(通过JSON.parse(字符串) 将JSON格式的字符串转成JS对象)，并更新局部页面1234567891011121314var xhr = new XMLHttpRequest();xhr.open('GET', '/', true);xhr.send();xhr.onreadystatechange = function() &#123; if (this.readyState == 4) &#123; if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) &#123; // 成功! var string = this.responseText; var obj = JSON.parse(string); &#125; else &#123; // 失败 _(:з」∠)_ &#125; &#125;&#125;; AJAX无法跨域同源政策规定，AJAX请求只能发给同源的网址，否则就报错。只有 协议 + 域名 + 端口 完全一模一样才能发AJAX请求12http://www.baidu.com 不可以向 http://baidu.com 发AJAX请求http://www.baidu.com:80 不可以向 http://www.baidu.com:81 发AJAX请求 如何解决AJAX无法跨域的问题？↓↓↓ 跨域方法：jsonp由于同源策略，我们无法从别的域名(网站)那获取数据，用jsonp可以解决这个问题。JsonP(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取数据，即跨域读取数据。它的基本思想是，网页通过动态添加&lt;script&gt;标签，&lt;script&gt;标签的src向跨域服务器请求JSON数据，同时传一个查询参数callback=随机名&amp;时间戳,这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。1234567891011121314151617181920function addScriipt(src) &#123; var script = document.createElement('script'); script.setAttribute("type","text/javascript"); script.src = src; document.body.appendChild(script); script.onload = function(ev)&#123; this.parentNode.removeChild(this);; //删除script标签 &#125;&#125;window.onload = function () &#123; addScriipt('http://example.com/ip?callback=JQuery173625173837');&#125;function JQuery173625173837(data) &#123;//服务器收到这个请求以后，会将数据放在回调函数的参数位置(data)返回。 console.log('你的ip地址是: ' + data.ip);&#125;;//后端：$&#123;callback&#125;(&#123;"ip": "8.8.8.8"&#125;); 上面代码通过动态添加&lt;script&gt;标签，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字(一般用随机数),这对于JSONP是必需的。此外还需要加一个时间戳，防止浏览器的缓存。 由于&lt;script&gt;标签请求的脚本会直接作为代码运行。这时，只要浏览器定义了名字为随机数的函数，该函数就会立即调用。于是请求方就能获得他要的数据。 jsonp面试题 什么是jsonp JSONP(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取数据，即跨域读取数据。它的基本思想是： 网页通过动态添加&lt;script&gt;标签，&lt;script&gt;标签的src向服务器请求数据，同时传一个查询参数callback=随机名&amp;时间戳给服务器,这种做法不受同源政策限制 服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 由于&lt;script&gt;标签请求的脚本会直接作为代码运行。这时，只要浏览器定义了对应名字的函数，该函数就会立即调用。 于是请求方就能获得他要的数据。 jsonp为什么不支持post方法 因为jsonp是通过动态创建&lt;script&gt;标签实现的，而script只能通过GET请求数据，不能POST 由于jsonp只能发GET请求，于是又有了CORS跨域↓↓↓ CORS跨源AJAX请求CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨域AJAX请求的根本解决方法。CORS允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。相比JSONP只能发GET请求，CORS允许任何类型的请求。 123后端程序员加上这句响应头：response.setHeader('Access-Control-Allow-Origin', 'http://stage.com:8000')告诉浏览器，http://stage.com:8000可以向我方服务器发送ajax请求 chrome调试在用submit提交数据时，页面会刷新，因此：chrome开发者工具 → Network → Network → 点击preserve log(页面刷新时不清楚日志)]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
        <tag>ajax</tag>
        <tag>json</tag>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 期中考试]]></title>
    <url>%2F2018%2F03%2F18%2F%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[link标签的media属性script标签的charset属性使用svg标签画图 请写出一个符合 W3C 规范的 HTML 文件要求： 页面标题为「我的页面」 页面中引入了一个外部 CSS 文件，文件路径为 /style.css 页面中引入了另一个外部 CSS 文件，路径为 /print.css，该文件仅在打印时生效 页面中引入了另一个外部 CSS 文件，路径为 /mobile.css，该文件仅在设备宽度小于 500 像素时生效 页面中引入了一个外部 JS 文件，路径为 /main.js 页面中引入了一个外部 JS 文件，路径为 /gbk.js，文件编码为 GBK 页面中有一个 SVG 标签，SVG 里面有一个直径为 100 像素的圆圈，颜色随意12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;我的页面&lt;/title&gt; &lt;link rel="stylesheet" href="style.css"&gt; &lt;link media="print" rel="stylesheet" href="print.css"&gt; &lt;link media="all and (max-width:500px)" rel="stylesheet" href="mobile.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;svg version="1.1" baseProfile="full" width="200" height="200" xmlns="http://www.w3.org/2000/svg"&gt; &lt;circle cx="100" cy="100" r="100" fill="green" /&gt;&lt;/svg&gt; &lt;script src="main.js"&gt;&lt;/script&gt;&lt;script charset="GBK" src="gbk.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 移动端是怎么做适配的？2016年腾讯前端面试题：移动端是怎么做适配的？ 回答要点： meta viewport 媒体查询（教程） 动态 rem 方案（教程） 使用meta标签的viewport能优化移动浏览器的显示 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; 使用媒体查询可以针对不同的媒体类型定义不同的样式。举个例子：如果浏览器窗口小于 500px, 就让背景变为蓝色：1234567&lt;style&gt;@media all and (max-width: 500px) &#123; body &#123; background-color: blue; &#125;&#125;&lt;/style&gt; 你也可以利用link标签的media属性，针对不同的媒体使用不同的样式表 :&lt;link media=&quot;all and (max-width:500px)&quot; rel=&quot;stylesheet&quot; href=&quot;mobile.css&quot;&gt; 动态rem方案通过js，动态设置html的font-size，让它的字号与页面宽度建立联系(比如html的字号等于页面宽度的十分之一)12345&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt;&lt;script&gt; var pageWidth = document.documentElement.clientWidth; document.documentElement.style.fontSize = pageWidth/10+'px';&lt;/script&gt; 此时，1rem就等于页面宽度的十分之一 css3圆角矩形和阴影怎么做?2017年腾讯前端实习面试题（二面）：用过CSS3吗? 实现圆角矩形和阴影怎么做?12345圆角矩形：border-radius 阴影分为盒子阴影和文字阴影:盒子阴影：box-shadow文字阴影：text-shadow 什么是闭包，闭包的作用是什么？2017年腾讯前端实习面试题（二面）：什么是闭包，闭包的用途是什么？123456(function ()&#123; var local = '变量'; function fn()&#123; console.log(local); &#125;&#125;)(); 「函数」和「函数内部能访问到的变量」的总和，就是一个闭包。上面代码中的函数fn，它里面可以访问到 local 变量，那么函数fn和local变量形成一个闭包。 闭包的作用是用来「间接访问一个变量」。利用闭包可以将函数内部的变量传递到外部，从而实现在外部访问另一个函数内部的局部变量。 call、apply、bind 的用法分别是什么？2017年腾讯前端实习面试题（二面）：call、apply、bind 的用法分别是什么？利用call、apply、bind这三个方法，可以改变this的指向，使它指向我们期望的对象。123var n = 123;var o =&#123;n: 234&#125;;function a() &#123;console.log(this.n)&#125;; call:格式fn.call(thisValue, arg1, arg2, ...)第一个参数是this要指向的那个对象，后面的参数是调用时所需要的参数用法123456a.call() //123a.call(null) //123a.call(undefined) //123a.call(window) //123a.call(o) //234可以看到，如果call方法没有参数，或者参数为null或undefined，则this指向全局对象 call()方法可以传递两个参数。第一个参数是指定函数内部中this的指向（也就是函数执行时所在的作用域），第二个参数是函数调用时需要传递的参数。1234function add(a, b) &#123; console.log(a + b); &#125;add.call(null, 1, 2); //3 第一个参数是必须的，可以是null，undefined，this，但是不能为空。设置为null，undefined，this表明函数add此时处于全局作用域。第二个参数中必须一个个添加。而在apply中必须以数组的形式添加。 apply方法与call方法类似，使用格式如下：func.apply(thisValue, [arg1, arg2, ...])apply方法的第一个参数也是this所要指向的那个对象，如果没有第一个参数，或者设为null或undefined，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。用法12345a.apply() // 123a.apply(null) //123a.apply(undefined) //123a.apply(window) //123a.apply(o) //234 call的第二部分参数要一个一个传，apply要把这些参数放到数组中。这就是他们的区别，真的就这么点区别！！！12345function add(a, b) &#123; console.log(a + b); &#125; add.call(null, 2, 3); //5 add.apply(null, [2, 3]); //5 然后，不得不说的一点：它们的第二个参数都可以传arguments。 bind()和call与apply不同。bind方法用于指定函数内部的this指向（执行时所在的作用域），然后返回一个新函数。bind方法并非立即执行一个函数。call和apply方法都是在调用之后立即执行的。而bind调用之后返回一个函数，需要再调用一次才行 格式：fn.bind(thisValue, arg1, arg2, ...]) 用法123456a.bind() //返回一个改变了上下文的函数a.bind()(); // 123a.bind(null)(); // 123a.bind(undefined)(); // 123a.bind(window)(); // 123a.bind(o)(); // 234 同样，我们也可以给bind方法传递参数，第一个参数如果为null或者undefined，会将函数内部的this对象指向全局环境；第二个为调用时需要的参数，并且传递参数的形式与call方法相同,一个一个传入。1234567function add(a, b) &#123;return a + b;&#125;console.log(add.apply(null,[1,4])); //5console.log(add.call(null,1,4)); //5console.log(add.bind(null, 1, 4)); //add()console.log(add.bind(null, 1, 4)()); //5 bind方法除了绑定this以外，还可以绑定原函数的参数12345678910111213var add = function (x,y) &#123; return x*this.m + y*this.n;&#125;var obj = &#123; m: 2, n: 2&#125;;var newAdd = add.bind(obj, 5);//add()函数的第一次参数x绑定为5,如果给了两个参数，则同时给定了x、y的值newAdd(3); //16 add()函数的参数y绑定3等同于add.bind(obj)(5,3) 找出数组最大元素123var a = [2, 4, 5, 7, 8, 10];console.log(Math.max.apply(null, a)); //10console.log(Math.max.call(null,2, 4, 5, 7, 8, 10)); //10 将数组里的空元素变为undefined通过apply方法，利用Array构造函数将数组的空元素变成undefined。1console.log( Array.apply(null, [1, , 3])); // [1, undefined, 3] 空元素和undefined的差别在于，数组的foreach方法会跳过空元素，但是不会跳过undefined，因此遍历内部元素的时候，会得到不同的结果1234567var a = [1, , 3]; a.forEach(function(index) &#123; console.log(index); //1,3 ，跳过了空元素。 &#125;) Array.apply(null,a).forEach(function(index)&#123; console.log(index); ////1,undefined,3 ，将空元素设置为undefined &#125;) 类数组变成数组利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。被处理的对象必须有length属性，以及相对应的数字键。12345678Array.prototype.slice.apply(&#123;0:1,length:1&#125;)// [1]Array.prototype.slice.apply(&#123;0:1&#125;)// []Array.prototype.slice.apply(&#123;0:1,lengt:2&#125;)// [1, undefined]Array.prototype.slice.apply(&#123;length:1&#125;)// [] 总结call，apply，bind方法的联系和区别 第一个参数都是指定函数内部中this的指向（函数执行时所在的作用域），然后根据指定的作用域，调用该函数。 都可以在函数调用时传递参数。call，bind方法需要直接传入，而apply方法需要以数组的形式传入。 call，apply方法是在调用之后立即执行函数，而bind方法没有立即执行，需要将函数再执行一遍。有点闭包的味道。 改变this对象的指向问题不仅有call，apply，bind方法，也可以使用that变量来固定this的指向。1234567891011var a = 1;var b = 2;var obj=&#123;a:3, b:4&#125;;function add(x,y)&#123; return this.a*x + this.b*y;&#125;add(5,6); // 1*5+2*6=17add.call(null,5,6) // 1*5+2*6=17, this指向windowadd.call(obj,5,6) // 3*5+4*6=39 ,this指向objadd.apply(obj,[5,6]) // 3*5+4*6=39 ,this指向obj，apply的参数以数组形式传入add.bind(obj,5,6)() // 3*5+4*6=39 ,this指向obj，bind方法并非立即执行一个函数，需要再次调用 HTTP 状态码2017年腾讯前端实习面试题（二面）：请说出至少 8 个 HTTP 状态码，并描述各状态码的意义。参考菜鸟教程资料：http://www.runoob.com/http/http-tutorial.html1234567891011121314151617200 OK:请求成功201 created:已创建。成功请求并创建了新的资源。一般POST时返回该状态码301 Moved Permanently:请求的资源(网页)已被永久的转移到其他URI302 Found:请求的资源被临时移走了304 未修改Not Modified：所请求的资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。服务器返回此状态码时不会返回任何资源。400：无法找到请求的资源。401：访问资源的权限不够。 一般登陆时用户名和密码不对会返回401404 Not Found ：请求的资源(网页)不存在。403 Forbidden ：没有权限访问资源。405：需要访问的资源被禁止。407：访问的资源需要代理身份验证。414：请求的URL太长。500 Internal Server Error：服务器内部错误，无法完成请求502 Bad Gateway ：充当网关或代理的服务器，从远端服务器接收到了一个无效的请求（比如服务器关了） HTTP post 请求的4部分2017年腾讯前端实习面试题（二面）：请写出一个 HTTP post 请求的内容，包括四部分。其中第四部分的内容是 username=ff&amp;password=123第二部分必须含有 Content-Type 字段请求的路径为 /path参考菜鸟教程资料：http://www.runoob.com/http/http-tutorial.html1234567POST /path HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.54.0Accept: */*Content-Type: application/x-www-form-urlencodedusername=ff&amp;password=123 说出三种排序请说出至少三种排序的思路，这三种排序的时间复杂度分别为 O(n²) O(n log2 n) O(n + max) https://blog.csdn.net/gane_cheng/article/details/52652705https://blog.csdn.net/supercoooooder/article/details/52153923https://www.cnblogs.com/Unknw/p/6346681.htmlhttp://bubkoo.com/2014/01/17/sort-algorithm/archives/ 冒泡排序 O(n²)原理：对数组进行遍历，相邻元素根据大小进行交换，每次遍历将最小值推至最前方，然后对剩下的值再次进行比较以数组 arr = [5, 1, 4, 2, 8] 为例说明，加粗的数字表示每次循环要比较的两个数字： 第一次外循环 ( 5 1 4 2 8 ) → ( 1 5 4 2 8 )， 5 &gt; 1 交换位置( 1 5 4 2 8 ) → ( 1 4 5 2 8 )， 5 &gt; 4 交换位置( 1 4 5 2 8 ) → ( 1 4 2 5 8 )， 5 &gt; 2 交换位置( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 5 &lt; 8 位置不变 第二次外循环（除开最后一个元素8，对剩余的序列） ( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 1 &lt; 4 位置不变( 1 4 2 5 8 ) → ( 1 2 4 5 8 )， 4 &gt; 2 交换位置( 1 2 4 5 8 ) → ( 1 2 4 5 8 )， 4 &lt; 5 位置不变 第三次外循环（除开已经排序好的最后两个元素，可以注意到上面的数组其实已经排序完成，但是程序本身并不知道，所以还要进行后续的循环，直到剩余的序列为 1） ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )( 1 2 4 5 8 ) → ( 1 2 4 5 8 ) 第四次外循环（最后一次）( 1 2 4 5 8 ) → ( 1 2 4 5 8 ) 快速排序 O(n log2 n)原理：从数组中取一个值为基准值，并将剩下的值与之比较，小于基准值的放到左边，大于基准值的放到右边，并再次对左右两边进行快速排序，直至左右两边只剩一个元素。以数组 arr = [5, 2, 1, 4, 8, 6] 为例取第一个数5为基准值，小于基准值的数放在基准值左边，大于基准值的数放在右边123 基准值 ↓2 1 4 [5] 8 6 然后分别对左右两边进行快速排序，左边以第一个数2为基准值，右边以第一个数8为基准值123左基准值 右基准值 ↓ ↓1 2 4 [5] 6 8 当左右基准值的两边都只剩一个元素时，快排结束。 桶排序 O(n + max) 【计数排序也是O(n + max)，max表示桶的数量】原理：将数组分到有限数量的桶里，然后对每个桶再分别排序（有可能再使用别的排序算法），最后将各个桶中的数据有序的合并起来。以数组 array = [29, 25, 3, 49, 9, 37, 21, 43]为例，数组中最大数为 49，先设置 5个桶，然后分别将这些数放入自己所属的桶12345第1个桶的范围 0~9: 3, 9第2个桶的范围 10~19:第3个桶的范围 20~29: 29, 25, 21第4个桶的范围 30~39: 37第5个桶的范围 40~49: 49, 43 然后，分别对每个桶里面的数进行排序12345第1个桶的范围 0~9: 3, 9第2个桶的范围 10~19:第3个桶的范围 20~29: 21, 25, 29第4个桶的范围 30~39: 37第5个桶的范围 40~49: 43, 49 最后，将各个桶中的数据有序的合并起来13, 9, 21, 25, 29, 37, 43, 49 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？这一题是在挖掘你的知识边界，所以你知道多少就要答多少。可以先查阅一些资料再查，但是不要把自己不懂的东西放在答案里，面试官会追问的。答： 输入URL地址 浏览器根据域名查找对应的 IP 地址(比如www.baidu.com（百度域名） 的其中一个IP地址是 220.181.112.244) 建立连接 —— TCP三次握手知道了服务器的 IP 地址，下面便开始与服务器建立TCP连接了。建立需要经历以下三个过程：浏览器向服务器发送一个建立连接的请求（你好，我可以连你吗？）；服务器接到请求后发送同意连接的信号（好的，你来连我吧）；浏览器接到同意连接的信号后，再次向服务器发送了确认信号（那我连你咯！），自此，浏览器与服务器两者建立了连接。 当服务器与浏览器建立了连接之后，浏览器向 web 服务器发送一个 HTTP 请求4.1 请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空）4.2 第三部分永远都是一个回车4.3 第4部分是要上传的数据4.4 第 2 部分中的 Content-Type 标注了第 4 部分的格式 12345671 POST / HTTP/1.12 Host: www.baidu.com2 User-Agent: curl/7.54.02 Accept: */*2 Content-Type: application/x-www-form-urlencoded3 4 1234567890 服务器处理请求 服务器返回一个 HTTP 响应，响应由4部分组成6.1 第1部分表示 协议/版本号 状态码 状态解释6.2 第 2 部分中的 Content-Type 标注了第 4 部分的格式6.3 第3部分永远是个回车6.4 第4部分是要下载的HTML文件内容 1234561 HTTP/1.1 200 OK2 Content-Type: text/html2 Content-Length: 1793134 &lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; 后面太长，省略了…… 服务器将 HTML 文件发送给浏览器 浏览器开始加载、解析、渲染 HTML8.1 加载：浏览器对一个html页面的加载顺序是从上而下的，并在加载过程并行进行解析渲染处理。8.2 浏览器发送静态资源请求:在加载过程中遇到link标签、image标签、script标签时，浏览器会再次向服务器发送请求获取css文件、图片资源、js文件，并执行js代码，同步进行加载解析8.3 浏览器发送异步请求（Ajax）8.4 解析、渲染： 解析的过程，其实就是生成dom树。dom树是由dom元素及属性节点组成，加上css解析的样式和js解析后的动作实现。而渲染，就是将DOM树进行可视化表示。下一步就来到了绘制网页的工作阶段 浏览器通过上面步骤计算得到渲染树，构建渲染树使页面以正确的顺序绘制出来，经过一系列的渲染工作，最终完成了页面展示 断开连接 —— TCP三次挥手○ 主机向服务器发送一个断开连接的请求（你把我断开吧）；○ 服务器接到请求后发送确认收到请求的信号（知道了）；○ 服务器向主机发送断开通知（那我断开咯？）；○ 主机接到断开通知后断开连接并反馈一个确认信号（嗯，你断开吧），服务器收到确认信号后断开连接；为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所以服务器先发送确认信号，等所有数据发送完毕后再同意断开。 What really happens when you navigate to a URL知乎：从输入 URL 到页面加载完成的过程中都发生了什么 如何实现数组去重？假设有数组 arr = [1,5,2,3,4,2,3,1,3,4]你要写一个函数 unique，使得unique(arr) 的值为 [1,5,2,3,4]也就是把重复的值都去掉，只保留不重复的值。要求： 不要做多重循环，只能遍历一次 请给出两种方案，一种能在 ES 5 环境中运行，一种能在 ES 6 环境中运行（提示 ES 6 环境多了一个 Set 对象）123456789101112131415161718192021222324ES5:function unique(arr)&#123; return arr.filter(function (value, index) &#123; return arr.indexOf(value) === index; &#125;);&#125;//上面的方法不满足要求，因为filter和indexOf算作两次遍历//更新如下方法↓function unique(arr)&#123; var hash=[]; for (var i = 0; i &lt; arr.length; i++) &#123; if(hash.indexOf(arr[i])==-1)&#123; hash.push(arr[i]); &#125; &#125; return hash;&#125;ES6:function unique4(arr)&#123; return [...new Set(arr)];&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>css</tag>
        <tag>html</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件]]></title>
    <url>%2F2018%2F03%2F17%2F%E4%BA%8B%E4%BB%B6%2C%E5%86%92%E6%B3%A1%2C%E6%8D%95%E8%8E%B7%2F</url>
    <content type="text"><![CDATA[DOM事件addEventListener()捕获和冒泡 DOM事件(默认冒泡)在 W3C 2 级 DOM 事件（DOM Level 2）中规范了事件模型。 面试题-事件如何触发函数事件通常与函数结合使用，下面哪种写法可以正确调用函数(方法)1234567&lt;div id="x" onclick="myFn"&gt;&lt;/div&gt; // ×&lt;div id="y" onclick="myFn()"&gt;&lt;/div&gt; // √&lt;div id="z" onclick="myFn.call()"&gt;&lt;/div&gt; // √x.onclick = myFn; // √x.onclick = myFn(); // × undefined，因为myFn()没有写return，则默认return undefinedx.onclick = myFn.call(); // × addEventListener()方法http://www.runoob.com/jsref/met-element-addeventlistener.html 如果一个对象绑定了多个click事件，那么就得用addEventListener()方法语法：ele.addEventListener(‘click’, myFn, 在捕获or冒泡阶段执行)，默认参数空或者false表示冒泡执行监听的事件绑定一个队列，队列里按顺序排列着函数(方法) 绑定多个事件1234567btn.onclick = myFn1;btn.onclick = myFn2;//myFn2的结果会覆盖myFn1btn.addEventListener("click", myFn1);btn.addEventListener("click", myFn2);//事件监听可以实现同一个对象绑定多个同样的事件执行不同的函数 addEventListener()里面是个队列，只有当事件发生时才会执行里面的函数**123456789101112131415161718function a()&#123; console.log('a');&#125;function b()&#123; console.log('b');&#125;function c()&#123; console.log('c');&#125;btn.addEventListener("click", a);btn.addEventListener("click", b);btn.removeEventListener("click", a);btn.addEventListener("click", c);btn.removeEventListener("click", c);//最终在这个队列里只剩下函数b因此，点击按钮后只打印出 'b' jquery的.one()方法原理123456function fn()&#123; console.log(1); btn.removeEventListener('click', fn);&#125;btn.addEventListener('click', fn); 冒泡 vs 捕获http://www.runoob.com/js/js-htmldom-eventlistener.html 先捕获，后冒泡，默认队列里的函数全部放在冒泡阶段执行 冒泡：点击最内层元素后，最内层元素的事件先触发，接着触发中层元素的事件，最后触发最外层的事件。捕获：点击最内层元素后，最外层元素的事件先触发，接着触发中层元素的事件，最后触发内层的事件。1234567891011结构a&gt;b&gt;cx.addEventListener('click', a);y.addEventListener('click', b);z.addEventListener('click', c);//点击c，默认打印出c,b,ax.addEventListener('click', a,true);y.addEventListener('click', b);z.addEventListener('click', c);//点击c,打印出a,c,b 默认冒泡阶段执行队列里的函数 当设置a的捕获为true时，a队列在a的捕获阶段执行于是先执行a队列里的函数，然后执行c，最后执行b 面试题-捕获冒泡顺序原则上，先捕获，后冒泡，函数(方法)队列在冒泡阶段执行但是1234567结构a&gt;b&gt;cz.addEventListener('click', fn冒泡,false);z.addEventListener('click', fn捕获,true);// 先执行fn冒泡，再执行fn捕获同一个元素，既有捕获，又有冒泡时，按照代码书写顺序执行 取消冒泡http://caibaojian.com/javascript-stoppropagation-preventdefault.html1ev.stopPropagation() 阻止默认行为1ev.preventDefault() 事件传播顺序]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 ES6基础知识点]]></title>
    <url>%2F2018%2F03%2F16%2FES6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[字符串 =&gt; 模板字符串 字符串模板字符串123let a = world;let str = `hello $&#123;a&#125;`;console.log(str); // "hello world" 模板字符串甚至可以调用函数。1234function fn() &#123; return "World";&#125;`hello $&#123;fn()&#125;`; //"hello world" 将数组变成字符串12var arr = [1,2,3];var str = `$&#123;arr&#125;`; //'1,2,3' 构赋值对象的解构赋值123let &#123; foo, bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb" 123456var hash=&#123;name:'stage',city:'shanghai'&#125;let &#123;name,city&#125;=hash; //name等于hash里的name，city等于hash里的city等同于var name = hash['name'];var city = hash['city']; 12345678910111213var url = response.config.url;var data = response.config.data;等同于let &#123;config:&#123;url,data&#125;&#125; = response;如果function (response)&#123; xxx&#125;则形参可以直接替换成function (&#123;config:&#123;url,data&#125;&#125;)&#123; xxx&#125; 函数形参的解构赋值1234567891011function user(data)&#123; var name = data.name; var age = data.age; console.log(name,age)&#125;user(&#123;name:'stage',age:24&#125;)等同于function user(&#123;name,age&#125;)&#123; console.log(name,age)&#125;user(&#123;name:'stage',age:24&#125;)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>es6</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery版的轮播图]]></title>
    <url>%2F2018%2F03%2F15%2Fjquery%E7%89%88%E7%9A%84%E8%BD%AE%E6%92%AD%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[用jquery实现一个轮播图，效果：自动轮播，点击切换，鼠标移入暂停用jquery实现无缝轮播 轮播图12345678910111213141516171819202122var n = 0;$('button').click(function() &#123; $('button').removeClass(); // removeClass不传入参数，则默认移除该元素所有class $(this).addClass('red'); n = $(this).index(); //通过.index()方法可以获取伪数组的index $('.imgs').css('transform', 'translateX(' + (-100 * n) + 'px)');&#125;);function setTimer() &#123; n++; $('button').eq(n % 5).trigger('click');&#125;var timer = null;timer = setInterval(setTimer, 3000);$('.box').hover(function() &#123; clearInterval(timer);&#125;, function() &#123; setTimer(); //鼠标移出后立即先执行一遍 timer = setInterval(setTimer, 3000);//然后再每隔3s执行&#125;); 无缝轮播图通过这个demo，了解了transitionend这个方法 为了防止切换页面，重新回来时，定时器出现错乱，建议加入以下代码：123456789var timer = null;$(document).on("visibilitychange", function() &#123; if (document.hidden === true) &#123; clearInterval(timer); &#125; else &#123; timer = setInterval(slide, 2000); &#125;&#125;);]]></content>
      <categories>
        <category>jq</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 前端面试题]]></title>
    <url>%2F2018%2F03%2F15%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[总结了一些前端的相关面试题 http://ovenzeze.coding.me/ 谈谈内容，样式，行为的分离html负责内容css负责样式js负责行为为什么这三者要分离？（反过来回答：如果不分离会导致……）如果用html负责样式12345&lt;div bgcolor=green&gt; &lt;center&gt; &lt;font color=red size=20&gt;文字居中&lt;/font&gt; &lt;/center&gt;&lt;/div&gt; 这样会使得html的标签有些是用来表示内容的，有些是用来表示样式的，导致html结构很复杂，很难区分这些标签的逻辑结构 如果用css负责内容123456789div:after&#123; content:'我是内容';&#125;``` 这样会导致用户无法选中内容；js也无法取到 如果用js负责样式```javascript$('#div1').show(); // 这会导致原本的display修改为block 建议设置css,然后通过addClass和removeClass来切换样式 关于性能优化性能优化及技巧分享 如果在图片下载下来之前就知道img的宽高，那么就把宽高写进img标签内；否则浏览器会先用一个小宽度的占位符，等到大图下载下来后，由于宽高撑大了原本的占位符，于是之后的元素的位置要往后退，这会导致重排(re-layout)，重排非常的浪费性能。 异步与回调异步异步：不等结果，直接进行下一步同步 vs 异步：同步：定时器的结果出来后，才进行下一步异步：不等定时器的结果，马上进行下一步123456789101112console.log(1);/* 这是个异步任务↓ setTimeout(function()&#123; console.log(2);&#125;,2000);*/console.log(3);先打印出1，再打印出3,两秒后打印出2 回调可以通过callback回调拿到异步结果1234567891011121314console.log(1);(function xxx()&#123; setTimeout(function()&#123; console.log(2); callback(); &#125;,2000);&#125;)();function callback()&#123; console.log('endFn');&#125;console.log(3);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>css</tag>
        <tag>html</tag>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿照jquery]]></title>
    <url>%2F2018%2F03%2F13%2F%E4%BB%BF%E7%85%A7jquery%2F</url>
    <content type="text"><![CDATA[如何封装一个js库把封装的js库添加到自定义的接口(自定义对象)上jquery的原理 封装函数封装函数获取兄弟节点(ele)1234567891011121314151617function 获取兄弟节点(ele)&#123; var parent = ele.parentElement; var allChildren = parent.children; var length = 0; var 伪数组=&#123;length:length&#125;; for(i=0;i&lt;allChildren.length;i++)&#123; if(allChildren[i] !== ele)&#123; 伪数组[length] = allChildren[i]; length++; 伪数组.length = length; &#125; &#125; return 伪数组;&#125;console.log( 获取兄弟节点(li4) ); 封装函数添加或删除多个class(ele,classes)12345678910111213141516var classes = &#123;'a':true, 'b':false,//false表示删除 'c':true &#125;;function 添加或删除多个class(ele,classes)&#123; for(var key in classes)&#123; if(classes[key])&#123; ele.classList.add(key); &#125;else &#123; ele.classList.remove(key); &#125; &#125;&#125;添加或删除多个class(li5,classes); 代码优化上面的代码可以优化为：12345678910原始代码：if(classes[key])&#123; ele.classList.add(key);&#125;else &#123; ele.classList.remove(key);&#125;优化：var method = classes[key] ? 'add' : 'remove';ele.classList[method](key); 打开console控制台查看结果JS Bin 命名空间12345678var stage = &#123;&#125;; // 或者 window.stage = &#123;&#125;stage.获取兄弟节点 = 匿名函数; //添加到对象内stage.添加或删除多个class = 匿名函数; //添加到对象内var x = stage.获取兄弟节点(li4);console.log(x);stage.添加或删除多个class(li6,&#123;'a':true,'b':false,'c':true&#125;); JS Bin 这种方法每次都要使用stage.xxx(ele,其他参数)太麻烦了 把ele放在前面的方法上面的方法每次使用都要在前面加上命名空间,比如stage.xxx(ele,其他参数)，这样太麻烦了 如何达到以下效果，不使用命名空间：12ele.获取兄弟节点()ele.添加或删除多个class(&#123;'a':true,'b':false,'c':true&#125;); 直接加到Node.prototype上将封装的函数直接加到Node的公用属性(原型)Node.prototype上。并且把传入的第一个参数去掉，函数体内改成this1234567891011121314151617Node.prototype.获取兄弟节点 = function &#123; var parent = this.parentElement; var allChildren = parent.children; var length = 0; var 伪数组=&#123;length:length&#125;; for(var i=0;i&lt;allChildren.length;i++)&#123; if(allChildren[i] !== this)&#123; 伪数组[length] = allChildren[i]; length++; 伪数组.length = length; &#125; &#125; return 伪数组;&#125;;console.log( li7.获取兄弟节点() );// 此处this就是li7 JS Bin 但是这种方法可能会污染Node的公用属性，因此不建议直接加到Node.prototype上 把封装的js库添加到自定义的接口上1234567891011121314151617181920212223242526272829var stage = function(node) &#123; return &#123; 获取兄弟节点: function() &#123; var parent = node.parentElement; var allChildren = parent.children; var length = 0; var 伪数组 = &#123; length: length &#125;; for (var i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== node) &#123; 伪数组[length] = allChildren[i]; length++; 伪数组.length = length; &#125; &#125; return 伪数组; &#125;, 添加或删除多个class: function(classes) &#123; for (var key in classes) &#123; var method = classes[key] ? 'add' : 'remove'; node.classList[method](key); &#125; &#125; &#125;&#125;;/////////////////console.log( stage(li3).获取兄弟节点() );stage(li3).添加或删除多个class(&#123; 'a': true, 'd': true &#125;); JS Bin 完善封装的js库123456789101112131415161718192021222324252627282930313233 function stage(node) &#123; if(typeof node === 'string')&#123;//如果传入的是个字符串 node = document.querySelector(node); &#125; return &#123; getSibings: function() &#123; var parent = node.parentElement; var allChildren = parent.children; var length = 0; var 伪数组 = &#123; length: length &#125;; for (var i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== node) &#123; 伪数组[length] = allChildren[i]; length++; 伪数组.length = length; &#125; &#125; return 伪数组; &#125;, add_remove_classes: function(classes) &#123; for (var key in classes) &#123; var method = classes[key] ? 'add' : 'remove'; node.classList[method](key); &#125; &#125; &#125;;&#125;;/////////////////console.log( stage('#li3').getSibings() );stage(li4).add_remove_classes(&#123; 'red': true&#125;);stage('ul&gt;li:nth-of-type(2)').add_remove_classes(&#123;'red':true&#125;); JS Bin 用$缩写(alias)1window.$ = stage; 12345678910111213141516171819202122232425262728var stage = function (node) &#123; var eles = &#123;length: 0&#125;; if (typeof node === 'string') &#123; //如果传入的是个字符串 var temps = document.querySelectorAll(node);//临时变量是个伪数组 for(var i=0;i&lt;temps.length;i++)&#123; //把临时变量存到伪数组eles内 eles[i] = temps[i]; eles.length = temps.length; &#125; &#125; //在eles里添加添加方法 eles.add_remove_classes = function(classes) &#123; for (var key in classes) &#123; var method = classes[key] ? 'add' : 'remove'; for (var j=0;j&lt;eles.length;j++)&#123; eles[j].classList[method](key); &#125; &#125; &#125;; //console.log(eles); return eles;//!!!一定要return，不然stage()调用完的返回值是undefined&#125;;window.$ = stage;/////////////////stage('li')..add_remove_classes(&#123;'blue': true&#125;);等同于：$('li').add_remove_classes(&#123;'blue': true&#125;); JS Bin 通过arguments.length区分获取or设置123456789.css('width') //获取宽度.css('width', '100px') //设置宽度jquery的源码通过arguments.lenth判断是获取or设置if(arguments.length == 1)&#123;//如果只传1个参数 // 获取&#125; else &#123; // 设置&#125; 作业题jQuery的原型（共用属性）是:$.fn1$.fn = jQuery.fn = jQuery.prototype 12345678910111213141516171819202122232425262728293031$('div').addClass('red') // 可将所有 div 的 class 添加一个 red$('div').setText('hi') // 可将所有 div 的 textContent 变为 hiwindow.jQuery = function(node) &#123; var nodes = &#123; length: 0 &#125;; if (typeof node === 'string') &#123; var temp = document.querySelectorAll(node); for (var i = 0; i &lt; temp.length; i++) &#123; nodes[i] = temp[i]; nodes.length = temp.length; &#125; &#125; nodes.addClass = function(classs) &#123; for (var i = 0; i &lt; nodes.length; i++) &#123; nodes[i].classList.add(classs); &#125; &#125;; nodes.setText = function(text)&#123; for (var i = 0; i &lt; nodes.length; i++) &#123; nodes[i].textContent = text; &#125; &#125;; return nodes;&#125;;window.$ = jQuery;$('div').addClass('red');$('div').setText('hi'); JS Bin]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>笔记</tag>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM基础知识]]></title>
    <url>%2F2018%2F03%2F12%2FDOM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[DOM相关apitextContent与innerText与innerHTML的区别nodeType的值对应什么节点documentFragment性能优化 DOMDocument Object Model,文档对象模型即：把html当做对象来操作 Node节点(元素)相关api获取 元素.childNodes 获取该元素的所有子节点，包括换行形成的text节点。返回一个伪数组 元素.childNodes[0] 元素.children 获取该元素的所有子标签，不包括换行。返回一个伪数组 元素.children[0] 元素.parentNode 与 元素.parentElement 元素.firstChild 与 元素.firstElementChild 元素.lastChild 与 元素.lastElementChild 元素.previousSibling 与 元素.previousElementSibling 元素.nextSibling 与 元素.nextElementSibling 元素.parentNode 与 元素.parentElement 元素.nodeName 与 元素.tagName 返回的是大写的字符串，比如’DIV’,在做if判断时要配合toLowerCase使用 元素.innerHTML 与 元素.innerTEXT 与 元素.textContent123456789101112131415161718192021&lt;footer id="footer"&gt; &lt;p&gt;hello &lt;script&gt;document.write('2014-' + new Date().getFullYear())&lt;/script&gt; world &lt;/p&gt; &lt;/footer&gt;footer.textContent 与 footer.innerText返回结果一样: 'hello document.write('2014-' + new Date().getFullYear()) world'1.textContent会将style标签里的内容当做文本返回，而innerText会忽略style标签里包含的内容2.innerText不会返回display:none的元素的文本，而textContent会--------------------------------footer.innerHTML的返回结果：' &lt;p&gt;hello &lt;script&gt;document.write('2014-' + new Date().getFullYear())&lt;/script&gt;2014-2018 world &lt;/p&gt;' 面试题textContent与innerText的区别123456&lt;div id="test" class="test"&gt;test&lt;div style="display:none"&gt;&lt;span&gt;test&lt;/span&gt;&lt;/div&gt;&lt;style&gt;hi&lt;/style&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var testDiv = document.getElementById('test'); console.log(testDiv.textContent); console.log(testDiv.innerText);&lt;/script&gt; textContent会获取所有元素的内容，包括 &lt;script&gt; 和 &lt;style&gt; 里包含的内容。而innerText不会 textContent会获取display:none的节点的文本；而innerText不会返回隐藏元素的文本 由于 innerText 受 CSS 样式的影响，它会触发回流（reflow），但textContent 不会。 innerHTML获取时，会将包含的标签还原出来123&lt;div id='x'&gt;&lt;p&gt;hello&lt;/p&gt;&lt;/div&gt;x.innerHTML // &lt;p&gt;hello&lt;/p&gt; 设置时，会将标签转成代码1x.innerHTML='&lt;i&gt;hello&lt;/i&gt;' // i标签自动转成斜体 面试题nodeType nodeType=1 元素节点(标签)，例如, nodeType=2 属性节点 比如class=”right” nodeType=3 文本节点 例如p标签里包含的文字 nodeType=8 注释节点 nodeType=9 document文档节点 nodeType=10 文档类型节点 比如html的文档类型是&lt;!DOCTYPE html&gt; nodeType=11 documentFragment文档片段节点12345document.nodeType === Node.DOCUMENT_NODE// truedocument.nodeType === 9// true 面试题documentFragment性能优化查看相关博客 操作DOM ul.appendChild(li) 把li插入ul的末尾内 div1.cloneNode(deep?)浅拷贝 深拷贝 元素.hasChildNodes() 元素是否含有子节点，有的话返回true，换行算作文本节点 ul.insertBefore(li, ul.children[0]) 把新节点插到ul最前面内 div1.isEqualNode(div2) 检查两个元素是否相等 div1.isSameNode(div2) 检查两个元素所有有相同节点。推荐使用div1===div2来代替此方法 ul.removeChild(ul.lastElementChildren) ul.replaceChild(newLi, oldLi) 元素.normalize() // 常规化 document相关api获取 document.body // &lt;body&gt;...&lt;/body&gt; document.children // 伪数组[html] document.documentElement // &lt;html&gt;...&lt;/html&gt; document.domain // “xiedaimala.com” document.origin // “https://xiedaimala.com“ document.head // &lt;head&gt;...&lt;/head&gt; document.images //获取页面中所有的&lt;img&gt;标签。通过document.images.length可以获取&lt;img&gt;标签数量 document.links //获取页面中所有的&lt;a&gt;标签。通过document.links.length可以获取&lt;a&gt;标签数量 document.location document.referrer //引荐人。从哪里跳转到这个页面的 document.title document.onxxxxx //onclick，onmouseover……. 操作document document.getElementById() document.getElementsByClassName() document.getElementsByTagName() document.querySelector() //只获取满足条件的第一个元素 document.querySelectorAll() //返回一个伪数组 document.createDocumentFragment() document.createElement() document.createTextNode() document.write() //紧接着写 document.writeln() //一行一行(line)写 Element相关apihttps://developer.mozilla.org/zh-CN/docs/Web/API/Element 作业题123456var parent = document.getElementById('parent');parent.childNodes.length // 2parent.appendChild(document.createElement('div'));parent.childNodes.length // 请问现在 length 是多少答案：3 12345678910var allDiv = document.querySelectorAll('div')allDiv.length // 假设是 2document.body.appendChild( document.createElement('div') )allDiv.length // 请问现在 length 的值是多少？？？答案：2将最后一段代码改成allDiv = document.querySelectorAll('div') //在使用querySelector方法时，遇到DOM树增加或删除,需要重新获取allDiv.length // 3 上面两题，为什么一个 length 会动态变化，另一个 length 却不会动态变化？ 1.parent.childNodes是动态集合。所谓动态集合就是一个活的集合，DOM树删除或新增一个相关节点，都会立刻反映在NodeList接口之中。2.document.querySelectorAll方法返回的是一个静态集合。DOM的增删，并不会实时反映在该方法的返回结果之中。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数Function基础知识]]></title>
    <url>%2F2018%2F03%2F12%2F%E5%87%BD%E6%95%B0Function%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[函数的声明方法函数的调用callthis作用域和闭包 函数声明方法总结 具名函数 1234function fn(x,y)&#123; return x + y;&#125;fn.name // 'fn' 匿名函数 123function (x,y) &#123; return x+y; &#125; var fn=匿名函数 1234var fn = function(x,y) &#123; return x+y;&#125;fn.name // 'fn' var fn=具名函数 1234567891011var fn = function f2(x,y)&#123; return x+y &#125;; fn.name // 'f2' console.log(f2) // f2 is not defined等同于 var fn; fn= function f2(x,y)&#123; return x+y &#125; var fn=new Function() 12345678910111213参数和函数体都以字符串的形式 var fn = new Function('x','y','return x+y') fn.name // "anonymous"面试题：var n = 3;var fn = new Function('x','y','return x+'+n+'+y');问：fn(2,4)的结果是A：9B：2n4C：234答案：9 ES6箭头函数 1234567891011121314151617181920 var fn = (x,y) =&gt; &#123; return x+y &#125;; fn(2,3); // 5如果函数体只有一句话，可以去掉花括号和return： var sum = (x,y) =&gt; x+y; sum(4,5); // 9如果只有1个参数，可以简写为： var fn2 = n =&gt; n*n; fn2(4); // 16箭头函数的复杂写法：var fn = (x,y) =&gt; &#123; const a=x*2; const b=y*3; return a+b;&#125;fn(3,5) // 21 evaleval方法可以将字符串当做代码执行。1eval('alert(1)') // 弹出1 eval方法一般很少会使用到。 函数的调用1234fn(参数1,参数2);等同于fn.call(undefined,参数1,参数2)； this和伪数组argumentsthis就是call的第一个参数fn(参数1,参数2)等同于fn.call(undefined,参数1,参数2)，因此fn(参数1,参数2)的this是undefined12345678910111213'use strict';function fn()&#123; console.log(this); console.log(arguments);&#125;fn.call(1,2,3);// this为1//arguments为伪数组[2,3]fn(1,2,3);//等同于fn.call(undefined,1,2,3)// this为undefined//arguments为伪数组[1,2,3] this相关面试题 this总是代表它的直接调用者(js的this是执行上下文), 例如 obj.fn ,那么fn中的this就是obj 在默认情况(非严格模式下,未使用 ‘use strict’),没找到直接调用者,则this指的是 window (约定俗成) 在严格模式下’use strict’,没有直接调用者的函数中的this是 undefined 使用call,apply,bind(ES5新增)绑定的,this指的是 绑定的对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function f()&#123; console.log(this)&#125;f.call(1)// Number对象&#123;1&#125;function f1()&#123; console.log(this) function f2()&#123;&#125;&#125;var obj = &#123;name: 'obj'&#125;f1.call( obj )//&#123;name: 'obj'&#125;----------function f()&#123; 'use strict' console.log(this)&#125;f.call(1)// 1-------------function f()&#123; console.log(this) //console.log(this === window)&#125;f.call()// window function f1()&#123; function f2()&#123; console.log(this) &#125; f2.call()&#125;var obj = &#123;name: 'obj'&#125;f1.call( obj )//window----------function f()&#123; 'use strict' console.log(this)&#125;f.call()//undefinedfunction f1()&#123; 'use strict'; function f2()&#123; console.log(this) &#125; f2.call()&#125;var obj = &#123;name: 'obj'&#125;f1.call( obj )//undefined call stack普通调用嵌套调用递归调用 作用域面试题最重要的一步：变量提升！！！！！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var a = 1;function f1()&#123; alert(a) // 是多少 var a = 2;// 由于函数内部有变量a了，所以不会访问外部作用域里的a&#125;f1(); //undefined-------------------var a = 1;function f1()&#123; alert(a) // 是多少&#125;f1();// 1f1内部没有变量a，因此会访问全局作用域里的a----------------------------var a = 1;function f1()&#123; var a = 2; //f1的局部a=2 f2();&#125;function f2()&#123; console.log(a) // 是多少&#125;f1(); // 1 由于f2内部没有变量a,因此会访问全局作用域里的a-----------------------------var a = 1;function f1()&#123; a = 2; //由于f1内部没有声明变量a，因此它赋值给的是全局作用域的a，此时全局a=2 f2();&#125;function f2()&#123; console.log(a) // 是多少&#125;f1(); // 2----------------------6个livar lis = document.getElementsByTagName('li');for(var i = 0; i&lt;lis.length; i++)&#123; lis[i].onclick = function()&#123; console.log(i) // 点击第3个 li 时，打印 2 还是打印 6？ &#125;&#125;//最终结果：6打印出来的是for循环结束完之后的i--------------------var改成letfor(let i = 0; i&lt;lis.length; i++)&#123; lis[i].onclick = function()&#123; console.log(i) // 点击第3个 li 时，打印 2 还是打印 6？ &#125;&#125;//最终结果：0,1,2,3,4,5 ES6中的let12345let a = 1;&#123; let a = 2; //这里的a困在花括号内，无法逃到全局作用域里&#125;consolelog(a); // 1 闭包面试题如果一个函数，使用了它外部作用域的变量，那么(这个函数+被使用的变量)就叫做闭包。12345var a = 1;function f1() &#123; console.log(a); //访问了外部的全局作用域的变量a&#125;f1(); // 1 闭包相关面试题 作业题123456789101112var a = console.log(1);a的值是多少？答案:undefined因为console.log的源码是将内容打印出来后，return undefinedalert的源码结尾也是return undefined----------------------function f()&#123; return 1;&#125;var a = f();//a的值是1 逗号表达式逗号表达式的一般形式是：表达式1，表达式2，表达式3……表达式n逗号表达式的求解过程是：先计算表达式1的值，再计算表达式2的值，……一直计算到表达式n的值。最后整个逗号表达式的值是表达式n的值。看下面几个例子：1234567891011var a = (1,2);a的值为2-----------var a = (1, console.log(2));a的值是undefined，因为console.log的返回值是undefinedx=8*2,x*4 /*整个表达式的值为64，x的值为16*/ (x=8*2,x*4),x*2 /*整个表达式的值为128，x的值为16*/ x=(z=5,5*2) /*整个表达式为赋值表达式，它的值为10，z的值为5*/ x=z=5,5*2 /*整个表达式为逗号表达式，它的值为10，x和z的值都为5*/ 12345678910111213141516171819202122232425262728function f()&#123; return function f2()&#123;&#125;&#125;var a = f();//a的值是函数f2---------------function f()&#123; return function f2()&#123;&#125;&#125;var a = f();var b = a();等同于 var b = f.call().call()又等同于 var b = f()(); //前一个括号调用后返回一个函数；后一个括号执行返回的这个函数//a的值是函数f2//b的值是undefined,f2没有写ruturn，则默认return undefinedf2();//f2 is not defined，因为f2无法单独执行，必须要通过f()才能执行f2function f()&#123; return function f2()&#123; return 'hello' &#125;&#125;var b = f.call().call();等同于 var b = f()(); //前一个括号调用后返回一个函数；后一个括号执行返回的这个函数//b的值为'hello' 1234567891011121314function f1()&#123; console.log(this) // 第一个 this function f2()&#123; console.log(this) // 第二个 this &#125; f2.call()&#125;var obj = &#123;name: 'obj'&#125;f1.call( obj )//第一个this为&#123;name: 'obj'&#125;//第二个this为window，在'use strict'模式下为undefined第一个this对应的call是f1.call(obj)第二个this对应的call是f2.call();]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组Array基础知识]]></title>
    <url>%2F2018%2F03%2F09%2F%E6%95%B0%E7%BB%84Array%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[数据类型new与不new的区别伪数组数组api查看Array对象公共属性 基本数据类型new不new的区别new String(x)和String(x)的区别 123456String(1) //"1" 变成字符串String(false) // 'false'String(null) // 'null'new String(1) // String &#123;"1"&#125; 变成String对象new String('sss') // String &#123;"sss"&#125; new Number(x)和Number(x)的区别 12345678910Number('3') //3 变成数字Number('sss') //NaN NaN也是数字类型Number(true) //1Number(false) //0Number(null) //0Number(undefined) //NaNnew Number('123') //Number &#123;123&#125; 变成Number对象new Number(111) //Number &#123;111&#125; 复杂数据类型new不new的区别new OBject(x)和Object(x)的区别【没区别】1234567891011Object(1) // Number &#123;1&#125; 传入数字则变成Number对象new Object(1) // Number &#123;1&#125; 与上面没区别Object('sss') // String &#123;"sss"&#125; 传入字符串则变成String对象new Object('sss') // String &#123;"sss"&#125;Object() //&#123;&#125; 什么都不传就是空对象new Object() //&#123;&#125;Object(false) // Boolean &#123;false&#125; 传入布尔值则变成Boolean对象new Object(false) // Boolean &#123;false&#125; 数组Array12345678910111213var arr = Array(3) // [undefined,undefined,undefined] 【生成length为3，每个值都是undefined的数组】arr[0] //undefinedarr[1] //undefinedarr[2] //undefined'0' in arr //false 从内存图可以看出，在地址99的数据里只有length和__proto__'length' in arr //true'__proto__' in arr //truearr.__proto__ == Array.prototype //arr是由Array构造的，所以它的__proto__指向Array的公用属性 //true 生成的数组的__proto__指向Array的公用属性(原型prototype)//这个公用属性中有push方法、shift方法等 1234567var arr = Array(3) // [undefined,undefined,undefined] 1个参数时表示生成长度为length、每一项的值为undefined的数组var arr = Array(3,3) // [3,3] 多于1个参数时，表示每一项的值var arr = new Array(3) 跟不加 new 一样的效果var arr = new Array(3,3) 跟不加 new 一样的效果 函数Function1234567891011var fn1 = function (a,b) &#123; return a+b;&#125;;fn1(5,9);// 14--------var fn2 = Function('a','b','return a-b');//参数和方法体都写成字符串的形式等同于var fn2 = new Function('a','b','return a-b');//加不加new都一样fn2(10,3) //7 总结 new不new的区别 基本数据类型不加new 则返回基本类型 1String(1) // '1' 基本数据类型加new 则返回一个对象 1new Number('123') //Number &#123;123&#125; 变成Number对象 复杂数据类型加不加new都一样 12Object('sss') // String &#123;"sss"&#125; 传入字符串则变成String对象new Object('sss') // String &#123;"sss"&#125; 伪数组 arguments 对象是伪数组 document.querySelectAll(‘div’) 返回的对象是伪数组上面两个有以下这些特征: 1.有 0:xx,1:xx,2:xx,3:xx…n:xx,length:xx 这些 key 的对象2.他们的proto不链接到数组的公用属性Array.prototype，即他们的原型链中没有Array.prototype 这样的对象就是伪数组12345678function fn() &#123; console.log(arguments)&#125;fn(1,3,5,7);//arguments有0,1,2...,length这些key,但是它的__proto__没有指向Array的公用属性Array.prototype，而是指向Object.prototypefn.push(9) // 报错，伪数组没有数组的api instanceof判断是不是数组instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。换句话说，instanceof用来测试一个对象的proto是否指向构造函数(Array,Function,Object等)的共有属性(prototype)1234567var arr = [1,2,3];arr instanceof Array; //truearr instanceof Function; //false//伪数组的原型链中没有Array的prototype属性var lis = document.querySelectorAll('li');lis instanceof Array;//false 数组的操作(api) 数组就是数据的有序集合 数组就是原型链中有 Array.prototype 的对象 遍历数组获取value和index用forEacharr.forEach(function (value,index) {执行函数体});forEach只用来操作数据,没有返回值map有返回值 forEach的用法与map方法一致,接受三个参数：value、index、整个数组。123456789101112131415161718var colors = ['red', 'green', 'blue'];colors.forEach(function (value) &#123; console.log(value);&#125;);//箭头函数写法：colors.forEach((value) =&gt; console.log(value));// red// green// blue-------var colors = ['red', 'green', 'blue'];colors.forEach(function (value,index) &#123; console.log(index + ':'+ value);&#125;);//0:red//1:green//2:blue forEach的原理： 排序sort sort用的快速排序 默认的sort会将数字先转成字符串，再按照字典顺序进行从小到大排序，所以会有bug 1234567891011['d', 'c', 'b', 'a'].sort()// ['a', 'b', 'c', 'd'][4, 3, 2, 1].sort()// [1, 2, 3, 4][11, 101].sort()// [101, 11] 先比较最前面的数，都是1，再比较第二位数，js误以为101小于11[10111, 1101, 111].sort()// [10111, 1101, 111] 先比较最前面的数，都是1；再依次比较后几位数，有bug 如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。 123456789101112从小到大排序a-b[10111, 1101, 111].sort(function (a, b) &#123; return a - b;&#125;)// [111, 1101, 10111]--------从大到小排序b-a[10111, 1101, 111].sort(function (a, b) &#123; return b - a;&#125;)[10111, 1101, 111] 根据给定的依据进行排序 1234567891011var students = ['小明','小红','小花']; var scores = &#123; 小明: 59, 小红: 99, 小花: 80 &#125;;students.sort(function(a,b) &#123; return scores[a]-scores[b]; //按照scores从小到大排序&#125;);//["小明", "小红", "小花"] students.sort(function(a,b) &#123; return scores[b]-scores[a];//按照scores从大到小排序&#125;);//["小红", "小花", "小明"] 123456789101112[ &#123; name: "张三", age: 30 &#125;, &#123; name: "李四", age: 24 &#125;, &#123; name: "王五", age: 28 &#125;].sort(function (o1, o2) &#123; return o1.age - o2.age;&#125;)// [// &#123; name: "李四", age: 24 &#125;,// &#123; name: "王五", age: 28 &#125;,// &#123; name: "张三", age: 30 &#125;// ] join 数组变字符串join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。12345var a = [1, 2, 3, 4];a.join(' ') // '1 2 3 4'a.join('xx') // "1xx2xx3xx4"a.join() // "1,2,3,4" 数组变字符串更简单的办法：1234var a = [1, 2, 3, 4];a+''; // "1,2,3,4"a+'3'; // "1,2,3,43" cancat连接多个数组concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。1234567891011['hello'].concat(['world'])// ["hello", "world"]['hello'].concat(['world'], ['!'])// ["hello", "world", "!"][].concat(&#123;a: 1&#125;, &#123;b: 2&#125;)// [&#123; a: 1 &#125;, &#123; b: 2 &#125;][2].concat(&#123;a: 1&#125;)// [2, &#123;a: 1&#125;] concot用来复制一个数组，由于concat返回的是一个新数组，因此虽然复制原数组，但两者不相等123var a = [1,2,3];var b = a.concat([]); // b = [1,2,3]a == b; // false 数组相加数组的相加，先将每个数组转变成字符串，然后连接起来1[1,2,3]+[4,5,6] // "1,2,34,5,6" mapmap方法将数组的所有value依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。原数组不变forEach没有返回值，map有返回值12345678910var numbers = [1, 2, 3];var newNum = numbers.map(function (value) &#123; return value + 1;&#125;);newNum; // [2,3,4]numbers; // [1, 2, 3]上面代码中，numbers数组的所有成员依次执行参数函数，运行结果组成一个新数组返回，原数组没有变化。 map有三个参数：value、index和数组本身。1234[1, 2, 3].map(function(value, index, arr) &#123; return value * index;&#125;);// [0, 2, 6] 用箭头函数=&gt;可以简写为：12var arr = [2,3,4];arr.map(value =&gt; value+3); // [5, 6, 7] map方法还可以返回包含对象的数组12345678var arr = [2,3,4];a.map(function(value,index)&#123; return &#123; '下标':index,'值':value; &#125;&#125;);// [ &#123;下标: 0, 值: 2&#125;, &#123;下标: 1, 值: 3&#125;, &#123;下标: 2, 值: 3&#125; ] filter过滤filter方法用于过滤数组value，满足条件的value组成一个新数组返回。 它的参数是一个函数，所有数组value依次执行该函数，返回结果为true的value组成一个新数组返回。 该方法不会改变原数组。 1234[1, 2, 3, 4, 5].filter(function (value) &#123; return (value &gt; 3); //结果为true的value组成一个新数组返回&#125;)// [4, 5] filter方法可以接受三个参数：value，index和整个数组。1234[1, 2, 3, 4, 5].filter(function (value, index, arr) &#123; return index % 2 == 0;&#125;);// [1, 3, 5] 先filter过滤再用map操作12345678var a = [1,2,3,4,5,6,7,8,9];a.filter(function(value)&#123; return value &gt; 5;&#125;).map(function(value)&#123; return value*2;&#125;)// [12, 14, 16, 18] 压缩累计reduce,reduceRightreduce方法和reduceRight方法依次处理数组的每个value，最终压缩累计为一个值。它们的差别是，reduce是从左到右处理（从第一个value到最后一个value），reduceRight则是从右到左（从最后一个value到第一个value），其他完全一样。 用reduce方法可以可以简化用for循环来累计的运算(比如求数组之和)12345678910var arr = [1, 2, 3, 4, 5];arr.reduce(function (sum, value) &#123; console.log(sum, value); return sum + value;&#125;, 0) //默认初始值为0,可以省略不写// 1 2// 3 3// 6 4// 10 5//最后结果：15 用箭头函数=&gt;简化：12arr.reduce((sum,value) =&gt; sum+value,0);//初始值为0//最后结果：15 reduce可以设置初始值1234[1, 2, 3, 4, 5].reduce(function (a, b) &#123; return a + b;&#125;, 10); // 从10开始累加// 最后结果：25 计算所有奇数之和：123456var a = [1,2,3,4,5,6,7,8,9];a.reduce( function(sum,value) &#123; value = value%2 == 0 ? 0 : value; return sum + value;&#125;,0) reduce替代map设置初始值为空数组[]12345678var arr = [2,3,4];将数组里的每一项乘以2，然后返回一个新数组arr.reduce(function(sum, value) &#123; sum.push(value*2); //push到初始值内 return sum;&#125;,[]) //初始值是个空数组// [4, 6, 8] reduce替代filter设置初始值为空数组[]12345678910var arr = [1,2,3,4,5,6,7,8,9];用reduce过滤出所有的偶数，然后返回新数组arr.reduce(function(sum,value)&#123; if(value%2==0)&#123; sum.push(value); &#125; return sum&#125;,[])// [2, 4, 6, 8] 数组中是否含有某个值顺带一提，字符串用str.indexOf(value)来判断是否含有某个字符123'abcde'.indexOf('c') // 2'abcde'.indexOf('f') // -1'abcde'.indexOf('bcd') // 1 arr.includes()语法：arr.includes(value [,startIndex])123[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, NaN].includes(NaN); // true Jquery的$.inArray()方法语法:$.inArray( value, array [, startIndex ] )123var arr = [1,2,'hi',3,'world'];console.log( $.inArray( 'hi', arr) ) // 2 说明'hi'在arr的第2位console.log( $.inArray( 5, arr) ) // -1 说明arr中没有数字5]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 jquery知识点补充]]></title>
    <url>%2F2018%2F03%2F07%2Fjquery%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[jquery相关知识点补充 production，development版本的区别production生产版，代码经过混淆压缩，用在生产环境(放在服务器上给客户用)development开发版，原始未混淆压缩的代码，给自己用 jQuery的原型jQuery的原型（公共属性）是:$.fn1$.fn = jQuery.fn = jQuery.prototype 点击导航缓动到相应位置12345678910111213141516 &lt;nav style="position: fixed;top: 0;"&gt; &lt;a href="#a"&gt;a&lt;/a&gt; &lt;a href="#b"&gt;b&lt;/a&gt; &lt;a href="#c"&gt;c&lt;/a&gt;&lt;/nav&gt; &lt;div id="a" style="width: 100px;height: 100px;background: green;margin-top: 500px;"&gt;aaaa&lt;/div&gt; &lt;div id="b" style="width: 100px;height: 100px;background: green;margin-top: 500px;"&gt;bbb&lt;/div&gt; &lt;div id="c" style="width: 100px;height: 100px;background: green;margin-top: 500px;margin-bottom: 500px;"&gt;ccc&lt;/div&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; $('a').click(function(event) &#123; event.preventDefault(); var eleId = $(this).attr('href'); $('html,body').animate(&#123;scrollTop: $(eleId).offset().top&#125;, 800); &#125;);&lt;/script&gt; addClass(function(index){})根据条件，将数组中的class按需添加1234var colors = ['red', 'yellow', 'blue', 'green'];$('li').addClass(function(i)&#123; return colors[i];&#125;); JS Bin 面试题123&lt;div id=x&gt;&lt;/div&gt;var div = document.getElementById('x')var $div = $('#x') 请说出 div 和 $div 的联系和区别。12345678910div 和 $div 的联系是：把 div 变成 $div ： $(div)把 $div 变成 div : 由于$div是一个伪数组，所以要取得他，需要用get()从数组中取出来$(div).get(0) 或者简写为$(div)[0]div 和 $div 的区别是：$div是JQuery对象，可以使用jq的api。而div是DOM对象，可以使用DOM的api两者可以调用的属性和方法不一样 removeClass()移除元素的所有classremoveClass()没有参数则移除所有class12$('div').removeClass();//如果不传入参数，则默认将div的所有class移除 或者使用removeAttr(&#39;class&#39;)12$('div').removeAttr('class');//移除div的class属性 触发器trigger123$('btn1').click(function()&#123; $('#div1').trigger('click'); // 触发#div1的click事件&#125;) transitionend过渡完成后执行某个函数transitionend事件该事件在 CSS 完成过渡后触发。12var $div1 = $("#div1");$div1.on('transitionend', fn); animationend动画结束后执行某个函数animationend事件该事件在 CSS 动画结束播放时触发1$div1.on("animationend", fn); animationiteration 该事件在 CSS 动画重复播放时触发animationstart 该事件在 CSS 动画开始播放时触发 return false取消冒泡和默认行为http://www.berlinix.com/js/jquery-return-false.php http://caibaojian.com/javascript-stoppropagation-preventdefault.html return false实际完成了3件事：1.event.preventDefault() //阻止默认行为 event.stopPropagation() //阻止冒泡 停止回调函数执行并立即返回。 点击页面其他地方关闭弹出层1234567891011121314$('#btn').click(function() &#123; $('#popover').show(); $(document).one('click', function() &#123; //在click事件里，给父级加上了另一个事件，这个事件会被立刻执行，因此需要给wrapper阻断冒泡，让它在被点击时才执行 console.log(1); //只有弹出层show出来后，才会触发document的click事件，且只触发一次 $('#popover').hide(); &#125;);&#125;);//document的click事件加在了btn函数内部，它会在冒泡阶段直接执行，即使不点击document也会直接执行因此需要阻断冒泡$('#wrapper').click(function(ev) &#123; ev.stopPropagation();&#125;); .on()向动态创建的子元素添加事件处理程序$(&#39;&#39;).on(&#39;click&#39;,未来的子元素,function)向未来的子元素添加事件处理函数1234567$("ul").click(function()&#123; $("&lt;li&gt;创建li&lt;/li&gt;").insertAfter("ul");&#125;);$("ul").on("click","li",function()&#123; $(this).hide(); //给动态创建的li绑定事件处理函数&#125;); http://www.runoob.com/try/try.php?filename=tryjquery_event_on_newel]]></content>
      <categories>
        <category>jq</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数、原型和原型链]]></title>
    <url>%2F2018%2F03%2F05%2F%E5%AF%B9%E8%B1%A1%2C%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%2C%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[var n=1; 与 var n=new Numer(1)的区别全局函数(构造函数)原型(prototype)和原型链对象.proto === 构造了它的全局函数.prototype (新创建的对象由对应的全局函数构造得来)全局函数.proto === Function.prototype（全局函数都是由Function构造出来的）全局函数.prototype.proto === Object.prototype （全局函数的共有属性从Object的共有属性中引用）Object.prototype.proto === null （Object的共有属性引用至null）原型 === 共有属性 === prototype原型链：顺着proto组成的链子一直往下走，直到proto 为 null 全局函数(构造函数)全局函数都是由Function构造的，因此全局函数.proto === Function.prototypeFunction.proto === Function.prototype1.Number12var n = new Number(1) 创建一个 Number 对象var n = 1 与 var n = new Number(1) 的区别是什么？看内存图 2.String12var s = new String('hello') 创建一个 String 对象'hello' 与 new String('hello') 的区别是什么？看内存图 3.Boolean12345678var b = new Boolean(true) 创建一个 Boolean 对象true 与 new Boolean(true) 的区别是什么？看内存图var a = false;var b = new Boolean(false);if(a)&#123;console.log(1)&#125;if(b)&#123;console.log(2)&#125; 结果是2，因为b是个对象 4.Object1234var o1 = &#123;&#125;var o2 = new Object()o1 和 o2 的数据没区别但是o1不等于o2，因为他们两个在Stack区的地址不同 原型和原型链原型 === 共有属性 === prototype原型链：顺着proto组成的链子一直往下走，直到proto 为 null12345678910111213创建一个对象后的原型链var arr = [1,2,3];arr.__proto__ === Array.prototype //新创建的对象由对应的全局函数构造arr.__proto__.__proto__ === Object.prototypearr.__proto__.__proto__.__proto__ === null所以它的原型链是：arr --&gt; Array.prototype --&gt; Object.prototype --&gt; null全局函数的原型链Array.__proto__ === Function.prototype //全局函数由Function构造Array.__proto__.__proto__ === Object.prototypeArray.__proto__.__proto__.__proto__ === null所以它的原型链是：Array.prototype --&gt; Function.prototype --&gt; Object.prototype --&gt; null 隐藏的公用属性(prototype)所有对象都有 toString 和 valueOf 属性，那么我们是否有必要给每个对象一个 toString 和 valueOf 呢？ 明显不需要。 JS 的做法是把 toString 和 valueOf 放在一个对象里（Object.prototype） 然后让每一个对象有1个隐藏的 proto 存储这个「公用属性组成的对象」的地址。 Object的proto指向Function.prototype12345var obj =&#123; name: 'stage', age: 24&#125;;console.log(obj);//&#123;name: "stage", age: 24&#125; 以及隐藏的__proto__指向Function.prototype 重点公式123456789101112131415161718192021222324252627282930313233var 对象 = new 全局函数() //全局函数包括Number(123)、String('123')/Function()等对象.__proto__ === (构造了它的)全局函数.prototype //.__proto__用来存原型(prototype)的地址，从而引用prototype的数据//__proto__是对象的属性//prototype是函数的属性//对象的__proto__指向函数的prototype比如：var num = new Number(1);num.__proto__ === Number.prototype; //num由Number构造生成//创建的num，它的隐藏的__proto__指向【Number】的公用属性Number.prototypenum.__proto__.__proto__ === Object.prototype; //创建的num，它隐藏的__proto__指向Number.prototype,Number.prototype.的隐藏__proto__继续指向Object的公用属性Object.prototype----------obj.toString === Object.prototype.toString //对象的toString方法，实际上是调用了Object的公用属性(prototype)的toString方法-----------var fn = new Function() fn.__proto__ === Function.prototype //fn由Function构造生成 由于Function的是由Function构造的，所以Function.__proto__ === Function.prototype 也就是说，Function.__proto__指向它本身的prototype-------------Object的_proto_指向Function.prototypeObject.__ptoto__ === Function.prototype，因为 Function 是 Object 的构造函数。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js类型转换，内存图，数据的引用，垃圾回收，深拷贝vs浅拷贝]]></title>
    <url>%2F2018%2F03%2F05%2Fjs%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[js类型转换的方法6个falsy值内存图数据的引用垃圾回收深拷贝vs浅拷贝 转成字符串String(x)String(x)是一个window的全局方法 x.toString()null和undefined没有.toString()方法 12345671.toString() //报错解析器不知道第一个点应该理解成小数点，还是应该理解成调用方法，因此报错1..toString() // '1' 第一个点表示小数点，第二个点表示调用方法1.0.toString() // '1'1 .toString() // '1'(1).toString() // '1' x + ‘’ 与空字符串相加这种方法比较简便，推荐用这种方法转成字符串 转成布尔值Boolean(x)注意!空对象是true !!x 转成数字Number(x)123456Number('3') //3 变成数字Number('sss') //NaN NaN也是数字类型Number(true) //1Number(false) //0Number(null) //0Number(undefined) //NaN parseInt(x)parseInt(&#39;123&#39;) 面试题1234567var a = 011; // a=9 js看到0开头默认转成8进制parseInt('011') // 11 【默认转成10进制】parseInt('011',8) // 9parseInt('s') // NaNparseInt('1s') // 1 parseFloat(x)parseFloat(3.14) x - 0 推荐这种12'123'-0 // 123'3.14'-0 // 3.14 +x 取正12+ '-1' // -1+ '3.14' // 3.14 6个falsy值0、NaN、空字符串、false、null、undefined 所有对象的falsy值都是true12345var a = false;var b = new Boolean(false);if(a)&#123;console.log(1)&#125;if(b)&#123;console.log(2)&#125; 结果是2，因为b是个对象 内存图 JS 引擎将内存分为代码区和数据区 我们只研究数据区 数据区又分为 Stack区（栈内存） 和 Heap区（堆内存） 简单类型的数据直接存在 Stack栈内存 里 复杂类型(object)把地址存到 Stack栈内存 区，把地址对应的数据存到 Heap堆内存 区 o2 = o;并不是修改了o2在Heap的数据，而是将o2的地址修改成o的地址，因此2访问o对应的数据 面试题-对象的引用12345678默认已经变量提升var a = &#123;name: 'a'&#125; //先在Heap区生成数据，然后在Stack区生成a的Address指向对应的数据var b = a // 将a的地址赋给b，而不是将a的数据赋值给bb = &#123;name: 'b'&#125; //在Heap区生成新的数据，然后生成b的地址指向对应的数据请问现在 a.name 是多少？ // 'a' a的地址没变，仍旧指向a的数据b = &#123;name:'b'&#125;并不会修改Heap区的数据，而是声明一个新的数据，然后Stack区的地址修改为新声明的数据对应的地址 12345默认已经变量提升var a = &#123;name: 'a'&#125; // 先在Heap区生成数据，然后在Stack区生成a的Address指向对应的数据var b = a // 将a的地址赋给b,此时b指向a的地址对应的数据b.name = 'b' // 修改a的地址对应的数据请问现在 a.name 是多少？ // 'b' 1234var a = &#123;name: 'a'&#125;var b = ab = null // null是简单类型，所以直接将b的STack区修改为null请问现在 a 是什么？ // &#123;name: 'a'&#125; 1234567var a = &#123;n:1&#125;; // heap区生成数据34，a生成地址34指向数据34var b = a; // b的地址也是34a.x = a = &#123;n:2&#125;; //此时最前面a.x是地址34的x// a.x等于地址a，即 34里的x = 新地址54【因为后面a在heap区生成了数据54&#123;n:2&#125;】alert(a.x);// --&gt; undefined 这里的a已经变成地址54了，54里的x是undefinedalert(b.x);// --&gt; [object Object] 由于b指向34,而34里的x = 新地址54 面试题-垃圾回收如果一个对象没有被引用(就是说没有地址指向它)，它就是垃圾，将会被回收 12345678910111213141516var fn = function ()&#123;&#125;;document.body.onclick = fn;fn = null;请问fn是垃圾吗？不是。一开始fn的Stack区是地址110,110指向数据fndocument是个复杂类型，所以Stack区存的地址222数据222里的body也是个复杂类型，所以body存的是地址333333里的onclick指向一开始声明的fnfn=null，null是简单类型，因此fn的Stack区更改为null虽然fn=null，但是fn被onclick引用，而onclick被body引用，body被document引用因此fn不是垃圾document.body.onclick = fn;此时fn是垃圾,因为没有东西引用它 浅拷贝vs深拷贝1234567891011121314151617181920212223var a = 1;var b = a;b = 2;//这个时候改变bconsole.log(a);// 1 【a 完全不受 b 的影响】把a赋值给b，当b改变时，a依然不变，这就是深拷贝对于简单类型的数据来说，赋值就是深拷贝。对于复杂类型的数据（对象）来说，才要区分浅拷贝和深拷贝。----------对象的浅拷贝：var a = &#123;name:'stage'&#125;; //复杂类型var b = a; // b的地址就是a的地址，因此指向a的数据b.name = 'xxx'; //修改a的地址对应的数据console.log(a.name) // 'xxx' 把a赋值给b(复杂类型的赋值只是将Stack区的地址进行了拷贝)，当b改变时，a也改变，这就是浅拷贝对象的深拷贝：var a = &#123;name: 'frank'&#125;var b = deepClone(a) // deepClone 还不知道怎么实现b.name = 'b'a.name === 'a' // true对象的深拷贝就是对 Heap 区进行完全的拷贝。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js里的数据类型]]></title>
    <url>%2F2018%2F03%2F03%2Fjs%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数字number字符串string布尔值booleanundefined未定义null对象object符号symbol js里的7种数据类型 number 数字 string 字符串 boolean 布尔值 symbol 符号 undefined null object 对象(数组array和函数function都是对象) typeof返回的都是字符串类型xxx 的类型stringnumberbooleansymbolundefinednullobjectfunctiontypeof xxx‘string’‘number’‘boolean’‘symbol’‘undefined’‘object’‘object’‘function’ number数字 整数和小数：1 1.1 .1 科学记数法：1.23e2 //123【表示1.23乘以10的2次方】 二进制：0b11 //3 【以0b开头的，js默认为二进制】 八进制：011（后来 ES5 添加了 0o11 语法）//3 【以0开头的默认为8进制】 十六进制：0x11 //17 【以0x开头的默认为16进制】 string字符串 空字符串：&#39;&#39; //空字符串的length=0 字符串换行： 12var s = `1234567890`; // 含换行符号,所以s.length=11 符号转义 1234567var s = '\''; // 'var s = '\n' // 回车var s = '\t' // tabvar s = '\\' // \ 用转义符转义斜杠 boolean布尔值 a &amp;&amp; b 与运算 a || b 或运算 null空对象,undefined空非对象 如果想声明一个对象，但暂且不赋值，用null表示空对象var obj = null 非对象声明，但暂且不赋值，用undefined(但是实际上你直接 var xxx 一下就行了)1234var notObj = undefined;简写为var notObj; object对象基本对象123456789101112var 王花花 = &#123; age: 18, gender: 'female', height: 168, weight: 57, married: true&#125;;王花花.age // 18等同于 王花花['age']王花花.gender // fenale等同于 王花花['gender'] 复杂对象12345678910111213141516var x = &#123; a: 1, b: 2, c: &#123; c1: 3, c2: 4, c3: &#123; d1: 5, d2: 6 &#125; &#125;&#125;;x.c // &#123;c1: 3, c2: 4&#125;x.c.c1 // 3x.c.c3.d2 // 6 对象的格式1234567891011121314151617var obj = &#123; 9a: 'hello' //报错，key不加引号，则命名需要按照变量名的命名规则，不能以数字开头&#125;; var obj = &#123; '9a': 'hello' //9a加上单引号就不报错了&#125;;-----------------var obj = &#123; '': 'hello' //空字符串可以作为key&#125;obj[''] // hellovar obj = &#123; 名字: '王花花' //可以用中文作为key名，因为在变量名的命名规则中，中文命名是合法的&#125; 操作对象12345678910111213141516171819var obj = &#123; a: 1, b: 2, c: 3&#125;;删除 delete obj.a;等同于delete obj['a'];某1个key是否存在'a' in obj;//true遍历对象for (var key in obj) &#123; console.log(key); // a,b,c console.log(obj[key]); //1,2,3&#125; 对象的相等情况1234567var a = [1,2,3];var b = [1,2,3];a===b // false,因为a和b的Address不一样var a = [1,2,3];var b = a;a===b //true,因为上一步a将自己的Address赋给了b typeof与instanceofinstanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。123var arr = [1,2,3];arr instanceof Array; //truearr instanceof Number; //false]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js和npm]]></title>
    <url>%2F2018%2F03%2F02%2FNode-js%E5%92%8Cnpm%2F</url>
    <content type="text"><![CDATA[node.js的常用命令npm的配置及使用 Node.js从官网下载node.jsshift + 鼠标右键，选择在此处打开命令窗口 Node.js相关命令 where node ：查看node.exe的安装路径 where npm ：查看npm安装路径 node -v：查看版本号 npm -v exit：退出 npm list -g --depth=0 查看所有全局安装 npm npm cache clean --force清除本地缓存 npmnpm常用命令及使用步骤：https://www.cnblogs.com/wdlhao/p/5900360.htmlnpm 常用命令详解：https://www.cnblogs.com/itlkNote/p/6830682.html 配置npm12345678910111213npm config set registry https://registry.npm.taobao.org/npm config set loglevel httpnpm config set progress falsenpm config set strict-ssl false---------------npm config，可以看到config可以简写为c所以上面的4句话可以简写为npm c set registry https://registry.npm.taobao.org/npm c set loglevel httpnpm c set progress falsenpm c set strict-ssl false npm 的配置被存储在 ~/.npmrc，你可以随时通过npm c edit查看修改。 安装模块在使用node的时候，用npm安装了很多软件，过一段时间没有使用就会忘记，怎么查看自己全局安装过的包，用命令npm list -g --depth 0 http-server安装：npm i http-server -g(默认安装在C:\Users\Administrator\AppData\Roaming\npm\node_modules) 然后就可以使用 http-server 或者 hs 来启动http-server了ctrl + C退出http-server 卸载：npm uninstall http-server -g，简写npm un http-server -g http-server的使用: 输入 hs 文件路径 参数 启用，默认localhost:8080如果直接 hs -c-1 就是在当前目录启用,禁止缓存,自动打开浏览器如果hhs D:\饥人谷\resume -c-1 -o 就是在指定的路径启用,禁止缓存,自动打开浏览器 如果想改变端口和地址采用这个方式：http-server &lt;文件路径&gt; -a hostip -p 端口号。参数-a是监听地址，而参数-p是修改监听端口。 -o 启动服务器后打开浏览器窗口-c 设置缓存控制max-age头的缓存时间（以秒为单位），例如-c10 10秒（默认为’3600’）。要禁用缓存，请使用-c-1，因为有时候修改代码后重启服务页面不一定立刻生效，所以禁用缓存-p 要使用的端口（默认为8080）-a 要使用的地址（默认为0.0.0.0）-d 显示目录列表（默认为“True”）-s或--silent从输出中抑制日志消息:这个意思就是你输入之后，日志消息不会显示 hs -h查看帮助]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js获取数组中的最大值的方法]]></title>
    <url>%2F2018%2F02%2F28%2Fjs%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[12345678910111213max = Math.max(1,32,45,31,3442,4);max = Math.max.apply(null,arr); max = Math.max(...arr); max = Math.max.call(null,7,2,0,-3,5); max = arr.sort().reverse()[0]; max = arr.sort(function(a,b)&#123; return b-a;&#125;)[0]; 1.Math.max()法12var max = Math.max(1,32,45,31,3442,4);console.log(max) apply()法1234在ES5中，使用Math.max函数的apply方法获取数组最大值使用null作为参数var arr = [7,2,0,-3,5];var max = Math.max.apply(null,arr);console.log(max) Math.max(…arr);1234在ES6中, 我们使用展开运算符...作为函数的参数var arr = [7,2,0,-3,5];var max = Math.max(...arr);console.log(max); 2.call()法12var max = Math.max.call(null,7,2,0,-3,5)console.log(max) 3.sort()+reverse()后，获取第0个1234var arr = [7,2,0,-3,5];//sort()排序默认为从小到大，reverse()将数组反转var max = arr.sort().reverse()[0];console.log(max); 4.sort()b-a后获取第0个123456var arr = [7,2,0,-3,5];//b-a从大到小，a-b从小到大var max = arr.sort(function(a,b)&#123; return b-a;&#125;)[0];console.log(max)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习canvas]]></title>
    <url>%2F2018%2F02%2F28%2F%E5%AD%A6%E4%B9%A0canvas%2F</url>
    <content type="text"><![CDATA[基本语法12345678910111213&lt;canvas width="300" height="300" id="canvas"&gt;&lt;/canvas&gt;&lt;script type="text/javascript"&gt; var canvas = document.getElementById('canvas'); var ctx = canvas.getContext('2d');//获取canvas的2d上下文 //必须先给颜色，再画图，顺序不能错！！！ ctx.fillStyle = 'red';//填充色 ctx.fillRect(10, 10, 100, 100);//在(10,10)处画一个100x100的填充矩形(fillRect) ctx.fillStyle = 'red';//描边色 ctx.strokeRect(10, 10, 100, 100);//描边矩形&lt;/script&gt; 设置画布高度canvas设置宽高时，由于它是inline元素，所以先要设置display:block或者vertical-align: top;；然后修改它的属性宽高，而不是css的宽高12345#canvas&#123; display: block; 或者 vertical-align:&#125; 画个矩形12345ctx.fillStyle = 'red';//填充色ctx.fillRect(10, 10, 100, 100);//在(10,10)处画一个100x100的填充矩形(fillRect)ctx.fillStyle = 'red';//描边色ctx.strokeRect(10, 10, 100, 100);//描边矩形 画个三角形123456//画个三角 ctx.beginPath();//老子要开始画图啦！ ctx.moveTo(300,240);//先在(300,240)这取个点 ctx.lineTo(300,300);//连接到(300,300) ctx.lineTo(240,270);//连接到(240,270) ctx.fill();//填充颜色(默认填充最近的ctx.fillStyle的颜色) 画个圆Math.PI表示π,弧度=(Math.PI/180)*角度12345ctx.arc(x, y, 半径, 起始弧度, 结束弧度, 默认顺时针画/设置true逆时针画); ctx.beginPath();//老子要开始画图啦！ ctx.arc(160, 140, 10,0,2*Math.PI);//在(160,140)的位置，画1个半径为10,起始弧度0，终止弧度为2π的圆，默认顺时针画 ctx.fill();//填充颜色 画个圆弧边123ctx.beginPath();//老子要开始画图啦！ctx.arc(190, 170, 50,0,Math.PI/2);//在(160,140)的位置，画1个半径为10,起始弧度0，终止弧度为2π的圆，默认顺时针画ctx.stroke();//描边 画条线(绘制路径)1234567function drawLine(x1,y1,x2,y2) &#123; ctx.beginPath(); ctx.lineWidth = 5; ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); &#125; 橡皮擦123456擦除部分内容ctx.clearRect(50,50,10,10);//在(50,50)这点擦去10x10的矩形【橡皮擦】清屏var paper = document.getElementById('canvas');ctx.clearRect(0,0,paper.width,paper.height);//挖去一个和画布大小一样的矩形【橡皮擦】 保存为图片12345678 var paper = document.getElementById('canvas'); a.onclick = function () &#123; var imgUrl = paper.toDataURL("image/png"); a.href = imgUrl; a.download = '图片.png';//设置保存时的默认名字 &#125;`]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>html</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 JavaScript知识点补充]]></title>
    <url>%2F2018%2F02%2F27%2FJavaScript%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[javascript查漏补缺，一些零碎的知识点的补充 sublime正则替换的用法store.js的使用记得判断是否存在容器12website = store.get('容器1') || website;//从容器1中取出website,如果存在就覆盖原始的website，如果不存在就使用原始的website prompt的使用弹出一个确认框。如果点击取消，则promote返回null，所以要做判断是否点击确定还是取消 键盘事件要加在document身上键盘事件要加在document身上1document.onkeypress = fn1; ev123xxx.onclick= function (ev) &#123; console.log(ev); //可以看到许多和ev有关的内容 &#125; ev.targetev.key和ev.keyCodeev.key直接获取按下哪个键ev.keyCode获取键值 oImg.onerror123oImg.onerror = function (ev) &#123; ev.target.src = &apos;//i.loli.net/2017/11/10/5a051fbc5e183.png&apos;;//如果网络图标下载出错就改用默认图标&#125; open和location.href123456open('//www.qq.com'); //默认新窗口打开open('//www.qq.com', '_blank');//同上open('//www.qq.com', '_self');//在当前窗口打开location.href = '//www.baidu.com'//同上语法糖:location = '//www.baidu.com location 是一个hash对象，location.href 是它的一个属性。在获取时，用location.href在赋值时，可以用location=”//www.xxx” ，也可以用 location.href=”//www.xxx”，两者效果相同 函数封装123456function tag(tagName, attr)&#123; //tag('div', &#123;id:'div1', className:'test'&#125;) var ele = document.creatElement(tagName); for (var key in attr) &#123; //遍历attr里的所有键值对 ele[key] = attr[key]; //div.id=div1, div.className=test &#125; return ele; return多个时要用json123456789101112131415161718function init() &#123; var keys = [ ['q','w','e','r','t','y','u','i','o','p'], ['a','s','d','f','g','h','j','k','l'] ]; var website = &#123; 'q': 'qq.com', 'w': 'weibo.com' &#125;; return &#123; 'keys': keys, 'website': website &#125;&#125;var keys = init().keys; //或写成init()['keys']var website = init().website; //或写成init()['website'] 三元运算123var n = 7;var msg = '数字' + n + '是' + (n % 2 === 0 ? '偶数' : '奇数');console.log(msg); 变量提升所有的变量的声明语句var，都会被提升到代码的头部，这就叫做变量提升12345678console.log(a);//undefinedvar a = 1;等同于var a; //var提升到头部，此时a = undefinedconsole.log(a);a = 1; js命名规范js对大小写敏感，所以var a和var A是不同的。要求：第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。中文是合法的标识符，可以用作变量名。1var 临时变量 = 1; sitch语句。多个if…else连在一起使用的时候，可以转为使用更方便的switch结构。12345678910111213141516171819202122232425262728switch (fruit) &#123; case "banana": // ... break; case "apple": // ... break; default: // ...&#125;每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块var x = 1;switch (x) &#123; case 1: console.log('x 等于1'); case 2: console.log('x 等于2'); default: console.log('x 等于其他值');&#125;// x等于1// x等于2// x等于其他值上面代码中，case代码块之中没有break语句，导致一直执行下去 switch语句采用的是严格相等运算符（===），而不是相等运算符（==） do…while 循环 while循环句末没有分号，而do…while 循环 句末必须要有分号 不管条件是否为真，do…while都会执行一次语句1234567891011do &#123; 语句&#125; while (条件);-----------------var x = 3;var i = 0;do &#123; console.log(i); i++;&#125; while(i &lt; x); break 语句和 continue 语句 break语句用于直接跳出代码块或循环、直接停止。 123456789for (var i = 0; i &lt; 5; i++) &#123; console.log(i); if (i === 3) break; //i==3时跳出去，停止该循环&#125;// 0// 1// 2// 3 continue语句立即终止本次循环，并直接开始下一轮循环。 1234567var i = 0;while (i &lt; 100)&#123; i++; if (i % 2 === 0) continue; console.log('i 当前为：' + i);&#125; 上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环。 如果存在多重for循环，不带label的break语句和continue语句都只针对最内层循环。 跳转标签（label）123456789101112131415161718192021222324252627282930313233343536373839404142标签名: 语句 --------------- top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) break top; console.log('i=' + i + ', j=' + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0上面代码为一个双重for循环，break命令后面加上了top标签，满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。----------------------continue语句也可以与标签配合使用。here: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) continue here; console.log('i=' + i + ', j=' + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// i=2, j=0// i=2, j=1// i=2, j=2上面代码中，continue命令后面有一个标签名here，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环。 null和undefined123456789Number(null) // 05 + null // 5null是一个表示“空”的对象，null转为数字时，自动变成0。---------------Number(undefined) // NaN5 + undefined // NaNundefined是一个表示”此处无定义”的原始值，转为数值时为NaN 空数组（[]）和空对象（{}）对应的布尔值，都是true123456789if ([]) &#123; console.log('true');&#125;// trueif (&#123;&#125;) &#123; console.log('true');&#125;// true js中的科学计数法1234567123e3 // 123000123e-3 // 0.123-3.1e+12 //-3100000000000.1e-23 //1e-24小数点后紧跟5个以上的零，就自动转为科学计数法0.0000003 // 3e-7 js会自动进制转换默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。1234567891011120xff // 2550o377 // 2550b11 // 3----------有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。0888 // 8880777 // 511 判断浏览器是否支持标签的某个属性123判断浏览器是否支持a标签的download属性"download" in document.createElement('a');//true or false 获取移动端坐标123var ev = ev.touches[0];//获取第一个触摸点var x = ev.clientX;由于触摸屏支持多点触控，有好几个touches,所以不能通过ev.clientX获取坐标 移动端必须在ontouchstart时，ev.preventDefault();阻止屏幕的滚动btoa将字符串转成base64123456789101112btoa('stage'); // c3RhZ2U=atob将base64转回字符串atob('c3RhZ2U='); // stage不支持中文，要把中文转成base64，必须加入encodeURI()转码环节btoa('你好') //报错btoa(encodeURI('你好')) // JUU0JUJEJUEwJUU1JUE1JUJEbase64还原成中文需要decodeURI()解码decodeURI(atob('JUU0JUJEJUEwJUU1JUE1JUJE')) //你好注意，encode在中间环节，decode在最终环节 ev.target 和 ev.currentTarget12345678&lt;a href="#" id="a"&gt; &lt;span&gt;111&lt;/span&gt;&lt;/a&gt;a.onclick = function(ev)&#123; console.log(ev.target) // &lt;a href="#" id="a"&gt;&lt;span&gt;111&lt;/span&gt;&lt;/a&gt; console.log(ev.currentTarget) // &lt;span&gt;111&lt;/span&gt;&#125; a.href 和 a.getAttribute(‘href’)1234a.onclick = function () &#123; console.log(a.href);//自动添加http协议 console.log(a.getAttribute('href'));// #about&#125; ele.offsetTop() 和 window.scrollTo(x,y)12var posY = ele.offsetTop;window.scrollTo(0,posY); 缓动效果 建议使用ev.currentTarget替代ev.target过渡完成后执行某个函数transitionend事件该事件在 CSS 完成过渡后触发。1div1.addEventListener('transitionend', fn); 动画结束后执行某个函数animationend事件该事件在 CSS 动画结束播放时触发1div1.addEventListener("animationend", fn); animationiteration 该事件在 CSS 动画重复播放时触发animationstart 该事件在 CSS 动画开始播放时触发 切换到另一个页面时，定时器错乱的解决办法页面失去焦点的意思时，当我们由当前页面切换（此处‘切换’不是指的链接跳转）到另一个页面时，当前页面就失去了焦点，如果我很久才回到当前页面，若该页面中有定时器时（如我们用定时器做的图片轮播），图片就会出现空白，出现该原因是，当当前页面失去焦点时，浏览器会减慢失去焦点页面的资源加载和运行，为获得焦点的页面提供更多的资源。但是我们失去焦点时的页面的定时器还在按程序的规定运行，而浏览器的运行又跟不上，所以就出现空白或卡顿现象。 一旦切换到别的页面，然后重新切换回来时，由于浏览器切换页面js定时器会变缓慢，当重新切换到当前窗口之前变慢的定时器堆积在一起便开始疯狂执行，会出现定时器错乱。 这是因为浏览器本着节省内存的性质，当切换到其他页面时，常用系统页面的定时器不运动，但是动画依然排列，当切换回来的时候，动画加速运动，出现错误，在轮播图之类的页面经常会发生这样的情况。 解决方法：通过浏览器的焦点事件去执行该js（我也是才知道window窗口也是有焦点事件的）12345678var timer=null;window.onfocus=function()&#123; timer=setInterval(autoRun,1000);&#125;window.onblur=function()&#123; clearInterval(timer);&#125; 更好的方法是监听visibilitychange12345678document.addEventListener("visibilitychange", function() &#123; if (document.hidden === true) &#123; clearInterval(timer); &#125; else &#123; timer = setInterval(slide, 2000); &#125; &#125;); 如果您使用的是jQuery，在animate前加上 $(obj).stop(true,true); 可以解决123setInterval(function()&#123; $("div").stop(true,true).animate(&#123;"top":"-20px"&#125;)&#125;,1000); 查看是否支持某个方法或属性12345'onclick' in document // true'onmouseover' in document // true'hidden' in document // true 多重三目运算1234var hidden = 'hidden' in document ? 'hidden' : 'webkitHidden' in document ? 'webkitHidden' : 'mozHidden' in document ? 'mozHidden' : null; 点击页面其他地方关闭弹出层 需要给document添加click事件，而不是body身上，因为body的区域并不是整个页面的宽高，而是与内部文档流的尺寸总和有关 为了防止点击按钮的同时触发document事件，因此需要阻断冒泡 document的点击事件需要改写成节省内存的写法12345678910111213141516171819202122232425262728btn.onclick = function (ev) &#123; popover.style.display = 'block'; &#125; document.onclick = function () &#123;//添加到document上 console.log(1); //浪费内存 popover.style.display = 'none'; &#125; wrapper.onclick = function (ev) &#123; ev.stopPropagation();//阻止冒泡 &#125;上面这种写法浪费内存，因为只要点击document就会触发它的click事件$('#btn').click(function() &#123; $('#popover').show(); $(document).one('click', function() &#123; //在click事件里，给父级加上了另一个事件，这个事件会被立刻执行，因此需要给wrapper阻断冒泡，让它在被点击时才执行 console.log(1); //只有弹出层show出来后，才会触发document的click事件，且只触发一次 $('#popover').hide(); &#125;);&#125;);//document的click事件加在了btn函数内部，它会在冒泡阶段直接执行，即使不点击document也会直接执行因此需要阻断冒泡$('#wrapper').click(function(ev) &#123; ev.stopPropagation();&#125;); 图片加载成功或失败图片加载成功时： onload图片加载失败时：onerror123456&lt;img src="image.gif" onerror="alert('图片加载出错')"&gt;&lt;img src="logo.png" onload="success()"&gt;function success()&#123; alert("图片加载完成");&#125; 用console.time获取代码运行时长123console.time();//标记代码开始时间// 代码console.timeEnd();//标记代码结束时间 form的提交监听的是form将submit事件加在整个form上，而不是提交按钮上这样用户按回车也能提交表单1form.onsubmit = fn; Date对象的日期格式化toLocaleString() 中国时间12var d=new Date();var n=d.toLocaleString(); //2018/3/29 上午10:42:13 1234567891011121314151617Date() //中国时间Date.now() //时间戳 1523521282634var d = new Date();d.toLocaleString() //中国时间console.log(d); // 输出：Mon Nov 04 2013 21:50:33 GMT+0800 (中国标准时间)console.log(d.toDateString()); // 日期字符串，输出：Mon Nov 04 2013console.log(d.toGMTString()); // 国外时间，GMT格式，输出：Mon, 04 Nov 2013 14:03:05 GMTconsole.log(d.toISOString()); // 国外时间，ISO格式，输出：2013-11-04T14:03:05.420Zconsole.log(d.toJSON()); // 输出：2013-11-04T14:03:05.420Zconsole.log(d.toLocaleDateString()); // 转换为本地日期格式，视环境而定，输出：2013年11月4日console.log(d.toLocaleString()); // 转换为本地日期和时间格式，视环境而定，输出：2013年11月4日 下午10:03:05console.log(d.toLocaleTimeString()); // 转换为本地时间格式，视环境而定，输出：下午10:03:05console.log(d.toString()); // 转换为字符串，输出：Mon Nov 04 2013 22:03:05 GMT+0800 (中国标准时间)console.log(d.toTimeString()); // 转换为时间字符串，输出：22:03:05 GMT+0800 (中国标准时间)console.log(d.toUTCString()); // 转换为世界时间，输出：Mon, 04 Nov 2013 14:03:05 GMT+0800 console.log(1)的值是什么?答案：打印出1，但是return的值是undefined12var result = console.log(1);result //undefined document.write()1document.write("&lt;h1&gt;Hello World!&lt;/h1&gt;&lt;p&gt;Have a nice day!&lt;/p&gt;") write() 与 writeln() 的区别：点击查看 打字机效果方法一： 方法二： 前面2中的document.write方法不会覆盖前面的内容，而innerHTML会覆盖之前的内容,，此时需要用+=：innerHTML += result[n-1]方法： innerHTML += .slice(n-1,n)方法： 滚动条始终拉到最底下1window.scrollTo(0,document.body.scrollHeight); 移动端触摸touch事件123当按下手指时，触发ontouchstart；当移动手指时，触发ontouchmove；当抬起手指时，触发ontouchend。 用setTimeout+延时递归实现setInterval因为循环定时器的speed一旦设定就无法改变，如果想要实时改变定时器的速度，就要用setTimeout+延时递归实现setInterval 1234567var n = 0;setTimeout(function xxx()&#123; n++; if(n&gt;=10) return; document.body.innerHTML = n; setTimeout(xxx,duration);&#125;,duration); 占位符的用法12var name = 'stage';h1.innerHTML = h1.innerHTML.replace(/&#123;&#123;name&#125;&#125;/ig,name); 利用:empty实现Skeleton Screen(加载占位图/骨架屏)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>js</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2018%2F02%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[本文主要介绍了哈希、队列、栈(stack)、链表、数(tree) 哈希（Hash）满足键值对(‘key’:’value’)的就是哈希。数组就是哈希 计数排序中的桶（复杂度 O(n+max)，比快排还快12345678910111213141516171819202122计数排序：数组[第0个是4，第1个是1，第二个是8......]将数组['0':4,'1':1,'2':8,'3':2,'4':9,'5':8,'length':6 //length等于最大下标index+1]里的值放入桶内hash=[]hash['1':1 //1有1个'2':1'4':1'8':2 //8有2个'9':1] //hash的length=10，因为最大下标index是9然后再从桶里把数值取出来newArr=[]newArr[1,2,4,8,8,9] 123456789101112131415161718192021222324252627282930313233计数排序的js代码var a = [0,2,1,56,4,67,3,2];//存入hashvar hash = &#123;&#125;;for (i=0;i&lt;a.length;i++) &#123; var num = a[i]; if(!hash[num])&#123;//如果还没有对应的hash hash[num] = 1; &#125; else &#123; hash[num]++; &#125;&#125;/* console.log(hash); 结果hash = &#123;0: 1, 1: 1, 2: 2, 3: 1, 4: 1, 56: 1, 67: 1&#125;，表示数字0有1个，数字1有1个，数字2有2个，数字3有1个...... *///从hash中取出var max = Math.max.apply(null,a);//获取hash里的最大值//最大值是max,那么hash的长度length就是max+1;var length = max+1;var result = [];for (i=0;i&lt;length;i++)&#123; var 个数 = hash[i]; if (个数) &#123;//如果不是0个 for (j=0;j&lt;个数;j++) &#123; result.push(i); &#125; &#125; &#125;console.log(result); (桶排序)[http://bubkoo.com/2014/01/15/sort-algorithm/bucket-sort/] 与计数排序的区别 123456789桶排序hash['1':[5,2,8] //第1个桶表示10以内的数有5,2,8，然后将这个桶内的数字二次排序'2':[]'3':[27]'4':[33,37,31] //40以内的数有33,37,31,将这几个数字二次排序]与计数排序的区别：假设数组中最大的数是1000，那么计数排序需要1000个桶，而桶排序(如果每个桶的区间是100一分割),那么只需要10个桶，但是桶内的数们需要二次排序 (基数排序)[http://bubkoo.com/2014/01/15/sort-algorithm/radix-sort/] 与计数排序的区别 1基数排序始终只有10个桶，按照个位、十位、百位、千位.....的数值进行比较,每个桶里的数们组成队列，先进先出 队列（Queue） 先进先出 可以用数组实现 举例：排队1var out = arr.shift() 栈（Stack） 先进后出 可以用数组实现 举例：坐电梯1var out = arr.pop() 链表（Linked List） 数组无法直接删除中间的一项，链表可以 用哈希（JS里面用对象表示哈希）实现链表(一个哈希指向另一个哈希) 123456789101112131415161718192021[0,2,1]var a = &#123;value:0, next:&#123; value:2, next:&#123; value:1, next:undefined &#125; &#125;&#125;a.value //0a.next.value //2a.next.next.value //1删除中间的2:a.next = a.next.next //将a.next指向a.next.nexta.value //仍旧是0a.next.value //变成了1a.next.next.value //undefined head、node 概念 12head：链表的表头node：节点，表头属于第一个节点 树（tree）https://segmentfault.com/a/1190000000740261 举例：有层级结构的需要用到tree，比如DOM树 概念：层数(第0层、第1层、第2层…)、深度(总共有几层)、节点个数(没有下一个节点的叫做叶子节点) 二叉树 满二叉树 完全二叉树 完全二叉树和满二叉树可以用数组实现 123456789arr=[1,2,3,4,5,6,7,8,9,10,11,12,13,15,15]如何取第3层的第1个数字？arr[Math.pow(2,3-1)-1] //4 【2的3减1次方后减1】如何取第3层的第2个数字？arr[Math.pow(2,3-1)-1+1]如何取第3层的第3个数字？arr[Math.pow(2,3-1)-1+2] 其他树可以用哈希（对象）实现 操作：增删改查 堆排序用到了 tree 1.将数组里的数表示成完全二叉树2.然后进行最大堆调整【每个父节点的数值都大于等于其两个孩子结点的数值】：从最后一层的最右边开始到最左边，然后上一层的最右边到最左边，每发生一次交换时，踢下来的数都需要与子节点再次比较3.最终，最上面的那个数就是最大的数，把他与最后一个数交换(即放到数组的最后一位)，且这个最大数不再参与排序4.由于顶上的数发生了交换，所以继续进行顶上的数与两个子节点比较(也就是说，一开始是从右往左，从下往上比较；当第一次最大堆调整完后，将顶点的数与最后一个数进行交换；接下来就是从上到下进行比较了) 12345671.将数组里的数表现成完全二叉树的形式2.进行最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点3.创建最大堆：将堆所有数据重新排序，使其成为最大堆此时最顶端(根节点)的数就是最大的数4.将根节点的数和最后一个数交换位置，并将最大数挪出，不参与下一轮的排序5.由于第4步根节点发生了变化，所以剩余的堆需要继续调整为最大堆6.重复2~5的过程，直到剩余数只有一个时结束。 其他：B树、红黑树、AVL树 堆排序可视化https://www.cs.usfca.edu/~galles/visualization/HeapSort.html 堆排序JS代码完整讲解（看到最后）：http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法初级]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%AE%97%E6%B3%95%E5%88%9D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[排序算法列表https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#排序算法列表 冒泡排序 http://bubkoo.com/2014/01/12/sort-algorithm/bubble-sort/ 插入排序 http://bubkoo.com/2014/01/14/sort-algorithm/insertion-sort/ 桶排序 http://bubkoo.com/2014/01/15/sort-algorithm/bucket-sort/ 常见排序算法归档：http://bubkoo.com/tags/algorithm/ 算法的5个特征 输入：一个算法必须有零个或以上输入量。 输出：一个算法应有一个或以上输出量，输出量是算法计算的结果。 明确性：算法的描述必须无歧义，以保证算法的实际执行结果是精确地匹配要求或期望，通常要求实际运行结果是确定的。 有限性：算法必须在有限个步骤内完成任务。 有效性：又称可行性，能够实现，比如：通过代码让电脑生个孩子出来是不可行的。 数据结构就是数据的结构。 一般来说是这样的： 我们要解决一个跟数据相关的问题 分析这个问题，想出对应的数据结构 分析数据结构，想出算法 先分析数据的结构，再想出对应的算法数据结构和算法是互相依存、不可分开的 你学习完排序算法，就能了解常见的数据结构 5种排序算法 身高两两对比法（冒泡排序,按顺序两两对比交换位置） 12345678910111213141516171819202122232425以数组 arr = [5, 1, 4, 2, 8] 为例说明，加粗的数字表示每次循环要比较的两个数字：第一次外循环( **5 1** 4 2 8 ) → ( **1 5** 4 2 8 )， 5 &gt; 1 交换位置( 1 **5 4** 2 8 ) → ( 1 **4 5** 2 8 )， 5 &gt; 4 交换位置( 1 4 **5 2** 8 ) → ( 1 4 **2 5** 8 )， 5 &gt; 2 交换位置( 1 4 2 **5 8** ) → ( 1 4 2 **5 8** )， 5 &lt; 8 位置不变第二次外循环（除开最后一个元素8不动，对剩余的序列）( **1 4** 2 5 8 ) → ( **1 4** 2 5 8 )， 1 &lt; 4 位置不变( 1 **4 2** 5 8 ) → ( 1 **2 4** 5 8 )， 4 &gt; 2 交换位置( 1 2 **4 5** 8 ) → ( 1 2 **4 5** 8 )， 4 &lt; 5 位置不变8固定在最后第三次外循环（除开已经排序好的最后两个元素，可以注意到上面的数组其实已经排序完成，但是程序本身并不知道，所以还要进行后续的循环，直到剩余的序列为 1）5,8固定不变( **1 2** 4 5 8 ) → ( **1 2** 4 5 8 )( 1 **2 4** 5 8 ) → ( 1 **2 4** 5 8 )4,5,8固定不变第四次外循环（最后一次）( *1 2* 4 5 8 ) → ( *1 2* 4 5 8 ) 体育老师一指禅法（选择排序,每次从一堆中选出最小的那个数排到最前面，然后后面剩余的数重复这个步骤） 整理扑克牌法（插入排序） 桌上散落的扑克牌整理法（桶排序、基数排序） 快排(每次快排择第一个数作为基准分割左右) 随机快排(每次快排随机选择一个数站定分割左右) 归并排序 堆排序 排序算法js代码https://www.cnblogs.com/Unknw/p/6346681.html 排序可视化排序可视化：https://visualgo.net/zh/sorting]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 css知识点补充]]></title>
    <url>%2F2018%2F02%2F23%2Fcss%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[css知识点查漏补缺，知识点补充，比较零碎 文档流文档流：文档内 元素流动的方向。inline元素从左往右流动→，如果宽度不够另挤一行block元素独占一行，从上往下流动↓ 块级元素块级元素的高度由其 内部文档流元素 的 高度总和 决定 块级元素居中margin:0 auto; 内联元素的高度多个内联元素以baseline对齐内联元素如果同处一个块元素内，那么按照基线对齐(可以通过vertical-align来设置内联元素对齐方式)可以看到，x不是在div的正中间，而是与hug的基线对齐 渐变gradient 在线渐变生成器:http://www.colorzilla.com/gradient-editor/ 设置dib后，一定要加上vat12display: inline-block;vertical-align: top; text-transform: uppercase将字母变成大写 利用box-shadow实现多层边框(立体感)12box-shadow: 向左 向下 模糊程度 一个不模糊的边框 内阴影inset;box-shadow: 0 0 0 1px #1a1b1c, 0 0 0 2px #1f2020, 0 3px 0 1px #080808; 100vh使元素的高度占满可视区高度12div&#123;height: 100vh&#125;再利用flex就可以使元素内的item相对于可视区居中 icon图标123将favicon.ico放在根目录下如果要获取其他网站的icon，可以通过 //该网站根目录/favicon.ico比如 //www.qq.com/favicon.ico 就可以获得qq的icon overflow:hidden别给老子出现滚动条！当元素设置了 absolute 后，默认就不是100%的宽度了，而是内容多宽就是多宽当元素设置了 absolute 后，默认就不是100%的宽度了，而是内容多宽就是多宽如果希望absolute 以后的元素依然和父容器一样是的100% 宽度有两个方法： 给子级设置 width:100% 给子级设置left:0px;right:0px; min-width和max-widthmin-width:无论如何，都不会小于这个宽度max-width:无论如何，都不会比这个宽度大 多色border123456.box&#123; border:50px solid red; width:0; height:0; border-color:red yellow green blue&#125; 多色三角形变形1234567.box&#123; border:50px solid red; width:0; height:0; border-color:red yellow green blue; border-width:10px 30px 50px 80px&#125; 扇形1234567.box&#123; border:50px solid black; width:0; height:0; border-color:red yellow green blue; border-radius: 50%;&#125; 渐变动画加载图 利用background-size: 200% auto将背景在x轴扩大，然后改变background-position的位置达到渐变动画的效果]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 前端学习记录]]></title>
    <url>%2F2018%2F02%2F23%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[- 9.HTML 续http-server的安装视频iframe和a这一节有介绍 10.入门css知识点 如何做横向布局（float + clearfix） 继承样式inherit 四种引入 CSS 的方式：行间样式、内部样式、外部样式、@import 作业完成简历的logo和top-navbar 11.CSS 布局与定位知识点 尽量不要设置width和height，通过调节padding来自适应. 用max-width代替width，这样当屏幕小于这个width时会自适应缩放 高度是由什么决定的 什么是文档流【文档内元素流动的方向】 内联元素 与 块级元素 line-box 是啥 box 是啥（盒模型） 宽度是有什么决定的 position 的 5 个取值 脱离文档流 background-size:cover z-index 作业 大背景图 大名片card 12.CSS 布局与定位续知识点 太极图12线性渐变background: linear-gradient(to bottom, white 0%,white 50%,black 50%,black 100%);:before,:after伪元素 作业 制作下载按钮 技能百分比条 非线性布局1234设置dib后，一定要加上vatdisplay: inline-block;vertical-align: top; 13.命令行 HTTP Node.js HTML CSS 小结命令行复习123456789101112131415161718192021222324252627pwd progress working dircd change dirmkdir make dirtouch echo &quot;hi&quot; &gt; 1.txtecho &quot;hi&quot; &gt;&gt; 1.txtecho &quot;hi&quot; &gt;! 1.txtcp -rrm -rfmvtree git initgit addgit commit -m &quot;hi&quot;git pullgit pushgit clonecurl -L http://baidu.comcurl -s -v -- http://baidu.comping qq.comhexo inithexo ghexo serverhexo deploy HTTP请求与响应复习 请求包括 GET(获取) POST(上传) PUT(整体更新) PATCH(局部更新) DELETE(删除) HEAD OPTIONS等 能够手写http请求，能够手写http响应 Content-Type: application/x-www-form-urlencoded : 应用数据/还没有写入规范的格式-万维网-表单-用urlencode形式压缩 知道状态码的含义 TCP/IP协议 Node.jsServer14.算法初级 排序算法列表 https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#排序算法列表 冒泡排序 http://bubkoo.com/2014/01/12/sort-algorithm/bubble-sort/ 插入排序 http://bubkoo.com/2014/01/14/sort-algorithm/insertion-sort/ 桶排序 http://bubkoo.com/2014/01/15/sort-algorithm/bucket-sort/ 其他排序：http://bubkoo.com/tags/algorithm/ 快排、随机快排 排序算法js代码https://www.cnblogs.com/Unknw/p/6346681.html 15.数据结构哈希、队列、栈(stack)、链表、数(tree) 计数排序(有多少个数就有多少个桶)与桶排序(自定义一个范围桶)与基数排序(始终10个桶) 队列：先进先出，arr.shift() 栈：先进后出，arr.pop() 链表，可以用来删除数组中间的某个数 12345678910var a = &#123;value:0, next:&#123; value:2, next:&#123; value:1, next:undefined &#125; &#125;&#125; 树堆排序:https://www.cs.usfca.edu/~galles/visualization/HeapSort.html 16.JavaScript 初体验做一个键盘导航代码和预览：https://github.com/FrankFang/nav-demo text-transform: uppercase将字母变成大写 sublime正则替换的用法for循环创建divstore.js的使用记得判断是否存在容器12website = store.get('容器1') || website;//从容器1中取出website,如果存在就覆盖原始的website，如果不存在就使用原始的website create元素和append元素prompt的使用如果点击取消，则promote返回null，所以要做判断是否点击确定还是取消 键盘事件要加在document身上这个事件加在document身上1document.onkeypress = fn1; ev123xxx.onclick= function (ev) &#123; console.log(ev); //可以看到许多和ev有关的内容 &#125; ev.targetev.key和ev.keyCodeev.key直接获取按下哪个键ev.keyCode获取键值 open和location.href12345open('http://www.qq.com'); //默认新窗口打开open('http://www.qq.com', '_blank');//同上open('http://www.qq.com', '_self');//在当前窗口打开location.href = 'http://www.baidu.com'//同上 17.第一个 JS 作品完善上一节课的键盘导航键盘参考：http://mcdlr.com/key-sheet/代码参考：https://github.com/FrankFang/nav-demo/ 知识点渐变色1background: linear-gradient(to bottom,#292929,#111); 利用box-shadow实现多层边框(立体感)12box-shadow: 向左 向下 模糊程度 一个不模糊的边框 内阴影inset;box-shadow: 0 0 0 1px #1a1b1c, 0 0 0 2px #1f2020, 0 3px 0 1px #080808; 100vh使元素的高度占满可视区高度12body&#123;height: 100vh&#125;再利用flex就可以使元素内的item相对于可视区居中 ico图标123将favicon.ico放在根目录下如果要获取其他网站的icon，可以通过 //该网站根目录/favicon.ico比如 //www.qq.com/favicon.ico 就可以获得qq的icon oImg.onerror123oImg.onerror = function (ev) &#123; ev.target.src = &apos;//i.loli.net/2017/11/10/5a051fbc5e183.png&apos;;//如果网络图标下载出错就改用默认图标&#125; 函数封装123456function tag(tagName, attr)&#123; //tag('div', &#123;id:'div1', className:'test'&#125;) var ele = document.creatElement(tagName); for (var key in attr) &#123; //遍历attr里的所有键值对 ele[key] = attr[key]; //div.id=div1, div.className=test &#125; return ele; return多个时要用一个对象123456789101112131415161718function init() &#123; var keys = [ ['q','w','e','r','t','y','u','i','o','p'], ['a','s','d','f','g','h','j','k','l'] ]; var website = &#123; 'q': 'qq.com', 'w': 'weibo.com' &#125;; return &#123; 'keys': keys, 'website': website &#125;&#125;var keys = init().keys; //或写成init()['keys']var website = init().website; //或写成init()['website'] 18.Canvas画板知识点鼠标事件123document.onmousemove = fn1;document.onmousedown = fn1;document.onmouseup = fn1; canvas canvas设置宽高时，由于它是inline元素，所以先要设置display:block或者vertical-align: top;；然后修改它的属性宽高，而不是css的宽高 19.手机端画板添加viewport方法:meta:vp + tab touch方法 手机端没有鼠标，所以不能用onmouse方法，而应该用ontouch方法 123元素.ontouchstart = fn;元素.ontouchmove = fn;元素.ontouchend = fn; 判断是否支持touch方法(特性检测) 1234567if (document.body.ontouchstart !== undefined) &#123; //是触屏设备&#125; else &#123; //是非触屏设备&#125; 判断浏览器是否支持标签的某个属性123判断浏览器是否支持a标签的download属性"download" in document.createElement('a');//true or false 判断是否是移动设备1234567891011在w3school上看到可以这样来判断平台：function checkStation()&#123; var info = navigator.userAgent; if(info.indexOf("iPod")!=-1 || info.indexOf("iPad")!=-1 || info.indexOf("iPhone")!=-1 || info.indexOf("Android")!=-1)&#123; alert("平板"); return true; &#125;else&#123; alert("电脑"); return false; &#125;&#125; 获取触摸坐标123var ev = ev.touches[0];//获取第一个触摸点var x = ev.clientX;由于触摸屏支持多点触控，有好几个touches,所以不能通过ev.clientX获取坐标 移动端必须在ontouchstart时，ev.preventDefault();阻止屏幕的滚动iconfont的使用 批量去色有些icon有默认色，为了icon颜色统一，建议批量去色选择完icon并添加至项目后，选择批量操作里的批量去色 局域网调试利用http-server进行局域网调试 20.JS里的7种数据 number string boolean symbol undefined null object 21.类型转换btoa将字符串转为base64类型转换5个falsy值内存图面试题-对象的引用面试题-垃圾回收面试题-深拷贝vs浅拷贝22.JS里的对象全局函数1.Numbervar n = new Number(1) 创建一个 Number 对象1 与 new Number(1) 的区别是什么？看内存图2.Stringvar s = new String(‘hello’) 创建一个 String 对象‘hello’ 与 new String(‘hello’) 的区别是什么？看内存图3.Booleanvar b = new Boolean(true) 创建一个 Boolean 对象true 与 new Boolean(true) 的区别是什么？看内存图4.Objectvar o1 = {}var o2 = new Object()o1 和 o2 没区别 原型prototypevar 对象 = new 全局函数() //函数包括Number(123)/String(‘123’)等全局函数对象.proto === 全局函数.prototype 23.给简历加 JS loading 动画 会变的navbar ， sticky navbar 鼠标滚动后导航栏黏着 会动的二级菜单menu 点击导航栏自己滚动到对应那一块 auto scroll smoothy chrome控制动画速度选中动画元素Elements → 点击三个点(更多) → More tools → Animations里控制动画的速度 scrollYvar y = scrollY;//window.scrollY,window可省略 字体颜色inheritev.target 和 ev.currentTargetxxx.tagName.toLowerCase()if (xxx.tagNamea.toLowerCase() == ‘ul’) a.href 和 a.getAttribute(‘href’)1234a.onclick = function () &#123; console.log(a.href);//自动补充完整http协议 console.log(a.getAttribute('href'));// #about&#125; ele.offsetTop() 和 window.scrollTo(x,y)12var posY = ele.offsetTop;window.scrollTo(0,posY); 24.给简历加 JS（续）平滑滚动smooth scroll tween.js滚动监听scrollspy检测元素出现在可视区12345678910111213141516171819&lt;div id="a"&gt;&lt;/div&gt;&lt;div id="b"&gt;&lt;/div&gt;&lt;div id="c"&gt;&lt;/div&gt;&lt;script&gt; var viewport = document.documentElement.clientHeight; var eles = document.querySelectorAll('div'); window.onscroll = function () &#123; for (var i = 0; i &lt; eles.length; i++) &#123; var eleCurrentTop = eles[i].getBoundingClientRect().top;//必须放在for循环里！ if(eleCurrentTop &lt; viewport-100)&#123; //alert('出现在可视区'); eles[i].classList.add('active'); &#125; &#125; &#125;&lt;/script&gt; 技能条加载动画25.JS 数组Array数据类型new不new的区别伪数组数组的操作(api)26.函数Function函数的声明方法eval()函数的调用call、this、arguments面试题call stack调用栈作用域面试题闭包27.DOM API文档对象模型 DOM各种api的操作28.jQuery 不过如此三等号===三等号 NaN永远不等于NaN对象永远不等于对象，因为他们在stack区的Address地址不一样 封装自己的js库jquery原理29.用 jQuery 做个轮播吧DOM作业讲解在使用querySelector方法时，遇到DOM树增加或删除,需要重新获取 jquery作业讲解jquery实现轮播图 index()，eq()的相互结合 取模的运用 trigger()的用法 30.无缝轮播 过渡结束事件transitionend的用法 放慢速度查看动画效果：chrome -&gt; 更多选项(三个点) -&gt; more tools -&gt; animations 切换到另一个页面时，为了防止定时器错乱，需要监听visibilitychange addEventListener() DOM事件，捕获和冒泡 31.期中考试32.DOM事件 点击其他地方关闭浮层 节省内存的写法.one() 可左右切换的无缝轮播图 33.JSONP 是什么鬼 git reset 后悔药id --hard 动态创建scrip标签用来发送请求 script标签创建后自动执行，执行完后ev.currentTarget.remove()将其删除 jsonp 34.AJAX 是什么鬼 背出XMLHttpRequest的写法 console.time();要执行的代码;console.timeEnd(); 可以得到代码执行时长 json里面的字符串必须用双引号 从后端获取的数据是字符串类型，需要通过JSON.parse(字符串)转成JS对象 chrome开发者工具 → Network → Network → 点击preserve log(页面刷新时不清楚日志) 35.自己实现 AJAX ajax设置http请求headers的4部分 ajax获取http响应headers的4部分 浏览器从输入网址回车到呈现页面的过程 封装jQuery.ajax ES6解构赋值的用法 Promise的用法 36.把 MVC 的 VC 加到简历里 简历中引入swiper的使用 模块化 -&gt; 立即执行函数，变量互不影响 立即执行函数,闭包 MVC的VC 37.给简历加个数据库 免费服务器leancloud Date对象的toLocaleString()方法 MVC的M 38.js高级基础知识考试39.来，面向对象编程吧！ 命名空间 理解var app = app || {} Class 类 复习this new一个构造函数时到底做了些什么 41.会动的简历 完整代码：https://github.com/FrankFang/animating-resume预览：https://frankfang.github.io/animating-resume/vue.js 版本：https://jirengu-inc.github.io/animating-resume/public/vue.js 版本源码：https://github.com/jirengu-inc/animating-resume &lt;pre&gt;标签，保留多个空格和回车换行,&lt;pre&gt;显示多行代码，&lt;code&gt;显示一行代码，&lt;pre&gt;可以替代&lt;code&gt; 代码高亮插件(关键词js syntax lib):prism.js或者hightlight.js 初识异步(先写的代码排在后面才执行) 初识回调 promise window.scrollTo(0,document.body.scrollHeight),使得滚动条始终拉到最底下 插件marked.js的用法 42.画一只皮卡丘 手机端的宽度最好控制在320px以内 扇形的制作 npm(yarn)的使用，以及忽略node_modules，防止里面的所有插件都提交到git node_modules里的jquery不忽略的方法 自定义属性data-的用法 因为循环定时器的speed一旦设定就无法改变，所以要用setTimeout+延时递归实现setInterval 用命令行将第三方插件从node_modules拷贝到vendor文件夹下 chrome的disable-cache的使用 43.Cookie与登录注册 复习浏览器请求与响应 做一个登入注册 用curl向后端发请求 cookie的设置和获取 44.Session、LocalStorage、Cache-Control 服务器通过cookie发送给浏览器sessionID(随机数) sessionStorage localStorage web性能优化：HTTP缓存 用curl -L https://cdn.bootcss.com/xxx.js &gt;&gt; main.js将其写入本地的main.js文件 cache-control Expires Etag Last-Modified 45.初识 webpack 前端工程化 sass的使用，用命令行将sass自动转成css 用Bable将es6自动转成es5 命令行CLI 46.从 MVC 到 MVVM axios的使用，请求数据，伪造数据 es6的解构赋值 通过jq的事件委托，使得DOM结构被更改时原来的按钮仍然能被触发 从jquery到mvc再到mvvm 用vue做显示helloworld、轮播、tab切换 47.2018年前端面试押题48.简历 简历的制作及投递，分析HR的心态 LeanCloud获取最新的10条留言 一些amazing的库 49.毕设：网易云音乐 需求分析 LeanCloud的使用 git bash的使用(gitignore忽略)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[空元素与可替换元素]]></title>
    <url>%2F2018%2F02%2F22%2F%E7%A9%BA%E6%A0%87%E7%AD%BE%E4%B8%8E%E5%8F%AF%E6%9B%BF%E6%8D%A2%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[空元素，不需要闭合的元素;没有伪元素:before和:after可替换元素,它的展现不由CSS来控制 空元素，不需要闭合的元素空元素没有伪元素:before和:after1234567891011121314151617&lt;br&gt;&lt;hr&gt;&lt;link&gt;&lt;meta&gt;&lt;img&gt;&lt;input&gt;&lt;area&gt;&lt;base&gt;&lt;col&gt;&lt;colgroup&gt; when the span is present&lt;command&gt;&lt;embed&gt;&lt;keygen&gt;&lt;param&gt;&lt;source&gt;&lt;track&gt;&lt;wbr&gt; 可替换元素,它的展现不由CSS来控制12&lt;img&gt;、 &lt;object&gt;、 &lt;video&gt; 、&lt;textarea&gt;、 &lt;input&gt;、&lt;audio&gt; 和 &lt;canvas&gt;这类元素一开始就有样式，比如img的宽高由引入的图片大小决定]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒 html知识点补充]]></title>
    <url>%2F2018%2F02%2F22%2Fhtml%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[html知识点补充，查漏补缺，比较零碎 iframe 标签嵌套页面12&lt;iframe src="https://www.baidu.com" name="qqqqq" width=100% height=200 &gt;&lt;/iframe&gt;&lt;a href="https://www.qq.com" name="qqqqq"&gt;在name=qqqqq的iframe中打开&lt;/a&gt; a 标签跳转页面（HTTP GET 请求） download属性123456&lt;a href="xxxx" download&gt;下载链接&lt;/a&gt;&lt;a href="http://www.xxx.com/3.png" download="3.png"&gt;下载图片3.png&lt;/a&gt;加上download属性，就会下载下来否则就是用浏览器打开预览文件download="文件名"用js可以操作文件名，比如a.download = imgName + '.png'; target属性12345&lt;a target="_blank|_self|_parent|_top|framename"&gt;_blank 在新窗口中打开_self 在a标签所在的页面中打开_parent 在a标签所在页面的父级窗口中打开_top 如果嵌套iframe,就在最顶层（也就是当前页面）中打开 href属性1234567891011121314151617181920212223绝对路径&lt;a href="www.qq.com"&gt;错误！！！！漏了协议&lt;/a&gt;&lt;a href="https://www.qq.com"&gt;正确，https协议&lt;/a&gt;&lt;a href="//www.qq.com"&gt;正确,自定义协议&lt;/a&gt;相对路径&lt;a href="./xxx.html"&gt;&lt;/a&gt;结果打开127.0.0.1:8080/xxx.html&lt;a href="#锚点"&gt;&lt;/a&gt;结果打开127.0.0.1:8080/index.html#锚点，锚点不发起请求&lt;a href="?name=stage"&gt;&lt;/a&gt;结果打开127.0.0.1:8080/index.html?name=stage,自动发起 ?name=stage 的GET请求&lt;a href="javascript:;"&gt;&lt;/a&gt;点击之后什么都不发生&lt;a href="#"&gt;&lt;/a&gt;点击之后不刷新，锚点变成#，滚回到顶部&lt;a href=""&gt;&lt;/a&gt;点击之后刷新当前页面 form12345678&lt;form action="index2.php" method="get"&gt; First name: &lt;input type="text" name="fname"&gt;&lt;br&gt; Last name: &lt;input type="text" name="lname"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;将fname=xxx&amp;lname=xxx提交到index2.php中文会转码 method属性 GET时，如果有提交的数据，数据会作为查询参数出现在地址栏127.0.0.1::8080/index.html?fname=xxx&amp;lname=xxx POST时，用Chrome开发者工具可以看到，数据在Form Data里 重点如果一个表单中没有input-submit时 如果有&lt;button&gt;没有写type的按钮&lt;/button&gt;，该button自动升级为type=submit，可以提交表单 如果写了type=button，则无法提交表单 label1234567891011&lt;label for="male"&gt;文字&lt;/label&gt;&lt;input type="checkbox" name="male" id="male"&gt;这样点击文字也能选中复选框，请将label的for与input的id名对应---------------------简便写法：label把input包起来&lt;label&gt;文字&lt;input type="checkbox" name="male"&gt;&lt;/label&gt;这样就不用for和id名了 select1234567&lt;select name=&quot;choose&quot; multiple&gt; &lt;option value=&quot;&quot;&gt; - &lt;/option&gt; &lt;option value=&quot;1&quot; selected&gt;默认&lt;/option&gt; &lt;option value=&quot;2&quot; disabled&gt;禁选&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;4&lt;/option&gt;&lt;/select&gt; multiple属性该属性允许多选对于 windows：按住Ctrl按钮来选择多个选项 table可以用colgroup&gt;col控制表格的样式，第一个col控制第一竖列，第二个col控制第2竖列123456789101112131415161718192021222324252627&lt;table border=&quot;1&quot;&gt;&lt;colgroup&gt; &lt;col width=200&gt; &lt;col bgcolor=red&gt;&lt;/colgroup&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;得分&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt;&lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小红&lt;/td&gt;&lt;td&gt;80&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;所有人&lt;/td&gt; &lt;td&gt;180&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 和 &lt;pre&gt;标签，保留多个空格和回车换行,&lt;pre&gt;显示多行代码，&lt;code&gt;显示一行代码，&lt;pre&gt;可以替代&lt;code&gt;]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>笔记</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 与 Node.js服务器]]></title>
    <url>%2F2018%2F02%2F21%2FTCPIP%E4%B8%8ENodejs%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[TCP/IP 是供已连接因特网的计算机进行通信的通信协议。HTTP 协议的底层其实是由 TCP 协议(规定如何传输)和 IP 协议(规定如何连网)（简称 TCP/IP协议）构建的。TCP和UDP的区别三次握手和四次挥手用node.js做服务器，并发出http响应 资料：菜鸟教程 - 学习TCP/IP TCP 传输控制协议（Transmission Control Protocol）TCP面试题问：TCP 和 UDP 的区别是什么简答：TCP 可靠(能够知道发送的请求是否成功)、面向连接、相对 UDP 较慢；UDP 不可靠，不面向连接、相对 TCP 较快。 补充： 什么叫面向连接呢？事先为所发送的数据开辟出连接好的通道，然后再进行数据发送。【像打电话，只能两人打，第三人打就显示占线。】 非面向连接：是指通信双方不需要事先建立一条通信线路，而是把每个带有目的地址的包（报文分组）送到线路上，由系统自主选定路线进行传输。【就像写信，不管对方有多忙，把信放到邮筒，就与自己无关系了。】 问：TCP 的三次握手指的是什么简答：每次建立连接前，客户端和服务端之前都要先进行三次对话，成功后才开始正式传输内容，三次对话大概是这样的： 客户端：我要连接你了，可以吗（浏览器向服务器发送建立连接的请求。） 服务端：嗯，我准备好了，连接我吧（服务器接收到浏览器发送的请求后，向浏览器发送同意连接的信号。） 客户端：那我真的连接你咯。（浏览器接受到服务器发出的同意连接的信号后，再次向服务器发出确认连接的信号。） 三次握手完成，客户端和服务端成功的建立TCP连接，就可以开始传输数据了。(客户端发送http请求的4个部分给服务端，服务端接收请求并处理后，发送http响应的4个部分给客户端。客户端接收响应) 这是因为，TCP要建立连接，必须确认4件事 客户端可以发请求 服务端可以收请求，服务端可以发请求 客户端可以收请求 问：TCP 的四次挥手指的是什么答： 浏览器向服务器发送一个断开连接的请求（你把我断开吧）； 服务器接到请求后发送确认收到请求的信号（知道了）； 服务器向浏览器发送断开通知（那我把你断开咯？）； 浏览器接到断开通知后断开连接并反馈一个确认信号（嗯，你断吧），服务器收到确认信号后断开连接 为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所以服务器先发送确认信号，等所有数据发送完毕后再同意断开。 IP 网络协议（英语：Internet Protocol）IP 分为「内网 IP」 和「外网 IP」 路由器有两个 IP，一个外网 IP（每次重启路由器后会重新分配一个新的外网IP）和一个内网 IP（192.168.1.1） 127.0.0.1 localhost 本地ip,表示设备自己 还有一个特别特殊的 IP：0.0.0.0，它不表示任何设备。 端口(Port)如果一个服务器既提供 HTTP 服务，又提供 FTP 服务，还提供 SMTP 服务（邮件服务），那么只用一个 IP 是无法告诉服务器你想要使用哪种服务。 所以这里有一个重要的原则：一个端口对应一个服务。 要提供 HTTP 服务使用 80 端口 12访问https://www.baidu.com实际上是访问https://www.baidu.com:80浏览器帮你加了默认端口号 80。 要提供 HTTPS 服务使用 443 端口 要提供 FTP 服务使用 21 端口 总结：使用 HTTP 协议访问另一个 IP 时，必须同时提供 IP 和端口号，缺一不可。 用Node.js创建一个服务器接收请求我们的脚本只需要一个文件就可以搞定 新建一个目录cd ~/Desktop; mkdir node-demo; cd node-demo touch server.js 编辑 server.js，内容我已经上传到 GitHub。 或者curl https://raw.githubusercontent.com/FrankFang/nodejs-test/7f1a0ce15c47a6c2c938fe322f042e5d62bc7d01/server.js &gt; ./node-demo/server.js将代码下载到server.js文件内 运行 node server.js，看到报错 根据报错提示调整你的命令 成功之后，这个 server 会保持运行，持续监听，无法退出 如果你想「中断」这个 server，按 Ctrl + C 即可（C 就是 Cancel 的意思） 中断后你才能输入其他命令 我建议你把这个 server 放在那里别动，新开一个 Bash 窗口，完成下面的教程 curl -s -v -- http://qq.com/xxx?name=ff，其中查询参数是?name=ff,查询参数是包含问号的 好了服务器完成。只不过 这个服务器目前只有一个功能，那就是打印出路径和查询字符串 还缺少一个重要的功能，那就是发出 HTTP 响应 目前我们先只做一个功能玩玩。 接下来你要发起一个请求到这个服务器。这听起来有点怪异，「我向自己发起请求」，目前是的，因为你买不起服务器啊。 在新的 Bash 窗口运行 curl http://localhost:你的指定的端口/xxx?name=yyyy 或者 curl http://127.0.0.1:你指定的端口/xxx?name=yyyy。 你会马上发现 server 打印出了路径： 这说明我们的 server 收到了我们用 curl 发出的请求由于 server 迟迟没有发出响应，所以 curl 就一直等在那里，无法退出（用 Ctrl + C 中断这个傻 curl） 发出响应接下来我们让我们 server 发出响应 编辑 server.js 在中间我标注的区域添加两行代码 12345678910console.log(&apos;方方说：得到 HTTP 路径\n&apos; + path)if (path == &apos;/&apos;) &#123; response.write(&apos;Hi\n&apos;) &#125; else if (path == &apos;/index&apos;) &#123; response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;) response.write(&apos;&lt;!DOCTYPE html&gt;\n&lt;head&gt;&lt;body&gt;&lt;h1&gt;你好&lt;/h1&gt;&lt;/body&gt;&lt;/head&gt;&apos;)&#125; else &#123; response.statusCode = 404&#125;response.end() Ctrl+C 中断之前的 server，重新运行 node server.js 8888 curl http://127.0.0.1:8888/xxx，结果如下：1Hi% 这个 % 不是我们的内容，% 表示结尾。 好了，响应添加成功 使用 curl -s -v -- &quot;http://localhost:8888/xxx&quot; 可以查看完整的请求和响应 根据请求返回不同的响应 响应 / 响应 /xxx 响应 404 响应 /xxx.html 响应 /xxx.frank 再次强调，后缀是废话。文件内容是有 HTTP 头中的 Content-Type 保证的 响应 /xxx.css 响应 /xxx.js HTTP 路径不是文件路径！！！/xxx.html 不一定对应 xxx.html 文件 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)var url = require(&apos;url&apos;)var port = process.argv[2]if(!port)&#123; console.log(&apos;请指定端口号好不啦？\nnode server.js 8888 这样不会吗？&apos;) process.exit(1)&#125;var server = http.createServer(function(request, response)&#123; var parsedUrl = url.parse(request.url, true) var path = request.url var query = &apos;&apos; if(path.indexOf(&apos;?&apos;) &gt;= 0)&#123; query = path.substring(path.indexOf(&apos;?&apos;)) &#125; var pathNoQuery = parsedUrl.pathname var queryObject = parsedUrl.query var method = request.method /******** 从这里开始看，上面不要看 ************/ console.log(&apos;HTTP 路径是\n&apos; + path) if (path == &apos;/style.css&apos;) &#123; response.setHeader(&apos;Content-Type&apos;, &apos;text/css; charset=utf-8&apos;) response.write(&apos;body&#123;background-color: #ddd;&#125;h1&#123;color: red;&#125;&apos;) &#125; else if (path == &apos;/main.js&apos;) &#123; response.setHeader(&apos;Content-Type&apos;, &apos;text/javascript; charset=utf-8&apos;) response.write(&apos;alert(&quot;这是js执行的&quot;)&apos;) &#125; else if (path == &apos;/&apos;) &#123; response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;) response.write(&apos;&lt;!DOCTYPE html&gt;\n&lt;html&gt;&apos;+ &apos;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/style.css&quot;&gt;&lt;body&gt;&apos;+ &apos;&lt;h1&gt;你好&lt;/h1&gt;&apos;+&apos;&lt;script src=&quot;/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/head&gt;&lt;/html&gt;&apos;) &#125; else &#123; response.statusCode = 404 &#125; response.end() /******** 代码结束，下面不要看 ************/&#125;)server.listen(port)console.log(&apos;监听 &apos; + port + &apos; 成功\n请用在空中转体720度然后用电饭煲打开 http://localhost:&apos; + port)]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>面试题</tag>
        <tag>TCP/IP</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP请求与响应]]></title>
    <url>%2F2018%2F02%2F21%2FHTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[状态码请求与响应参考菜鸟教程资料什么是HTTPS Server + Client + HTTP 浏览器负责发起请求 服务器在 80 端口接收请求 服务器负责返回内容（响应） 浏览器负责下载响应内容 HTTP 的作用就是指导浏览器和服务器如何进行沟通。资料：菜鸟教程 - 学习HTTP 重点 面试题 请求包括 GET(获取) POST(上传) PUT(整体更新) PATCH(局部更新) DELETE(删除) HEAD OPTIONS等 能够手写http请求，能够手写http响应 Content-Type: application/x-www-form-urlencoded : 应用数据/还没有写入规范的格式-万维网-表单-用urlencode形式压缩 知道状态码的含义:123456789101112200 OK:GET时返回，表示响应成功201 created:POST时返回，表示创建成功301 Moved Permanently:请求的资源已被永久的移动到新URI302 Found:请求的资源被临时移走了304 未修改Not Modified：所请求的资源未修改，使用缓存的文档404 Not Found ：无法找到这个网页403 Forbidden ：服务器拒绝执行此请求500 Internal Server Error：服务器内部错误，无法完成请求502 Bad Gateway ：充当网关或代理的服务器，从远端服务器接收到了一个无效的请求（比如服务器关了） HTTP请求发起GET请求 命令行执行curl -s -v -- &quot;https://www.baidu.com&quot;请求内容为：1234GET / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.54.0Accept: */* 发起POST请求 命令行执行curl -X POST -s -v -- &quot;https://www.baidu.com&quot;请求内容为：1234POST / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.54.0Accept: */* 发起带data的POST请求 命令行执行curl -X POST -d &quot;1234567890&quot; -s -v -- &quot;https://www.baidu.com&quot;请求内容为: 12345678POST / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.54.0Accept: */*Content-Length: 10Content-Type: application/x-www-form-urlencoded1234567890 请求的格式1234567891 动词 路径 协议/版本2 Key1: value12 Key2: value22 Key3: value32 Content-Type: application/x-www-form-urlencoded2 Host: www.baidu.com2 User-Agent: curl/7.54.03 4 要上传的数据 请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空） 第三部分永远都是一个回车（\n，作为第2部分与第4部分的分界线 动词有 GET POST PUT PATCH DELETE HEAD OPTIONS 等 这里的路径可以包括「查询参数」，但不包括「锚点」比如GET /s?wd=javascript HTTP/1.1 如果你没有写路径，那么路径默认为 / :GET / HTTP/1.1 第 2 部分中的 Content-Type 标注了第 4 部分的格式 用 Chrome 发请求 打开 Network 地址栏输入网址 在 Network 点击，查看Headers里的 Request Headers，点击「view source」就可以看到请求内容 如果是POST请求，要点Preserve log防止刷新页面后丢失，此时就有第四部分，那么在 FormData 或 Payload 里面可以看到 响应上面三个请求示例，前两个请求对应的响应分别为 对GET的响应用GET请求百度首页后的响应：123456789101112131415HTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: Keep-AliveContent-Length: 2443Content-Type: text/htmlDate: Tue, 10 Oct 2017 09:14:05 GMTEtag: &quot;5886041d-98b&quot;Last-Modified: Mon, 23 Jan 2017 13:24:45 GMTPragma: no-cacheServer: bfe/1.0.8.18Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; 后面太长，省略了…… 对POST的响应用POST请求百度首页后的响应：1234567891011HTTP/1.1 302 FoundConnection: Keep-AliveContent-Length: 17931Content-Type: text/htmlDate: Tue, 10 Oct 2017 09:19:47 GMTEtag: &quot;54d9749e-460b&quot;Server: bfe/1.0.8.18&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; 后面太长，省略了…… GET 请求和 POST 请求对应的响应可以一样，也可以不一样 响应的第四部分可以很长很长很长 响应的格式12345671 协议/版本号 状态码 状态解释2 Key1: value12 Key2: value22 Content-Length: 179312 Content-Type: text/html34 要下载的内容 状态码要背，是服务器对浏览器说的话 123451xx 不常用2xx 表示成功3xx 表示重定向4xx 表示你丫错了（客户端错误）5xx 表示好吧，我错了（服务端错误） 状态解释没什么用 第 2 部分中的 Content-Type 标注了第 4 部分的格式 第 2 部分中的 Content-Type 遵循 MIME 规范 用 Chrome 查看响应 打开 Network 输入网址 选择Headers 查看 Response Headers，点击「view source」 你会看到响应的前两部分 查看 Response 或者 Preview，你会看到响应的第 4 部分 总结http请求与响应的格式12345678910111213141516171819202122232425262728293031323334GET 请求 GET / HTTP/1.1 //GET /?w=xxx HTTP/1.1 查询参数为?w=xxxHost: baidu.comAccept: text/html //请求html格式的文件响应HTTP/1.1 200 OKContent-Type: text/html; charset=utf-8 //响应给我html文件Content-Length: 10000&lt;!DOCTYPE&gt; //html格式的文件&lt;html&gt;......&lt;/html&gt;--------------------------POST 请求POST /login?w=xxx HTTP/1.1Host: baidu.comAccept: application/json //请求一个json格式的页面Content-Type: application/x-www-form-urlencodedContent-Length: 10username=fangfang&amp;password=mima响应HTTP/1.1 403 ForbiddenContent-Type: application/json //返回json格式Content-Length: 200&#123;&quot;erroc&quot;:&quot;错误&quot;&#125; //返回json文件 比喻版12345678910111213工资请求GET 11月工资 工资协议/1.1Host: 百度公司Accept: 现金 (or 支付宝转账, or 银行汇款)工资响应工资协议/1.1 200 OK类型: 现金现金张数: 1010000 httpsHTTP缺点：通信不加密内容会被窃听 不验证通信方的身份，遭遇伪装 无法证明报名完整性，可能回被篡改 所以引入HTTPS HTTP+加密+认证+完整性保护=HTTPS]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>请求与响应</tag>
        <tag>状态码</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脚本的简单运用]]></title>
    <url>%2F2018%2F02%2F20%2F%E8%84%9A%E6%9C%AC%E7%9A%84%E7%AE%80%E5%8D%95%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[写脚本Bash脚本、Node.js脚本node.js中文文档：http://nodejs.cn/api/ 写一个脚本 找个地方（比如local）新建文件.sh123mkdir ~/localcd ~/localtouch demo.sh 打开并往 demo.sh 里添加以下内容： 12345mkdir demo cd demo mkdir css js touch index.html css/style.css js/main.js exit 运行脚本在任意位置执行 sh ~/local/demo.sh 即可运行此脚本 12cd ~/Desktopsh ~/local/demo.sh 然后你会看到当前目录里多出一个 demo 目录，demo 目录里面还有一些文件 依次运行cd demo,然后在cmd模式下运行tree /f 好了，这个 demo.sh 就是你写出的第一个 Bash 脚本了。 path将 ~/local 添加到 PATH 里 cd ~/local; pwd 得到 local 的绝对路径 创建 ~/.bashrc：touch ~/.bashrc 编辑 ~/.bashrc：start ~/.bashrc，在最后一行添加 export PATH=”local的绝对路径:$PATH” 执行source ~/.bashrc 使其生效 之前你要运行 sh ~/local/demo.sh，现在你只需要运行 demo.sh ，不需要添加路径了 demo.txt 的后缀 .txt 很无聊，删掉它mv ~/local/demo.txt ~/local/demo现在你只要运行 demo 就能执行该脚本了。 细节 文件后缀的作用：毫无作用 PATH 的作用你每次在 Bash 里面输入一个命令时（比如 ls、cp、demo），Bash 都会去 PATH 列表里面寻找对应的文件，如果找到了就执行。 使用 type demo 可以看到寻找过程 使用 which demo 可以看到寻找结果 参数demo 脚本只能创建名字为 demo 的目录，太无聊了，我们让目录名是可变的吧。$1是第一个参数、$2是第二个参数、$3、$4……..12345mkdir $1cd $1mkdir css jstouch index.html css/style.css js/main.jsexit 此时在相应的文件夹里运行demo 参数，比如demo hello 就会在这个文件夹内生成一个名为hello的目录，里面有一些文件 完善版判断是否存在和$1同名的文件夹打开并编辑demo文件123456789101112if [ -d $1 ]; then echo &apos;error: dir exists&apos; exit 0else mkdir $1 cd $1 mkdir css js echo -e &quot;&lt;!DOCTYPE&gt;\n&lt;title&gt;Hello&lt;/title&gt;\n&lt;h1&gt;Hi&lt;/h1&gt;\n&quot; &gt; index.html touch css/style.css js/main.js echo &apos;success&apos; exit 1fi echo -e &quot;abc\ndef&quot; 输出：12abcdef -e表示启用解释反斜杠转义 exit 0 表示没有错误 exit 1 表示错误代码为 1 命令1 &amp;&amp; 命令2 ：命令1执行成功后才会执行命令2 命令1 || 命令2 ：命令1执行失败时，执行命令2 命令1 ; 命令2 : 命令1执行完后，执行命令2 Node.js 写脚本我们在 Bash 命令行里输入 Bash 命令，也可以在 Node.js 命令行里输入 JS 命令（Ctrl + D 退出）Bash 脚本能做的事情，JS 脚本也能做。(sh demo.sh 对应 node demo.js） Node.js命令node 进入node模式 切换目录 console.log(process.cwd()) : 显示当前目录路径，等同于bash里的pwd process.chdir(&quot;/Users/frank/Desktop&quot;) 进入相应的目录，等同于bash里的cd ~/Desktop console.log(1) ：等同于bash里的echo 1 创建目录12let fs = require(&quot;fs&quot;)fs.mkdirSync(&quot;目录名&quot;) 创建文件12let fs = require(&apos;fs&apos;)fs.writeFileSync(&quot;./index.html&quot;, &quot;内容&quot;) .表示当前文件夹 用 JS 脚本来重写 demo.sh 在bash模式下，执行cd ~/local进入目录 touch jsdemo : 创建js脚本 打开jsdemo文件，编辑它内容如下 123456789101112131415var fs = require(&apos;fs&apos;) var dirName = process.argv[2] // 你传的参数是从第 2 个开始的 process.chdir(&quot;/Users/stage/desktop/test&quot;) // cd ~/Desktop/tset fs.mkdirSync(&quot;./&quot; + dirName) // mkdir $1 process.chdir(&quot;./&quot; + dirName) // cd $1 fs.mkdirSync(&apos;css&apos;) // mkdir css fs.mkdirSync(&apos;js&apos;) // mkdir js fs.writeFileSync(&quot;index.html&quot;, &quot;&quot;) fs.writeFileSync(&quot;css/style.css&quot;, &quot;&quot;) fs.writeFileSync(&quot;js/main.js&quot;, &quot;&quot;) process.exit(0) 退出node模式 cd ~/Desktop/目录名 进入需要执行node命令的目录 node ~/local/jsdemo 参数 ：比如node ~/local/jsdemo testFile shebang的作用我们每次执行 ~/local/jsdemo 参数 都要在最前面添加 node 来执行，能不能做到不加 node也能执行呢（也就是指定执行环境），可以，在 jsdemo 里第一行加上这一句即可：#!/usr/bin/env node ：指定这个文件用node模式来执行 1234567891011121314151617#!/usr/bin/env nodevar fs = require(&apos;fs&apos;) var dirName = process.argv[2] // 你传的参数是从第 2 个开始的 process.chdir(&quot;/Users/stage/desktop/test&quot;) // cd ~/Desktop/tset fs.mkdirSync(&quot;./&quot; + dirName) // mkdir $1 process.chdir(&quot;./&quot; + dirName) // cd $1 fs.mkdirSync(&apos;css&apos;) // mkdir css fs.mkdirSync(&apos;js&apos;) // mkdir js fs.writeFileSync(&quot;index.html&quot;, &quot;&quot;) fs.writeFileSync(&quot;css/style.css&quot;, &quot;&quot;) fs.writeFileSync(&quot;js/main.js&quot;, &quot;&quot;) process.exit(0) 然后你就可以直接用 ~/local/jsdemo.js 参数 了（省得输入 node 了） 如果你已经把 ~/local 加入了 PATH，那么甚至可以直接输入 jsdemo 参数 来执行]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git bash完整操作流程]]></title>
    <url>%2F2018%2F02%2F18%2Fgitbash%E5%AE%8C%E6%95%B4%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[git的使用，包括add、commit、打标签、创建以及合并分支、push到远程仓库菜鸟教程：Git教程 git常用命令git --version查看git Bash版本号 init → 修改文件 → add → commit git的三种状态：modified修改文件 → add到暂存区 → commit造一颗后悔药 git config -l : 查看配置 git --version : 查看版本号 初始化词库：在文件夹右键选择Git Bash Here，运行git init git init file2 :创建一个文件夹file2并同时创建仓库 git clone xxxxxxx : 将github上的xxxxx clone到本地，文件夹名为此项目的repository名字 git clone xxxxxx test3 ：将xxxxx clone into 文件夹test3内，文件夹名就是test3 git status -sb : 查看文件状态。红色??表示该文件还没add过。绿色A表示add过但没commit了 git add . : 将所有修改添加至暂存区。然后运行git status -sb查看此时的状态。绿色A表示add过但没commit了 git commit -m &quot;描述&quot; ：造一颗后悔药 建议使用git commit -v来造后悔药git commit -v可进行多行描述，首行为title，次行开始description。比如首行“做了一些更新”，次行“详细更新了xxxx和xxxx以及xxxx” 组合技 git add . &amp;&amp; git commit -m &quot;描述&quot; ：将add和commit组合使用 git log : 查看后悔药的id（commit后面的代码），按↑ ↓键查看，按 Q 退出 12345commit f0d95058cd32a332b98967f6c0a701c64a00810a Author: xxxxxx &lt;xxxxxxxx@gmail.com&gt; Date: Thu Sep 28 22:30:43 2017 +0800 完成第一章 git log -p : 查看具体增删了哪些内容 git log --oneline : 在一行简要显示历史节点 git log --all --oneline ： 可以看到master和所有分支上的历史记录 git log --all --graph : 图示全部分支历史记录 git checkout 后悔药的id ：吃一颗后悔药~~ git checkout - : 回退到上一个历史节点 TODO:git checkout 后悔药id 与 git reset 后悔药id --hard的区别 打tag git tag -a 标签名 -m &quot;描述&quot; ：打tag(如果项目比较大，有上百个commit时，给几个重要的后悔药打上tag方便查找，省去了拷贝后悔药id代码) git log --oneline: git tag -a 标签名 -m &quot;描述&quot; 后悔药的id ：给某个历史节点打标签 git tag : 列出所有tag git show 标签名 ：git show v1 查看v1的具体详情（记得↑ ↓翻页） git checkout 标签名 ：吃一颗后悔药~ 比如git checkout v1(省去了拷贝后悔药id代码) 分支branch假设在开发V3版时，发些V2版存在一些bug，那么可以在V2版上创建分支用来修复V2的bug，然后与后期的版本合并 git branch 分支名 ：在master主干上创建分支 git checkout 分支名 ：进入分支 组合技 git checkout -b 分支名 ：创建并进入这个分支 在3 not rich commit造完后悔药后，创建一个rich的分支并进入git branch rich &amp;&amp; git checkout rich 此时就是在rich分支上操作了，修改not rich为rich，然后add → commit git checkout master : 回到master分支 git log --all --oneline ： 可以看到master和所有分支上的历史记录 git log --all --graph : 图示全部分支历史记录 git merge 分支名 ：合并分支,合并完之后再次add和commit 上传到远程仓库github视频教程 ： 点我 git remote add origin git@github.com:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx/git-demo-1.git ：将本地仓库上传至远程仓库 git pull : 把远程仓库中最新的更改拖下来，然后在此基础上编辑文件，完成后add和commit git push -u origin master ：上传到远程仓库 clear 或者 Ctrl + L :清屏]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令以及偷懒小技巧]]></title>
    <url>%2F2018%2F02%2F17%2Fgit%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%81%B7%E6%87%92%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[本文简单介绍了git与github的配置，以及如何将本地仓库与github连接起来。还介绍了git常用的一些命令，以及如何简化git命令参考资料: 饥人谷菜鸟教程：Git教程 配置 GitHub (SSH Key) 进入 https://github.com/settings/keys 如果页面里已经有一些 key，就点「delete」按钮把这些 key 全删掉。如果没有，就往下看 点击 New SSH key，你需要输入 Title 和 Key，但是你现在没有 key，往下看 打开 Git Bash 按照 https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/ 的教程 运行 ssh-keygen -t rsa -b 4096 -C &quot;你的邮箱&quot;，注意填写你的邮箱！ 按回车三次 运行 ll ~/.ssh,可以看到生成了id_rsa(钥匙)和id_rsa.pub(锁) 运行 cat ~/.ssh/id_rsa.pub，得到一串东西，完整的复制这串东西 回到上面第 3 步的页面，在 Title 输入「win7上的ssh」 在 Key 里粘贴刚刚你你复制的那串东西 点击 Add SSH key 回到 Git Bash 运行 ssh -T git@github.com，用你电脑上的钥匙打开上传到github的锁，你可能会看到这样的提示：输入 yes 回车 然后如果你看到 Permission denied (publickey). 就说明你失败了，请回到第 1 步重来，是的，回到第 1 步重来；如果你看到 Hi FrankFang! You’ve successfully authenticated, but GitHub does not provide shell access. 就说明你成功了！ 一台电脑只需要一个 SSH key 一个 SSH key 可以访问你的所有仓库，即使你有 1000000 个仓库，都没问题 如果你新买了电脑，就在新电脑上重新生成一个 SSH key，把这个 key 也上传到 GitHub，它可以和之前的 key 共存在 GitHub 上 如果你把 key 从电脑上删除了，重新生成一个 key 即可，替换之前的 key Git的配置与使用配置Gitgit --version :查看当前git版本号 12345git config --global user.name 你的英文名git config --global user.email 你的邮箱git config --global push.default matchinggit config --global core.quotepath falsegit config --global core.editor &quot;vim&quot; 五句话，依次运行。不执行的话，电脑可能会爆炸你信不信。 git config -l : 查看配置 只在本地使用Gitgit --version查看git Bash版本号 步骤 创建目录作为我们的项目目录：mkdir git-demo-1 进入目录 cd git-demo-1 git init，初始化这句命令会在 git-demo-1 里创建一个 .git 目录 ls -la 你就会看到 .git 目录，它就是一个「仓库」，不要进去看，这仓库里面有毒，别进去！ 在 git-demo-1 目录里面添加任意文件，假设我们添加了两个文件，分别是 index.html 和 css/style.css 123touch index.htmlmkdir csstouch css/style.css 运行 git status -sb查看文件状态， 可以看到文件前面有 ?? 号 123## Initial commit on master?? css/?? index.html 这个 ?? 表示 git 一脸懵逼，不知道你要怎么对待这些变动。 使用 git add 将文件添加到「暂存区」你可以一个一个地 add12git add index.htmlgit add css/style.css 你也可以一次性 addgit add . 意思是把当前目录（.表示当前目录）里面的变动都加到「暂存区」 再次运行 git status -sb，可以看到 ?? 变成了 A123## Initial commit on masterA css/style.cssA index.html A 的意思就是添加，也就是说你告诉 git，这些文件我要加到仓库里 使用 git commit -m &quot;信息&quot;将你 add 过的内容「正式提交」到本地仓库（.git就是本地仓库），并添加一些注释信息，方便日后查阅你可以一个一个地 commit12git commit index.html -m &apos;添加index.html&apos;git commit css/style.css -m &quot;添加 css/style.css&quot; 你也可以一次性 commitgit commit . -m &quot;添加了几个文件&quot; 建议使用git commit -v来提交git commit -v可进行多行描述，首行为title，次行开始description。比如首行“做了一些更新”，次行“详细更新了xxxx和xxxx以及xxxx” 再再次运行 git status -sb，发现没有文件变动了，这是因为文件的变动已经记录在仓库里了。 这时你使用 git log 就可以看到历史上文件的变动：12345commit f0d95058cd32a332b98967f6c0a701c64a00810aAuthor: xxxxxx &lt;xxxxxxxx@gmail.com&gt;Date: Thu Sep 28 22:30:43 2017 +0800 添加几个文件 按↑ ↓键查看，按 Q 退出 运行history可以看到历史上输入过的命令 运行start css/style.css 会使用默认的编辑器编辑style.css，保存 运行git status -sb,可以看到style.css前面一个红色的M(Modified)，代表文件有过变动但未add到仓库 12## masterM css/style.css 运行git add style.css,可以看到红色的M变成了绿色的M，表示变动过的文件将添加到「暂存区」 运行git commit -m &quot;改动style.css&quot;这个改动就被提交到 .git 本地仓库了 再再次运行 git status -sb，会发现没有变更了，这说明所有变动都被本地仓库记录在案了。 删除文件rm style.css 运行git add style.css，将删除结果add到仓库 git status -sb，会发现前面有个绿色的D(Delete) 运行git commit -m &quot;删除style.css&quot; 总结 git init，初始化本地仓库 .git git status -sb，显示当前所有文件的状态 git add 文件路径，用来将变动加到暂存区 git commit -m &quot;信息&quot;，用来正式提交变动，提交至 .git 仓库 如果有新的变动，我们只需要依次执行 git add xxx 和 git commit -m &#39;xxx&#39; 两个命令即可。别看本教程废话那么多，其实就这一句有用！先 add 再 commit，行了，你学会 git 了。 git log 查看变更历史 将本地仓库上传到 GitHub如何将我们这个 git-demo-1 上传到 GitHub 呢？ 步骤 在 GitHub 上New一个repository，名称随意，一般跟本地目录名一致按照截图所示，除了仓库名，其他的什么都别改，其他的什么都别改，其他的什么都别改，其他的什么都别改，这样你才能创建一个空仓库 点击创建按钮之后，GitHub 就会把后续的操作全告诉你，如图 看图，点击 SSH 按钮，点击 SSH 按钮，点击 SSH 按钮，我想你现在肯定不会忘了点击 SSH 按钮了吧~~~~如果不点击这个按钮，你就会使用默认的 HTTPS 地址。但是千万不要使用 HTTPS 地址，因为 HTTPS 地址使用起来特别麻烦，每次都要输入密码，而 SSH 不用输入用户名密码。为什么 SSH 不用密码呢，因为你已经上传了 SSH public key。还记得吗？如果不记得，翻到本文第一部分「配置 GitHub」章节。 由于我们上之前创建过本地仓库了，所以看图，图中下面半部分就是你需要的命令，我们一行一行拷贝过来执行 找到图中的「…or push an existing repository from the command line」这一行，你会看到 git remote add origin https://github.com/xxxxxxxxxx/git-demo-1.git， 如果你发现这个地址是 https 开头的，那你就做错了，还记得吗，我们要使用 SSH 地址，GitHub 的 SSH 地址是以 git@github.com 开头的。 再次点击 SSH 按钮，不管我强调多少遍，总会有人忘记点击 SSH 按钮，为什么呢？我也不知道，为了防止你忘了点击 SSH 按钮，我最后再说一遍，「点击 SSH按钮」，点击之后，整个世界就会变得美好起来。 得到新的命令 git remote add origin git@github.com:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx/git-demo-1.git，复制并运行它 复制第二行 git push -u origin master，运行它 刷新当前页面，你的仓库就上传到 GitHub 了！是不是特别简单？只要你按照我说的做，一丝不苟，即可。 直接在 GitHub 创建一个仓库，然后下载到本地步骤 在GitHub 上新建一个仓库 git-demo-2，这次就不创建空仓库了，而是自带 README 和 Lisence 的仓库，创建截图如下：请按图中所示，填写一模一样的内容，然后点击创建按钮。 这样一来，这个仓库就会自动拥有三个文件： 这三个文件的作用请自行了解：.gitignore 的作用、README.md 的作用 以及 LISENCE 的作用 运行git clone 以git@github.com开头的地址运行完了你就会发现，桌面上多出一个 git-demo-2 目录。 cd git-demo-2 进入这个多出来的目录 运行 ls -la 你会看到，远程目录的所有文件都在这里出现了，另外你还看到了 .git 本地仓库。这时你就可以添加文件，git add，然后 git commit 了。 总结 git clone git@github.com:xxxx，下载仓库 git init，初始化本地仓库 .git git status -sb，显示当前所有文件的状态 git add 文件路径，用来将变动加到暂存区 git commit -m “信息”，用来正式提交变动，提交至 .git 仓库 如果有新的变动，我们只需要依次执行 git add xxx 和 git commit -m ‘xxx’ 两个命令即可。别看本教程废话那么多，其实就这一句有用！先 add 再 commit，行了，你学会 git 了。 git log 查看变更历史 如何上传更新你在本地目录有任何变动，只需按照以下顺序就能上传到github：1234git add 文件路径git commit -m &quot;信息&quot;git pull （相信我，你一定会忘记这一个命令）获取远程仓库最新文件git push 下面是例子1234567cd git-demo-1touch index2.htmlgit add index2.htmlgit commit -m &quot;新建 index2.html&quot;git pull退出vim: esc + : + w + qgit push 然后你去 git-demo-1 的 GitHub 页面，就能看到 index2.html 出现在里面了。是不是很……简……单……呢…… 其他Git命令 git remote add origin git@github.com:xxxxxxx.git 将本地仓库与远程仓库关联 git remote set-url origin git@github.com:xxxxx.git 上一步手抖了，可以用这个命令来挽回 git branch 新建分支 git merge 合并分支 git stash 通灵术 git stash pop 反转通灵术 git revert 后悔了 git reset 另一种后悔了 git diff 查看详细变化 git操作偷懒技巧通过~/.bashrc 文件可以简化git操作 自动运行 首先 touch ~/.bashrc 创建一下这个文件 start ~/.bashrc 选用编辑器编辑这个文件，内容为 echo &#39;Hi&#39; 你也可以用命令行编辑文件 echo &quot;echo &#39;hi&#39;&quot; &gt;&gt; ~/.bashrc 关闭退出 Git Bash，然后打开 Git Bash，是不是看到了 Hi，这说明每次进入 Git Bash，就会优先运行 ~/.bashrc 里面的命令 重新编辑 ~/.bashrc，内容改为 cd ~/Desktop，重启 Git Bash，有没有发现默认就进入桌面目录了？ 你可以用 ~/.bashrc 在进入 Git Bash 前执行任何命令，十分方便。 alias(简写) 在 ~/.bashrc 里新增一行 alias f=&quot;echo &#39;frank is awesome&#39;&quot;，等于号两边不能有空格，你最好一个字都不要错。 运行 source ~/.bashrc，作用是执行 ~/.bashrc 运行 f，就会看到 frank is awesome 也就是说，现在 f 就是 echo ‘frank is awesome’ 的缩写了，利用这个技巧，我们可以把很多常见的命令缩写一下，比如1234567alias la=&apos;ls -a&apos;alias ll=&apos;ls -l&apos;alias gst=&apos;git status -sb&apos;alias ga=&apos;git add&apos;alias ga.=&apos;git add .&apos;alias gc=&apos;git commit&apos;alias gc.=&apos;git commit .&apos; 保存退出，然后运行 source ~/.bashrc 这样一来，你的 Git 操作就会简单很多：12345ga 1.txtga .gc 1.txtgc.gst 环境变量还可以在 ~/.bashrc 里面设置一些环境变量，比如你可以在 ~/.bashrc 里面添加一行 export SASS_BINARY_SITE=&quot;https://npm.taobao.org/mirrors/node-sass&quot;那么以后你安装 node-sass 的时候就不会因为被墙而报错了。以后会用到的，现在先说一下。 设置 PATHexport PATH=&quot;目录的绝对路径:$PATH&quot;可以在 PATH 里添加一个目录，不要运行，等用到的时候再来查。 其他命令1 &amp;&amp; 命令2 ：命令1执行成功后才会执行命令2命令1 || 命令2 ：命令1执行失败时，执行命令2命令1 ; 命令2 : 命令1执行完后，执行命令2]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行(CLI)基础及常用命令]]></title>
    <url>%2F2018%2F02%2F16%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[介绍了cmd，gitBash命令行(CLI)的一些基础知识，以及常用的一些命令 参考资料: 饥人谷 基本概述~ / . .. $ 的意思 ~/desktop : 其中的 ~ 表示电脑的username，所以这句命令等同于stage/desktop . : 当前目录 .. : 上级目录，cd ..表示进入上级目录常见单词英文翻译directory目录、文件夹file文件make新建remove删除move移动copy复制list罗列link链接find查找echo发出回音、重复touch触摸change改变 单词缩写命令全写缩写创建目录make directorymkdir删除removerm移动 / 重命名movemv复制copycp罗列listls改变目录change directorycd， windows下用cd %userprofile%\desktop进入桌面 缩写规则就是：删掉元音字幕（A E I O U），保留前 2 到 3 个辅音字母 基础命令 cd ~/Desktop 进入桌面1.1 cmd直接cd desktop mkdir demo-1 创建目录，这时你可以切到桌面，看到 demo-1 目录 rm -rf demo-1 删除目录【-r表示递归，循环删除直至删光，-f表示强制，不提示yes/no】 touch 1.txt 创建文件4.1 cmd用echo x &gt; xxx.txt mv 1.txt 2.txt 这样我们就把 1.txt 移到 2.txt 了，也就是重命名 cp js/main.js vendor,将js目录下的main.js复制到vendor目录下6.1 cmd用copy，比如copy C:\Users\stage\Desktop\hello\目录1&gt;1.txt C:\Users\stage\Desktop\hello，将目录1里的1.txt复制到hello目录内 Linux常用命令(重点！！！)操作命令进入目录cd显示当前目录的详细路径pwd创建目录mkdir 目录名创建特殊名字的目录(比如带空格的文件名)mkdir “目 录名” : mkdir &quot;file 1&quot;创建多个目录mkdir 目录名1 目录名2 :mkdir file1 file2 file3创建深层次目录mkdir -p 目录路径：举个栗子 mkdir -p file1/file2/file3我是谁,显示用户名whoami清屏clear 或者 Ctrl + L––显示文件夹里的内容ls 文件夹路径 : ls显示当前文件夹里的内容，查看指定路径文件夹里的内容ls file1/file2查看文件夹里的所有内容，包括隐藏的ls -a 文件夹路径显示文件夹详细信息ls -l 文件夹路径 ： drwxr表示directory(d开头表示目录，-开头表示非目录)、read可读、write可写、x可运行显示详细信息，包括隐藏的文件ls -la 文件夹路径––创建文件echo ‘1’ &gt; 文件路径 ：echo &#39;xxx&#39; &gt; 1.txt追加文件内容echo ‘1’ &gt;&gt; 文件路径创建文件touch 文件名改变文件更新时间touch 文件名––复制文件cp 源路径 目标路径 : cp 1.txt 2.txt将1.txt里的内容复制到2.txt，cp js/main.js vendor,将js目录下的main.js复制到vendor目录下复制目录cp -r 源路径 目标路径 ： cp -r file1 file2––重命名文件名mv 原文件名 修改后的文件名 : mv 1.txt 2.txt––删除文件rm 文件路径 : rm 1.txt强制删除文件rm -f 文件路径删除目录rm -r 目录路径强制删除目录rm -rf 目录路径––【windows不支持】查看当前目录结构tree【windows不支持】建立软链接，相当于创建一个双胞胎目录ln -s 真实文件 双胞胎文件 ：ln -s demo demo-copy––下载文件curl -L https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js &gt; jq.js【将jq源码下载下来并保存到jq.js】拷贝网页wget -p -H -e robots=off https://www.baidu.com磁盘占用df -kh当前目录大小du -sh .各文件大小du -h cmd命令行进入目录如果要进入E:\aaa\bbb\ccc首先要C:\Users\stage&gt;e:进入E盘然后在进入目录cd E:\aaa\bbb\ccc【总之，不能直接cd 路径，必须先进入相对应的磁盘，才能cd】 树形列表： tree 路径：只展示目录 tree /f 路径:深度展示 tree /f 路径&gt; tree.txt：把生成的文件目录树形结构写入到tree.txt文件中 批量合并文件copy /b E:\aaa\bbb\*.ts E:\aaa\bbb\together.ts 批量删除文件del E:\aaa\bbb\000*.ts]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行(CLI)的安装和配置方法]]></title>
    <url>%2F2018%2F02%2F15%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[归纳总结了下 git、git bash、node、npm 的安装和配置方法. 参考资料: 饥人谷 本文参考 饥人谷 的文章后整理归纳了一下，主要包括git、git bash、node、npm的使用和配置方法。 Git Bash的使用第一种使用方式找一个目录，在目录上右键点击，然后选中「Git Bash Here」，即可用 Git Bash 打开这个目录。试试输入 touch 1.txt，回车后可以看到目录里多了一个touch 1.txt文件。 第二种使用方式直接打开 Git Bash，输入 cd ~/Desktop 即可来到桌面所在的目录。试试输入 touch 1.txt，回车后看看桌面上是不是多了一个文件。 Linux常用命令新建文件夹：mkdir my-dir 删除文件夹：rm -rf my-dir 创建文件：echo &quot;hello&quot; &gt; newFile.txt 创建空内容文件: touch file.txt 重命名: mv 1.txt 2.txt ,将1.txt重命名为2.txt 删除文件：rm newFile.txt 进入文件夹: cd my-dir 运行文件: start file.txt 显示文件夹内所有的文件: ls 清屏: clear 中断/退出模式: ctrl + C 关闭git bash: ctrl + D 或者输入 exit 进入node模式: node 进入npm模式: npm Node.js的使用从官网下载node.js 使用第一种使用方法 进入 Git Bash 输入 node，回车，就可以进入 node 运行环境，这个时候我们就可以写 JS 了 试试写最简单的 JS 语句，比如 1+2，回车 2 * 8，回车 node的另一种使用方法我们可以先创建一个 JS 文件，然后让 node 运行 来到桌面：cd ~/Desktop 新建一个目录用来玩耍：mkdir hello-node 进入这个目录：cd hello-node 新建一个有内容的 JS 文件：echo &quot;console.log(&#39;Hi, Node.js&#39;)&quot; &gt; main.js，那么 main.js 就新建成功了 输入 node main.js，回车，node 就会执行这个 main.js 文件，你会看到「Hi, Node.js」字样 玩完了，删除 hello-node：cd .. ; rm -rf hello-node npm的配置和使用配置打开 Git Bash，依次输入以下命令，按回车：1234npm config set registry https://registry.npm.taobao.org/npm config set loglevel httpnpm config set progress falsenpm config set strict-ssl false npm 的配置被存储在 ~/.npmrc，你可以随时改。 npm的使用我们可以用 npm 的翻译工具做一个随时可用的小字典，这个小工具的名字叫做 fanyi。 打开Git Bash，运行 npm i -g fanyi 即可安装 fanyi，安装完成之后，输入 fanyi frontend 就可以看到对应的中文释义了！ 是不是很帅呢？！ Git的配置和使用配置请在命令行运行这五句话！！！一定要运行这五句话，不然 git 就不能用了12345git config --global user.name xxx #方便产品经理找（怼）你git config --global user.email yyy #方便产品经理找（怼）你git config --global push.default simple # 本来我写的是 matching，不过想了想可能 simple 更好git config --global core.quotepath false #防止文件名变成数字git config --global core.editor &quot;vim&quot; # 使用vim编辑提交信息 git config -l : 查看配置信息 这样就可以愉快地使用git了~ Git的使用使用 在本地新建一个文件夹 test ，在文件夹上右键点击，然后选中「Git Bash Here」 在github上新建一个仓库New repository 在已经打开的Git Bash内输入123456echo &quot;# test&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://github.com/harry0071/test.gitgit push -u origin master 最后一段代码 git push -u origin master 回车后会询问 yes/no ,输入yes此时如果报错的话，需要SSH Key解决办法： 进入github的 Settings &gt;&gt;&gt; 点击右侧的 SSH and GPG keys &gt;&gt;&gt; 点击New SSH key &gt;&gt;&gt; 进入 https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/ 按照网页提示在Git Bash内输入:ssh-keygen -t rsa -b 4096 -C &quot;改成自己的邮箱@example.com&quot; ，接着按3次回车，直至出现冒泡泡的画面 将生成的SSH key cat下来: cat ~/.ssh/id_rsa.pub 回到第1步将生成的SSH key粘贴进去 重新运行`git push -u origin master 常用命令git init: 把用Git Bash打开的本地文件夹变成Git可以管理的仓库git add 1.txt 2.txt: 将文件提交至暂存区,可以一次添加多个文件git add .: 将文件夹内的所有文件添加到暂存区git commit -m &quot;本次更新内容&quot;: 把add的文件一次性打包提交至本地版本库，-m后面输入的是本次更新的说明注释git push origin master: 将本地仓库推送到Github仓库git rm 1.txt: 删除一个文件git checkout -- 1.txt: 把误删的文件恢复到最新版本git rm 1.txt + git commit -m &quot;remove&quot;: 彻底删除文件]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime中如何使用terminal教程]]></title>
    <url>%2F2018%2F02%2F08%2Fsublime%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8terminal%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.安装terminal首先在sublime text3 中安装terminalctrl+shift+P打开package control面板,输入pci进入安装插件列表，输入terminal找到插件安装 2.配置terminalterminal默认调用系统自带的PowerShell，接下来我们改成cmd.exe 安装完成后在工具菜单选择“Preferences(首选项)”–“Package Settings”–“Terminal”–“Settings - User” 在里面输入打开cmd命令窗口的脚本，然后ctr+s保存。12345&#123; &quot;terminal&quot;: &quot;c:\\WINDOWS\\system32\\cmd.exe&quot;, &quot;parameters&quot;: [&quot;/START&quot;,&quot;%CWD%&quot;] &#125; 3.启动terminal现在我们打开sublime，使用ctrl+shift+t就可以打开cmd命令窗口了 4.更多关于terminal详情关于sublime的terminal插件的更多安装及配置方法:百度经验Github]]></content>
      <categories>
        <category>sublime</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漂亮的弹窗插件 —— SweetAlert教程]]></title>
    <url>%2F2018%2F02%2F08%2Fsweetalert%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[SweetAlert可以替代JavaScript原生的alert和confirm等函数呈现的弹出提示框，它将提示框进行了美化，并且允许自定义，支持设置提示框标题、提示类型、内容展示图片、确认取消按钮文本、点击后回调函数等。官方网站: https://sweetalert.js.org/Github: https://github.com/t4t5/sweetalert中文教程站: http://mishengqiang.com/sweetalert/ 使用方法1.引入(我用的CDN引入)12&lt;link href="https://cdn.bootcss.com/sweetalert/1.1.3/sweetalert.min.css" rel="stylesheet"&gt;&lt;script src="https://cdn.bootcss.com/sweetalert/1.1.3/sweetalert.min.js"&gt;&lt;/script&gt; 2.使用简称函数swal调用sweetAlert123456789101112swal(&#123; title: "确定删除吗？", text: "你将无法恢复该虚拟文件！", type: "warning", showCancelButton: true, confirmButtonColor: "#DD6B55", confirmButtonText: "确定删除！", closeOnConfirm: false&#125;,function()&#123; swal("删除！", "你的虚拟文件已经被删除。", "success"); &#125;); 3.举个栗子 html代码 1234567891011121314151617181.基本信息：&lt;button id="demo1"&gt;试一试&lt;/button&gt; &lt;br /&gt;2.带有文字的标题：&lt;button id="demo2"&gt;试一试&lt;/button&gt; &lt;br /&gt;3.成功提示：&lt;button id="demo3"&gt;试一试&lt;/button&gt; &lt;br /&gt;4.带有“确认”按钮的功能的警告消息：&lt;button id="demo4"&gt;试一试&lt;/button&gt; &lt;br /&gt;5.通过传递参数，您可以执行一些其他的事情比如“取消”。：&lt;button id="demo5"&gt;试一试&lt;/button&gt; &lt;br /&gt;6.一个有自定义图标的消息：&lt;button id="demo6"&gt;试一试&lt;/button&gt; &lt;br /&gt;7.自定义HTML信息：&lt;button id="demo7"&gt;试一试&lt;/button&gt; &lt;br /&gt;2秒后关闭：&lt;button id="demo8"&gt;试一试&lt;/button&gt; &lt;br /&gt;8.更换“提示”功能: &lt;button id="demo9"&gt;试一试&lt;/button&gt; &lt;br /&gt;9.使用加载程序（例如，用于AJAX请求）: &lt;button id="demo10"&gt;试一试&lt;/button&gt; &lt;br /&gt; js代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107document.getElementById("demo1").onclick = function() &#123; swal("这是一个信息提示框!")&#125;;document.getElementById("demo2").onclick = function() &#123; swal("这是一个信息提示框!", "很漂亮，不是吗？")&#125;;document.getElementById("demo3").onclick = function() &#123; swal("干得好", "你点击了按钮!", "success")&#125;;document.getElementById("demo4").onclick = function() &#123; swal(&#123; title: "你确定？", text: "您将无法恢复这个虚构的文件！", type: "warning", showCancelButton: true, confirmButtonColor: "#DD6B55", confirmButtonText: "是的，删除！", closeOnConfirm: false &#125;, function() &#123; swal("删除!", "您的虚构文件已被删除！", "success") &#125;)&#125;;document.getElementById("demo5").onclick = function() &#123; swal(&#123; title: "你确定？", text: "您将无法恢复这个虚构的文件！", type: "warning", showCancelButton: true, confirmButtonColor: "#DD6B55", confirmButtonText: "是的，删除！", cancelButtonText: "不，取消", closeOnConfirm: false, closeOnCancel: false &#125;, function(isConfirm) &#123; if (isConfirm) &#123; swal("删除!", "您的虚构文件已被删除！", "success") &#125; else&#123; swal("取消!", "您的虚构文件是安全的！", "error") &#125; &#125;)&#125;;document.getElementById("demo6").onclick = function() &#123; swal(&#123; title: "Sweet!", text: "这里是自定义图像!", imageUrl: "img/thumbs-up.jpg" &#125;)&#125;;document.getElementById("demo7").onclick = function() &#123; swal(&#123; title: "HTML &lt;small&gt;标题&lt;/small&gt;!", text: "A custom &lt;span style='color:pink'&gt;html&lt;span&gt; message.", html: true &#125;)&#125;;document.getElementById("demo8").onclick = function() &#123; swal(&#123; title: "自动关闭警报!", text: "2秒后自动关闭", timer: 2000, showConfirmButton: false &#125;)&#125;;document.getElementById("demo9").onclick = function() &#123; swal(&#123; title: "请输入！", text: "填写一些信息", type: "input", showCancelButton: true, closeOnConfirm: false, animation: "slide-from-top", inputPlaceholder: "请输入..." &#125;, function(inputValue) &#123; if (inputValue === false) &#123; return false; &#125; if (inputValue === "") &#123; swal.showInputError("内容不能为空！"); return false; &#125; swal("Nice!", "你输入的是：" + inputValue, "success") &#125;)&#125;;document.getElementById("demo10").onclick = function() &#123; swal(&#123; title: "AJAX请求实例", text: "提交运行Ajax请求", type: "info", showCancelButton: true, closeOnConfirm: false, showLoaderOnConfirm: true &#125;, function() &#123; setTimeout(function() &#123; swal("AJAX请求完成！"); &#125;, 2000) &#125;)&#125;; 效果预览 更多详情可以去中文教程站查看更多详情,里面包括了各种配置和方法，以及示例中文教程站: http://mishengqiang.com/sweetalert/]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>教程</tag>
        <tag>jq</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next主题个性化教程:打造炫酷网站]]></title>
    <url>%2F2018%2F02%2F08%2Fhexonext%2F</url>
    <content type="text"><![CDATA[看到有些next主题的网站很炫酷，那么是怎么配置的呢？接下来我会讲一讲如何实现一些炫酷的效果 主要有以下32种： 在右上角或者左上角实现fork me on github添加RSS添加动态背景实现点击出现桃心效果修改文章内链接文本样式修改文章底部的那个带#号的标签在每篇文章末尾统一添加“本文结束”标记修改作者头像并旋转博文压缩修改代码块自定义样式侧边栏社交小图标设置主页文章添加阴影效果在网站底部加上访问量添加热度网站底部字数统计添加 README.md 文件设置网站的图标Favicon实现统计功能添加顶部加载条在文章底部增加版权信息添加网易云跟帖(跟帖关闭，已失效，改为来必力)隐藏网页底部powered By Hexo / 强力驱动修改网页底部的桃心文章加密访问添加jiathis分享博文置顶修改字体大小修改打赏字体不闪动自定义鼠标样式为博客加上萌萌的宠物DaoVoice 在线联系点击爆炸效果 详细配置请参考: https://www.jianshu.com/p/f054333ac9e6]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日期时间控件jQuery datetimepicker的使用简介]]></title>
    <url>%2F2018%2F02%2F08%2Fjquerydatetimepicker%2F</url>
    <content type="text"><![CDATA[datetimepicker是一个配置灵活的日期选择插件，你可以定义它的展示方式，包括日期格式、语言、限制选择日期范围、添加相关按钮以及其它导航等 此项目的Github地址：https://github.com/xdan/datetimepicker演示地址: https://xdsoft.net/jqplugins/datetimepicker/ 使用方法1.添加引用添加jquery.js、datetimepicker.js和datetimepicker.css到您的页面123&lt;link href="https://cdn.bootcss.com/jquery-datetimepicker/2.5.17/jquery.datetimepicker.min.css" rel="stylesheet"&gt;&lt;script src="https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/jquery-datetimepicker/2.5.17/jquery.datetimepicker.full.min.js"&gt;&lt;/script&gt; 2.创建input元素1&lt;input id="datetimepicker" type="text" &gt; 3.设置成中文1$.datetimepicker.setLocale('zh'); 4.启用插件1$('#datetimepicker').datetimepicker(); 按以上步骤我们就实现jquery datetimepicker的使用，当然这只是最基本的样式，另外jquery datetimepicker的样式控制是通过传一个json对象的参数给datetimepicker来实现的。下面我们举个例子来看下：1$("#start").datetimepicker(&#123; format: 'Y/m/d', timepicker: false &#125;); 上面传入的参数设置只显示年月日，以及弹出层只能选择日期，而不能选择时间。 那我们接下来总结一下它常用的一些参数及其作用。 详细配置参数关于详细配置参数参考：https://xdsoft.net/jqplugins/datetimepicker/12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455$('#datetimepicker').datetimepicker(&#123; value: '' // 设置当前datetimepicker的值 rtl: false, // false 默认显示方式 true timepicker和datepicker位置变换 format: 'Y/m/d H:i', // 设置时间年月日时分的格式 如: 2016/11/15 18:00 formatTime: 'H:i', // 设置时间时分的格式 formatDate: 'Y/m/d', // 设置时间年月日的格式 startDate: false, // new Date(), '1986/12/08', '-1970/01/05','-1970/01/05', step: 10, // 设置时间时分的间隔 closeOnDateSelect: false, // true 设置datepicker可点击 false 设置datepicker不可点击 实际上可以双击 closeOnTimeSelect: true, // true 设置timepicker可点击 false 设置timepicker不可点击 closeOnWithoutClick: true, // true 设置点击input可以隐藏datetimepicker false 设置点击input不可以隐藏datetimepicker closeOnInputClick: true, // true 设置点击input可以隐藏datetimepicker false 设置点击input不可以隐藏datetimepicker (会有闪动 先隐藏 再显示) timepicker: true, // true 显示timepicker false 隐藏timepicker datepicker: true, // true 显示datepicker false 隐藏datepicker weeks: false, // true 显示周数 false 隐藏周数 defaultTime: false, // 如果输入值为空 可用来设置默认显示时间 use formatTime format (ex. '10:00' for formatTime: 'H:i') defaultDate: false, // 如果输入值为空 可用来设置默认显示日期 use formatDate format (ex new Date() or '1986/12/08' or '-1970/01/05' or '-1970/01/05') minDate: false, // 设置datepicker最小的限制日期 如：2016/08/15 maxDate: false, // 设置datepicker最大的限制日期 如：2016/11/15 minTime: false, // 设置timepicker最小的限制时间 如：08:00 maxTime: false, // 设置timepicker最大的限制时间 如：18:00 allowTimes: [], // 设置timepicker显示的时间 如：allowTimes:['09:00','11:00','12:00','21:00'] opened: false, // false默认打开datetimepicker可关闭 true打开datetimepicker后不可关闭 initTime: true, // 设置timepicker默认时间 如：08:00 inline: false, // ture设置datetimepicker一直显示 theme: '', // ture设置datetimepicker显示样式 如: 'dark' withoutCopyright: true, // ture默认隐藏左下角'xdsoft.net'链接 false 显示左下角'xdsoft.net'链接 inverseButton: false, // false 默认 true datepicker的上一月和下一月功能互换 timepicker的上下可点击按钮功能互换 hours12: false, // true设置12小时格式 false设置24小时格式 next: 'xdsoft_next', // 设置datepicker上一月按钮的样式 prev : 'xdsoft_prev', // 设置datepicker下一月按钮的样式 dayOfWeekStart: 0, // 设置默认第-列为周几 如：0 周日 1 周一 parentID: 'body', // 设置父级选择器 timeHeightInTimePicker: 25, // 设置timepicker的行高 timepickerScrollbar: true, // ture设置timepicker显示滑动条 false设置timepicker不显示滑动条 todayButton: true, // ture显示今天按钮 false不显示今天按钮 位置在datepicker左上角 prevButton: true, // ture显示上一月按钮 false不显示上一月按钮 位置在datepicker左上角 nextButton: true, // ture显示下一月按钮 false不显示下一月按钮 位置在datepicker又上角 scrollMonth: true, // ture 设置datepicker的月份可以滑动 false设置datepicker的月份不可以滑动 lazyInit: false, // 翻译： 初始化插件发生只有当用户交互。大大加速插件与大量的领域的工作 mask: false, // 使用输入掩码。真正的-自动生成一个字段的“格式”的面具，从0到9的数字，设置为值的最高可能的数字。例如：第一个小时的数字不能大于2，而第一位数字不能大于5 如：&#123;mask:'9999/19/39 29:59',format:'Y/m/d H:i'&#125; validateOnBlur: true, // 失去焦点时验证datetime值输入,。如果值是无效的datetime,然后插入当前日期时间值 yearStart: 1950, // 设置最小的年份 yearEnd: 2050, // 设置最大的年份 monthStart: 0, // 设置最小的月份 monthEnd: 11, // 设置最大的月份 roundTime: 'round', // 设置timepicker的计算方式 round四舍五入 ceil向上取整 floor向下取整 allowDateRe : null, // 设置正则表达式检查日期 如：&#123;format:'Y-m-d',allowDateRe:'\d&#123;4&#125;-(03-31|06-30|09-30|12-31)' &#125; disabledDates : [], // 设置不可点击的日期 如：disabledDates: ['21.11.2016','22.11.2016','23.11.2016','24.11.2016','25.11.2016','26.11.2016'] disabledWeekDays: [], // 设置不可点击的星期 如：disabledWeekDays:[0,3,4] yearOffset: 0, // 设置偏移年份 如：2 代表当前年份加2 -2 代表当前年份减2 beforeShowDay: null, // 显示datetimepicker之前可调用的方法 &#123;beforeShowDay:function(d) &#123;console.log("bsd"); &#125; &#125; enterLikeTab: true, // tab按键均可使datetimepicker关闭 true点击回车键可使datetimepicker关闭 false点击回车键不可使datetimepicker关闭 showApplyButton: false // 相当于确定按钮 true显示 false隐藏&#125;); jquery datetimepicker的相关点击方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* * 监听时间插件显示时的事件 */$('#datetimepicker').datetimepicker(&#123; onShow: function(dateText, inst) &#123; console.log("---已打开datetimepicker----"); &#125;&#125;); /* * 监听时间插件关闭时的事件 */$('#datetimepicker').datetimepicker(&#123; onClose: function(dateText, inst) &#123; console.log("---已关闭datetimepicker----"); &#125;&#125;); /* * 监听点击日期时的事件 */ $('#datetimepicker').datetimepicker(&#123; onSelectDate: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;); /* * 监听点击时分的事件 */ $('#datetimepicker').datetimepicker(&#123; onSelectTime: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;); /* * 监听点击datepicker 上一月下一月按钮及选择月份点击事件 */$('#datetimepicker').datetimepicker(&#123; onChangeMonth: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;);/* * 监听获取当前datetimepicker显示的所有日期信息 */$('#datetimepicker').datetimepicker(&#123; onGetWeekOfYear: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;); /* * 监听选择年份的点击事件 */$('#datetimepicker').datetimepicker(&#123; onChangeYear: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;); /* * 实时监听你选择的日期和时间 */$('#datetimepicker').datetimepicker(&#123; onChangeDateTime: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;); /* * 实时监听datetimepicker上的所有事件 */$('#datetimepicker').datetimepicker(&#123; onGenerate: function(dateText, inst) &#123; console.log(dateText); &#125;&#125;);]]></content>
      <categories>
        <category>jq</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>教程</tag>
        <tag>jq</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[store.js的使用 -- 本地存储localStorage的封装插件]]></title>
    <url>%2F2018%2F02%2F08%2Fstore%2F</url>
    <content type="text"><![CDATA[store.js 是一个兼容所有浏览器的 LocalStorage 包装器，不需要借助 Cookie 或者 Flash来实现。它提供非常了简洁的 API 来实现跨浏览器的本地存储功能。使用store,js简化了使用localStorage原生方法的操作。本文主要介绍如何用store.js操作localStorage。 本地存储localstoragelocalstorage 是 HTML5 提供的在客户端存储数据的新方法，主要作用是将数据保存在客户端中，并且数据是永久保存的，除非人为干预删除。localstorage 的局限1、只有版本较高的浏览器中才支持 localstorage2、localStorage只能存储字符串，使用 JSON 时需转换3、如果存储内容过多会消耗内存空间，导致页面变卡，因为localStorage本质上是对字符串的读取 store.jsGithub地址 store.js 是一个兼容所有浏览器的 LocalStorage 包装器，不需要借助 Cookie 或者 Flash来实现。它提供非常了简洁的 API 来实现跨浏览器的本地存储功能。使用store,js简化了使用localStorage原生方法的操作。 store.js的使用 首先引入store.min.js插件: 1&lt;script src="https://cdn.bootcss.com/store.js/1.3.20/store.min.js"&gt;&lt;/script&gt; 判断浏览器是否支持本地存储 12345678910&lt;script type="text/javascript"&gt; init(); function init()&#123; if(!store.enabled)&#123; alert("你的浏览器不支持本地存储，请使用更高版本的浏览器"); return; &#125;else&#123; ...... &#125; &lt;/script&gt; 开始愉快地使用store.js吧~store.js的基本API有： 123456store.set(key, val) //存储 key 的值为 val；store.get(key) //获取 key 的值；store.remove(key) //移除 key 的记录；store.clear() //清空存储；store.getAll() //返回所有存储；store.forEach() //遍历所有存储。 使用方法：123456789101112131415161718store.set('username', 'marcus') store.get('username') store.remove('username') store.clear() store.set('user', &#123; name: 'marcus', likes: 'javascript' &#125;) var user = store.get('user') alert(user.name + ' likes ' + user.likes) // Get all stored values store.getAll().user.name == 'marcus' // Loop over all stored values store.forEach(function(key, val) &#123; console.log(key, '==', val) &#125;) set 单个存储字符格式：store.set(key, data[, overwrite]);123456789101112131415161718192021store.set('name','mavis'); //存储name的值为 mavisstore.set('name','angel'); //将name的值存储为angel例如：store.set('容器1', json)``` 在控制台显示 ![](https://sfault-image.b0.upaiyun.com/282/193/2821938934-5831460c5a712) ---- get 获取存入的key值 格式：`store.get(key[, alt]);` get获取时，有时需要判断是否存在localStorage```javascriptstore.set('name','mavis');store.set('name','angel');store.get('name'); //angel例如：var json = &#123;1:1,2:2,3:3,4:4&#125;;store.set('容器1', json)store.get('容器1');//&#123;1:1,2:2,3:3,4:4&#125; remove 移除key的记录1store.remove('name'); 在控制台可以看到name的值已经被移除 store.clear(); 清空所有本地存储 getAll 从所有存储中获取值格式：store.getAll() 12store.set('name','mavis');store.getAll().user.name == 'mavis'; //true forEach 遍历所有的值 12345store.set('user',&#123;name:'mavis',likes:'javascript'&#125;); // 存储对象 - 自动调用 JSON.stringifyvar user = store.get('user'); // 获取存储的对象 - 自动执行 JSON.parsestore.forEach(function(key, val) &#123; console.log(key, '==', val) &#125;) // 遍历所有存储 store.has(key)``javascriptconsole( store.has(‘容器1’) );//trueconsole( store.has(‘容器2’) );//false``` 在浏览器中查看LocalStorage的方法F12打开开发人员工具→Application→Storage→LocalStorage]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>教程</tag>
        <tag>jq</tag>
        <tag>插件</tag>
      </tags>
  </entry>
</search>
